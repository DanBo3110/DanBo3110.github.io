<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="GISer加油站"><meta name="keywords" content="DanBoCode, 代码, 程序, gis, js, 前端"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><title>Colletion集合 | DanBoCode</title></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Colletion集合</h1><a id="logo" href="/.">DanBoCode</a><p class="description">句子跟标点落入四个区间，有人能懂真理，有人读出文艺。</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Colletion集合</h1><div class="post-meta"><a href="/2019/10/23/Colletion集合/#comments" class="comment-count"></a><p><span class="date">Oct 23, 2019</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h3 id="对象数组的概述和使用"><a href="#对象数组的概述和使用" class="headerlink" title="(对象数组的概述和使用)"></a>(对象数组的概述和使用)</h3><ul>
<li><p>A:案例演示</p>
<ul>
<li>需求：我有5个学生，请把这个5个学生的信息存储到数组中，并遍历数组，获取得到每一个学生信息。</li>
</ul>
</li>
<li><pre><code>Student[] arr = new Student[5];                    //存储学生对象
arr[0] = new Student(&quot;张三&quot;, 23);
arr[1] = new Student(&quot;李四&quot;, 24);
arr[2] = new Student(&quot;王五&quot;, 25);
arr[3] = new Student(&quot;赵六&quot;, 26);
arr[4] = new Student(&quot;马哥&quot;, 20);

for (int i = 0; i &lt; arr.length; i++) {
    System.out.println(arr[i]);
}</code></pre></li>
<li><p>B:画图演示</p>
<ul>
<li>把学生数组的案例画图讲解</li>
<li>数组和集合存储引用数据类型,存的都是地址值</li>
</ul>
</li>
</ul>
<h3 id="集合的由来及集合继承体系图"><a href="#集合的由来及集合继承体系图" class="headerlink" title="(集合的由来及集合继承体系图)"></a>(集合的由来及集合继承体系图)</h3><ul>
<li>A:集合的由来<ul>
<li>数组长度是固定,当添加的元素超过了数组的长度时需要对数组重新定义,太麻烦,java内部给我们提供了集合类,能存储任意对象,长度是可以改变的,随着元素的增加而增加,随着元素的减少而减少 </li>
</ul>
</li>
<li>B:数组和集合的区别<ul>
<li>区别1 : <ul>
<li>数组既可以存储基本数据类型,又可以存储引用数据类型,基本数据类型存储的是值,引用数据类型存储的是地址值</li>
<li>集合只能存储引用数据类型(对象)集合中也可以存储基本数据类型,但是在存储的时候会自动装箱变成对象</li>
</ul>
</li>
<li>区别2:<ul>
<li>数组长度是固定的,不能自动增长</li>
<li>集合的长度的是可变的,可以根据元素的增加而增长</li>
</ul>
</li>
</ul>
</li>
<li>C:数组和集合什么时候用<pre><code>* 1,如果元素个数是固定的推荐用数组
* 2,如果元素个数不是固定的推荐用集合</code></pre></li>
<li>D:集合继承体系图</li>
</ul>
<h3 id="Collection集合的基本功能测试"><a href="#Collection集合的基本功能测试" class="headerlink" title="(Collection集合的基本功能测试)"></a>(Collection集合的基本功能测试)</h3><ul>
<li><p>A:案例演示    </p>
</li>
<li><pre><code>基本功能演示

boolean add(E e)
boolean remove(Object o)
void clear()
boolean contains(Object o)
boolean isEmpty()
int size()</code></pre></li>
<li><p>B:注意:</p>
</li>
<li><pre><code>collectionXxx.java使用了未经检查或不安全的操作.
注意:要了解详细信息,请使用 -Xlint:unchecked重新编译.
java编译器认为该程序存在安全隐患
温馨提示:这不是编译失败,所以先不用理会,等学了泛型你就知道了</code></pre></li>
</ul>
<h3 id="集合的遍历之集合转数组遍历"><a href="#集合的遍历之集合转数组遍历" class="headerlink" title="(集合的遍历之集合转数组遍历)"></a>(集合的遍历之集合转数组遍历)</h3><ul>
<li><p>A:集合的遍历</p>
<ul>
<li>其实就是依次获取集合中的每一个元素。</li>
</ul>
</li>
<li><p>B:案例演示</p>
<ul>
<li><p>把集合转成数组，可以实现集合的遍历</p>
</li>
<li><p>toArray()</p>
</li>
<li><pre><code>Collection coll = new ArrayList();
coll.add(new Student(&quot;张三&quot;,23));        //Object obj = new Student(&quot;张三&quot;,23);
coll.add(new Student(&quot;李四&quot;,24));
coll.add(new Student(&quot;王五&quot;,25));
coll.add(new Student(&quot;赵六&quot;,26));

Object[] arr = coll.toArray();                //将集合转换成数组
for (int i = 0; i &lt; arr.length; i++) {
    Student s = (Student)arr[i];            //强转成Student
    System.out.println(s.getName() + &quot;,&quot; + s.getAge());
}</code></pre></li>
</ul>
</li>
</ul>
<h3 id="Collection集合的带All功能测试"><a href="#Collection集合的带All功能测试" class="headerlink" title="(Collection集合的带All功能测试)"></a>(Collection集合的带All功能测试)</h3><ul>
<li><p>A:案例演示</p>
</li>
<li><pre><code>带All的功能演示

boolean addAll(Collection c)
boolean removeAll(Collection c)
boolean containsAll(Collection c)
boolean retainAll(Collection c)</code></pre></li>
</ul>
<h3 id="集合的遍历之迭代器遍历"><a href="#集合的遍历之迭代器遍历" class="headerlink" title="(集合的遍历之迭代器遍历)"></a>(集合的遍历之迭代器遍历)</h3><ul>
<li><p>A:迭代器概述</p>
<ul>
<li>集合是用来存储元素,存储的元素需要查看,那么就需要迭代(遍历) </li>
</ul>
</li>
<li><p>B:案例演示</p>
<ul>
<li><p>迭代器的使用</p>
<pre><code>Collection c = new ArrayList();
c.add(&quot;a&quot;);
c.add(&quot;b&quot;);
c.add(&quot;c&quot;);
c.add(&quot;d&quot;);

Iterator it = c.iterator();                        //获取迭代器的引用
while(it.hasNext()) {                            //集合中的迭代方法(遍历)
    System.out.println(it.next());
}</code></pre></li>
</ul>
</li>
</ul>
<h3 id="Collection存储自定义对象并遍历"><a href="#Collection存储自定义对象并遍历" class="headerlink" title="(Collection存储自定义对象并遍历)"></a>(Collection存储自定义对象并遍历)</h3><ul>
<li><p>A:案例演示</p>
<ul>
<li><p>Collection存储自定义对象并用迭代器遍历</p>
</li>
<li><pre><code>Collection c = new ArrayList();

c.add(new Student(&quot;张三&quot;,23));
c.add(new Student(&quot;李四&quot;,24));
c.add(new Student(&quot;王五&quot;,25));
c.add(new Student(&quot;赵六&quot;,26));
c.add(new Student(&quot;赵六&quot;,26));

for(Iterator it = c.iterator();it.hasNext();) {
    Student s = (Student)it.next();                        //向下转型
    System.out.println(s.getName() + &quot;,&quot; + s.getAge());    //获取对象中的姓名和年龄
}
System.out.println(&quot;------------------------------&quot;);
Iterator it = c.iterator();                                //获取迭代器
while(it.hasNext()) {                                    //判断集合中是否有元素
    //System.out.println(((Student)(it.next())).getName() + &quot;,&quot; + ((Student)(it.next())).getAge());
    Student s = (Student)it.next();                        //向下转型
    System.out.println(s.getName() + &quot;,&quot; + s.getAge());    //获取对象中的姓名和年龄
}</code></pre></li>
</ul>
</li>
</ul>
<h3 id="迭代器的原理及源码解析-了解"><a href="#迭代器的原理及源码解析-了解" class="headerlink" title="(迭代器的原理及源码解析)(了解)"></a>(迭代器的原理及源码解析)(了解)</h3><ul>
<li>A:迭代器原理<ul>
<li>迭代器原理:迭代器是对集合进行遍历,而每一个集合内部的存储结构都是不同的,所以每一个集合存和取都是不一样,那么就需要在每一个类中定义hasNext()和next()方法,这样做是可以的,但是会让整个集合体系过于臃肿,迭代器是将这样的方法向上抽取出接口,然后在每个类的内部,定义自己迭代方式,这样做的好处有二,第一规定了整个集合体系的遍历方式都是hasNext()和next()方法,第二,代码有底层内部实现,使用者不用管怎么实现的,会用即可 </li>
</ul>
</li>
<li>B:迭代器源码解析<ul>
<li>1,在eclipse中ctrl + shift + t找到ArrayList类</li>
<li>2,ctrl+o查找iterator()方法</li>
<li>3,查看返回值类型是new Itr(),说明Itr这个类实现Iterator接口</li>
<li>4,查找Itr这个内部类,发现重写了Iterator中的所有抽象方法 </li>
</ul>
</li>
</ul>
<h3 id="List集合的特有功能概述和测试"><a href="#List集合的特有功能概述和测试" class="headerlink" title="(List集合的特有功能概述和测试)"></a>(List集合的特有功能概述和测试)</h3><ul>
<li>A:List集合的特有功能概述<ul>
<li>void add(int index,E element)</li>
<li>E remove(int index)</li>
<li>E get(int index)</li>
<li>E set(int index,E element)</li>
</ul>
</li>
</ul>
<h3 id="List集合存储学生对象并遍历"><a href="#List集合存储学生对象并遍历" class="headerlink" title="(List集合存储学生对象并遍历)"></a>(List集合存储学生对象并遍历)</h3><ul>
<li><p>A:案例演示</p>
<ul>
<li><p>通过size()和get()方法结合使用遍历。</p>
<pre><code>List list = new ArrayList();
list.add(new Student(&quot;张三&quot;, 18));
list.add(new Student(&quot;李四&quot;, 18));
list.add(new Student(&quot;王五&quot;, 18));
list.add(new Student(&quot;赵六&quot;, 18));

for(int i = 0; i &lt; list.size(); i++) {
    Student s = (Student)list.get(i);
    System.out.println(s.getName() + &quot;,&quot; + s.getAge());
}</code></pre></li>
</ul>
</li>
</ul>
<h3 id="并发修改异常产生的原因及解决方案"><a href="#并发修改异常产生的原因及解决方案" class="headerlink" title="(并发修改异常产生的原因及解决方案)"></a>(并发修改异常产生的原因及解决方案)</h3><ul>
<li><p>A:案例演示</p>
<ul>
<li><p>需求：我有一个集合，请问，我想判断里面有没有”world”这个元素，如果有，我就添加一个”javaee”元素，请写代码实现。</p>
<pre><code>List list = new ArrayList();
list.add(&quot;a&quot;);
list.add(&quot;b&quot;);
list.add(&quot;world&quot;);
list.add(&quot;d&quot;);
list.add(&quot;e&quot;);

/*Iterator it = list.iterator();
while(it.hasNext()) {
    String str = (String)it.next();
    if(str.equals(&quot;world&quot;)) {
        list.add(&quot;javaee&quot;);            //这里会抛出ConcurrentModificationException并发修改异常
    }
}*/</code></pre></li>
</ul>
</li>
</ul>
<ul>
<li><p>B:ConcurrentModificationException出现</p>
<ul>
<li>迭代器遍历，集合修改集合</li>
</ul>
</li>
<li><p>C:解决方案</p>
<ul>
<li><p>a:迭代器迭代元素，迭代器修改元素(ListIterator的特有功能add)</p>
</li>
<li><p>b:集合遍历元素，集合修改元素</p>
<pre><code>ListIterator lit = list.listIterator();        //如果想在遍历的过程中添加元素,可以用ListIterator中的add方法
while(lit.hasNext()) {
    String str = (String)lit.next();
    if(str.equals(&quot;world&quot;)) {
        lit.add(&quot;javaee&quot;);    
        //list.add(&quot;javaee&quot;);
    }
}</code></pre></li>
</ul>
</li>
</ul>
<h3 id="ListIterator-了解"><a href="#ListIterator-了解" class="headerlink" title="(ListIterator)(了解)"></a>(ListIterator)(了解)</h3><ul>
<li>boolean hasNext()是否有下一个</li>
<li>boolean hasPrevious()是否有前一个</li>
<li>Object next()返回下一个元素</li>
<li>Object previous();返回上一个元素</li>
</ul>
<h3 id="Vector的特有功能-了解"><a href="#Vector的特有功能-了解" class="headerlink" title="(Vector的特有功能)(了解)"></a>(Vector的特有功能)(了解)</h3><ul>
<li><p>A:Vector类概述</p>
</li>
<li><p>B:Vector类特有功能</p>
<ul>
<li>public void addElement(E obj)</li>
<li>public E elementAt(int index)</li>
<li>public Enumeration elements()</li>
</ul>
</li>
<li><p>C:案例演示    </p>
<ul>
<li><p>Vector的迭代</p>
<pre><code>Vector v = new Vector();                //创建集合对象,List的子类
v.addElement(&quot;a&quot;);
v.addElement(&quot;b&quot;);
v.addElement(&quot;c&quot;);
v.addElement(&quot;d&quot;);

//Vector迭代
Enumeration en = v.elements();            //获取枚举
while(en.hasMoreElements()) {            //判断集合中是否有元素
    System.out.println(en.nextElement());//获取集合中的元素
}</code></pre></li>
</ul>
</li>
</ul>
<h3 id="数据结构之数组和链表"><a href="#数据结构之数组和链表" class="headerlink" title="(数据结构之数组和链表)"></a>(数据结构之数组和链表)</h3><ul>
<li>A:数组<ul>
<li>查询快修改也快</li>
<li>增删慢</li>
</ul>
</li>
<li>B:链表<ul>
<li>查询慢,修改也慢</li>
<li>增删快</li>
</ul>
</li>
</ul>
<h3 id="List的三个子类的特点"><a href="#List的三个子类的特点" class="headerlink" title="(List的三个子类的特点)"></a>(List的三个子类的特点)</h3><ul>
<li><p>A:List的三个子类的特点</p>
</li>
<li><pre><code>ArrayList:
    底层数据结构是数组，查询快，增删慢。
    线程不安全，效率高。
Vector:
    底层数据结构是数组，查询快，增删慢。
    线程安全，效率低。
Vector相对ArrayList查询慢(线程安全的)
Vector相对LinkedList增删慢(数组结构)
LinkedList:
    底层数据结构是链表，查询慢，增删快。
    线程不安全，效率高。

Vector和ArrayList的区别
    Vector是线程安全的,效率低
    ArrayList是线程不安全的,效率高
共同点:都是数组实现的
ArrayList和LinkedList的区别
    ArrayList底层是数组结果,查询和修改快
    LinkedList底层是链表结构的,增和删比较快,查询和修改比较慢
共同点:都是线程不安全的</code></pre></li>
<li><p>B:List有三个儿子，我们到底使用谁呢?</p>
<pre><code>查询多用ArrayList
增删多用LinkedList
如果都多ArrayList</code></pre></li>
</ul>
</div><div class="post-copyright"><blockquote><p>原文作者: 冯亚杰(DanBoard·Feng)</p><p>原文链接: <a href="http://yoursite.com/2019/10/23/Colletion集合/">http://yoursite.com/2019/10/23/Colletion集合/</a></p><p>版权声明: 转载请注明出处(必须保留作者署名及链接)</p></blockquote></div><div class="tags"></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2019/10/23/Eclipse基本配置（eclipse初使用必看，从小白到大白）/" class="pre">Eclipse基本配置（eclipse初使用必看，从小白到大白）</a><a href="/2019/10/23/ArcGIS API for JavaScript/" class="next">ArcGIS API for JavaScript</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#对象数组的概述和使用"><span class="toc-text">(对象数组的概述和使用)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#集合的由来及集合继承体系图"><span class="toc-text">(集合的由来及集合继承体系图)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Collection集合的基本功能测试"><span class="toc-text">(Collection集合的基本功能测试)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#集合的遍历之集合转数组遍历"><span class="toc-text">(集合的遍历之集合转数组遍历)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Collection集合的带All功能测试"><span class="toc-text">(Collection集合的带All功能测试)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#集合的遍历之迭代器遍历"><span class="toc-text">(集合的遍历之迭代器遍历)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Collection存储自定义对象并遍历"><span class="toc-text">(Collection存储自定义对象并遍历)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#迭代器的原理及源码解析-了解"><span class="toc-text">(迭代器的原理及源码解析)(了解)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List集合的特有功能概述和测试"><span class="toc-text">(List集合的特有功能概述和测试)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List集合存储学生对象并遍历"><span class="toc-text">(List集合存储学生对象并遍历)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#并发修改异常产生的原因及解决方案"><span class="toc-text">(并发修改异常产生的原因及解决方案)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ListIterator-了解"><span class="toc-text">(ListIterator)(了解)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector的特有功能-了解"><span class="toc-text">(Vector的特有功能)(了解)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据结构之数组和链表"><span class="toc-text">(数据结构之数组和链表)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List的三个子类的特点"><span class="toc-text">(List的三个子类的特点)</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/01/11/计算机地图制图 知识总结/">计算机地图制图 知识总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/11/GIS程序设计 知识总结/">GIS程序设计 知识总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/11/空间数据库总结/">空间数据库总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/11/GPS测量原理及应用 知识总结/">GPS测量原理及应用 知识总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/11/github码云操作---合并分支，推送/">github/码云操作---合并分支，推送</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/11/IDEA连接Mysql数据库没有jar包，报错/">IDEA连接Mysql数据库没有jar包报错</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/07/Vue工程化环境(模块化规范、webpack、单文件组件、脚手架、Element-UI)/">Vue工程化</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/03/解决nodejs报错 Cannot find module/">完美解决nodejs报错 Cannot find module './application'</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/25/AE - 04.专题图绘制及打印功能实现/">AE - 04.专题图绘制及打印功能实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/25/AE - 01.空间书签的创建及调用/">AE - 01.空间书签的创建及调用</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">十二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://blog.csdn.net/DanBo_C" title="CSDN" target="_blank">CSDN</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">冯亚杰(DanBoard·Feng).</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>