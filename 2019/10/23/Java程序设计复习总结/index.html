<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="GISer加油站"><meta name="keywords" content="DanBoCode, 代码, 程序, gis, js, 前端"><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.4"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.4"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><title>Java程序设计复习总结 | DanBoCode</title></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Java程序设计复习总结</h1><a id="logo" href="/.">DanBoCode</a><p class="description">句子跟标点落入四个区间，有人能懂真理，有人读出文艺。</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Java程序设计复习总结</h1><div class="post-meta"><a href="/2019/10/23/Java程序设计复习总结/#comments" class="comment-count"></a><p><span class="date">Oct 23, 2019</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h2 id="Java程序设计期中复习总结"><a href="#Java程序设计期中复习总结" class="headerlink" title="Java程序设计期中复习总结"></a>Java程序设计期中复习总结</h2><h3 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章 概述"></a>第一章 概述</h3><h6 id="1-应用程序的结构：package-import-class"><a href="#1-应用程序的结构：package-import-class" class="headerlink" title="1. 应用程序的结构：package import class"></a>1. 应用程序的结构：package import class</h6><h6 id="2-源文件的扩展名-java，字节文件的扩展名：-class"><a href="#2-源文件的扩展名-java，字节文件的扩展名：-class" class="headerlink" title="2. 源文件的扩展名.java，字节文件的扩展名：.class"></a>2. 源文件的扩展名.java，字节文件的扩展名：.class</h6><h6 id="3-Java语言的工作原理：先编译后解释"><a href="#3-Java语言的工作原理：先编译后解释" class="headerlink" title="3. Java语言的工作原理：先编译后解释"></a>3. Java语言的工作原理：先编译后解释</h6><h6 id="4-一个源文件中最多可以有一个public类，并且文件名与public类名相同。"><a href="#4-一个源文件中最多可以有一个public类，并且文件名与public类名相同。" class="headerlink" title="4. 一个源文件中最多可以有一个public类，并且文件名与public类名相同。"></a>4. 一个源文件中最多可以有一个public类，并且文件名与public类名相同。</h6><h6 id="5-常用命令javac编译，java运行。"><a href="#5-常用命令javac编译，java运行。" class="headerlink" title="5. 常用命令javac编译，java运行。"></a>5. 常用命令javac编译，java运行。</h6><h6 id="6-一个应用程序最少有一个main方法。"><a href="#6-一个应用程序最少有一个main方法。" class="headerlink" title="6. 一个应用程序最少有一个main方法。"></a>6. 一个应用程序最少有一个main方法。</h6><hr>
<h3 id="第二章-Java基础"><a href="#第二章-Java基础" class="headerlink" title="第二章 Java基础"></a>第二章 Java基础</h3><h6 id="1-标识符命名规则，能够区分合法标识符"><a href="#1-标识符命名规则，能够区分合法标识符" class="headerlink" title="1. 标识符命名规则，能够区分合法标识符"></a>1. 标识符命名规则，能够区分合法标识符</h6><pre><code>标识符命名规则
1. 标识符由26个英文字符大小写（a~zA~Z）、数字(0~9)、下划线(_)和美元符号($)组成。
2. 不能以数字开头，不能是关键字。
3. 严格区分大小写。
4. 标识符的可以为任意长度。</code></pre><h6 id="2-所有关键字都是小写"><a href="#2-所有关键字都是小写" class="headerlink" title="2. 所有关键字都是小写"></a>2. 所有关键字都是小写</h6><h6 id="3-基本数据类型的名称、长度和默认值，注意float类型的定义方法：float-f-3-14F；float-f-3-14f；没有大写或者小写f是错误的。"><a href="#3-基本数据类型的名称、长度和默认值，注意float类型的定义方法：float-f-3-14F；float-f-3-14f；没有大写或者小写f是错误的。" class="headerlink" title="3. 基本数据类型的名称、长度和默认值，注意float类型的定义方法：float f=3.14F；float f=3.14f；没有大写或者小写f是错误的。"></a>3. 基本数据类型的名称、长度和默认值，注意float类型的定义方法：float f=3.14F；float f=3.14f；没有大写或者小写f是错误的。</h6><h6 id="4-while和do-while的区别"><a href="#4-while和do-while的区别" class="headerlink" title="4. while和do-while的区别"></a>4. while和do-while的区别</h6><ul>
<li>do-while语句</li>
</ul>
<pre><code>后测试循环语句，即只有在循环体中的代码执行之后，才会测试出口条件。</code></pre><ul>
<li><p>while语句</p>
<p>  前测试循环语句，即在循环体内的代码被执行之前，就会对出口条件求值。</p>
</li>
</ul>
<h6 id="5-数组使用length属性获得长度"><a href="#5-数组使用length属性获得长度" class="headerlink" title="5. 数组使用length属性获得长度"></a>5. 数组使用length属性获得长度</h6><pre><code>int[] arr={&quot;11&quot;,&quot;22&quot;,33&quot;};
arr.length;//3</code></pre><h6 id="6-int-a-b-c是定义了3个数组，int-a-b-c是定义了一个数组a，两个变量b，c"><a href="#6-int-a-b-c是定义了3个数组，int-a-b-c是定义了一个数组a，两个变量b，c" class="headerlink" title="6. int [] a,b,c是定义了3个数组，int a[],b,c是定义了一个数组a，两个变量b，c"></a>6. int [] a,b,c是定义了3个数组，int a[],b,c是定义了一个数组a，两个变量b，c</h6><h6 id="7-掌握基本数据类型的名称、长度、默认值和数据类型对应的封装类"><a href="#7-掌握基本数据类型的名称、长度、默认值和数据类型对应的封装类" class="headerlink" title="7. 掌握基本数据类型的名称、长度、默认值和数据类型对应的封装类"></a>7. 掌握基本数据类型的名称、长度、默认值和数据类型对应的封装类</h6><p><img src="https://img-blog.csdnimg.cn/20190426132236356.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70" alt></p>
<h6 id="8-字符串转基本类型的方法"><a href="#8-字符串转基本类型的方法" class="headerlink" title="8. 字符串转基本类型的方法"></a>8. 字符串转基本类型的方法</h6><ul>
<li><p>字符串转换为基本类型</p>
<ol>
<li><p>Integer包装类的parseXxx静态方法</p>
</li>
<li><p>Integer包装类的valueOf()方法[自动拆箱]</p>
<blockquote>
<p>String str = “123”;</p>
<p>int a = Integer.parseInt(str);</p>
<p>int b = Integer.valueOf(str);</p>
</blockquote>
</li>
</ol>
</li>
<li><p>基本类型转换为字符串</p>
<ol>
<li>Integer包装类的toString()方法</li>
<li>String类的valueOf()方法</li>
<li>n + “”<blockquote>
<p>int n = 6;</p>
<p>String str = Integer.toString(n);</p>
<p>String str = String.valueOf(n);</p>
<p>String str = n + “”;</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<hr>
<h3 id="第三章-类和对象"><a href="#第三章-类和对象" class="headerlink" title="第三章 类和对象"></a>第三章 类和对象</h3><h6 id="1-什么是方法的重载"><a href="#1-什么是方法的重载" class="headerlink" title="1. 什么是方法的重载"></a>1. 什么是方法的重载</h6><ul>
<li><p>名字相同，参数列表不同的两个（或多个）方法</p>
<ol>
<li>参数类型不同</li>
<li>参数个数不同</li>
</ol>
</li>
<li><p>重载方法的依据方法参数列表的不同，是编译器用来区分调用哪一个</p>
</li>
</ul>
<h6 id="2-构造方法是用来进行成员变量初始化的"><a href="#2-构造方法是用来进行成员变量初始化的" class="headerlink" title="2. 构造方法是用来进行成员变量初始化的"></a>2. 构造方法是用来进行成员变量初始化的</h6><h6 id="3-构造方法的名字和类名相同"><a href="#3-构造方法的名字和类名相同" class="headerlink" title="3. 构造方法的名字和类名相同"></a>3. 构造方法的名字和类名相同</h6><h6 id="4-构造方法可以有也可以没有，没有系统会自动添加一个无参的方法，也可以有多个构造方法，构造方法可重载"><a href="#4-构造方法可以有也可以没有，没有系统会自动添加一个无参的方法，也可以有多个构造方法，构造方法可重载" class="headerlink" title="4. 构造方法可以有也可以没有，没有系统会自动添加一个无参的方法，也可以有多个构造方法，构造方法可重载"></a>4. 构造方法可以有也可以没有，没有系统会自动添加一个无参的方法，也可以有多个构造方法，构造方法可重载</h6><h6 id="5-static关键字可以修饰变量和方法，可以使用类名直接调用，也可以使用对象调用"><a href="#5-static关键字可以修饰变量和方法，可以使用类名直接调用，也可以使用对象调用" class="headerlink" title="5. static关键字可以修饰变量和方法，可以使用类名直接调用，也可以使用对象调用"></a>5. static关键字可以修饰变量和方法，可以使用类名直接调用，也可以使用对象调用</h6><h6 id="6-public、private、默认、peorected修饰符可以修饰什么？作用范围分别是什么"><a href="#6-public、private、默认、peorected修饰符可以修饰什么？作用范围分别是什么" class="headerlink" title="6. public、private、默认、peorected修饰符可以修饰什么？作用范围分别是什么"></a>6. public、private、默认、peorected修饰符可以修饰什么？作用范围分别是什么</h6><ul>
<li>public：public表明该数据成员、成员函数是对所有用户开放的，所有用户都可以直接进行调用 </li>
<li>private：私有.就是除了class自己之外，任何人都不可以直接使用，即便是子女，朋友，都不可以使用。</li>
<li>protected：对于子女、朋友来说，是public可以自由使用，没有限制，而对于其他的外部class，protected就变成private。 </li>
<li>默认(无修饰词)，同一个包内可以访问，包级访问权限；</li>
</ul>
<p>权限修饰符用来修饰类、接口、方法、变量。</p>
<ul>
<li>修饰类：public、默认（default）。</li>
<li>修饰接口：public、默认（default）。</li>
<li>修饰方法：private、默认、protected、public</li>
<li>修饰变量：private、默认、protected、public</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190426132259697.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h6 id="7-类、方法和变量等可以使用多个修饰符修饰"><a href="#7-类、方法和变量等可以使用多个修饰符修饰" class="headerlink" title="7. 类、方法和变量等可以使用多个修饰符修饰"></a>7. 类、方法和变量等可以使用多个修饰符修饰</h6><h6 id="8-所有类的直接或者间接父类是Object类"><a href="#8-所有类的直接或者间接父类是Object类" class="headerlink" title="8. 所有类的直接或者间接父类是Object类"></a>8. 所有类的直接或者间接父类是Object类</h6><hr>
<h3 id="第四章-继承"><a href="#第四章-继承" class="headerlink" title="第四章 继承"></a>第四章 继承</h3><h6 id="1-类之间使用extends关键字继承"><a href="#1-类之间使用extends关键字继承" class="headerlink" title="1. 类之间使用extends关键字继承"></a>1. 类之间使用extends关键字继承</h6><h6 id="2-子类继承父类成员后，在子类中定义与父类相同的成员叫重写（覆盖）"><a href="#2-子类继承父类成员后，在子类中定义与父类相同的成员叫重写（覆盖）" class="headerlink" title="2. 子类继承父类成员后，在子类中定义与父类相同的成员叫重写（覆盖）"></a>2. 子类继承父类成员后，在子类中定义与父类相同的成员叫重写（覆盖）</h6><h6 id="3-final修饰类、变量和方法，不能被继承和改写"><a href="#3-final修饰类、变量和方法，不能被继承和改写" class="headerlink" title="3. final修饰类、变量和方法，不能被继承和改写"></a>3. final修饰类、变量和方法，不能被继承和改写</h6><h6 id="4-Java所有的类都是java-lang-Object类的子类"><a href="#4-Java所有的类都是java-lang-Object类的子类" class="headerlink" title="4. Java所有的类都是java.lang.Object类的子类"></a>4. Java所有的类都是java.lang.Object类的子类</h6><hr>
<h3 id="第五章-抽象类、接口"><a href="#第五章-抽象类、接口" class="headerlink" title="第五章 抽象类、接口"></a>第五章 抽象类、接口</h3><h6 id="1-定义接口使用interface，实现接口implements"><a href="#1-定义接口使用interface，实现接口implements" class="headerlink" title="1. 定义接口使用interface，实现接口implements"></a>1. 定义接口使用interface，实现接口implements</h6><h6 id="2-abstract修饰的类为抽象类，方法为抽象方法，抽象方法没有方法体"><a href="#2-abstract修饰的类为抽象类，方法为抽象方法，抽象方法没有方法体" class="headerlink" title="2. abstract修饰的类为抽象类，方法为抽象方法，抽象方法没有方法体"></a>2. abstract修饰的类为抽象类，方法为抽象方法，抽象方法没有方法体</h6><h6 id="3-抽象类可以没有抽象方法，有抽象方法的类必定是抽象类"><a href="#3-抽象类可以没有抽象方法，有抽象方法的类必定是抽象类" class="headerlink" title="3. 抽象类可以没有抽象方法，有抽象方法的类必定是抽象类"></a>3. 抽象类可以没有抽象方法，有抽象方法的类必定是抽象类</h6><h6 id="4-使用interface关键字定义接口，类使用implements实现（继承）接口"><a href="#4-使用interface关键字定义接口，类使用implements实现（继承）接口" class="headerlink" title="4. 使用interface关键字定义接口，类使用implements实现（继承）接口"></a>4. 使用interface关键字定义接口，类使用implements实现（继承）接口</h6><h6 id="5-接口中只有常量和抽象方法，并且都是public-abstract的抽象方法，都是public-static-final的常量"><a href="#5-接口中只有常量和抽象方法，并且都是public-abstract的抽象方法，都是public-static-final的常量" class="headerlink" title="5. 接口中只有常量和抽象方法，并且都是public abstract的抽象方法，都是public static final的常量"></a>5. 接口中只有常量和抽象方法，并且都是public abstract的抽象方法，都是public static final的常量</h6><h6 id="6-接口可以实现多重继承，定义类的模板"><a href="#6-接口可以实现多重继承，定义类的模板" class="headerlink" title="6. 接口可以实现多重继承，定义类的模板"></a>6. 接口可以实现多重继承，定义类的模板</h6><h6 id="7-多态有两种体现重载和重写（覆盖），重载称为编译时多态，重写为运行时多态"><a href="#7-多态有两种体现重载和重写（覆盖），重载称为编译时多态，重写为运行时多态" class="headerlink" title="7. 多态有两种体现重载和重写（覆盖），重载称为编译时多态，重写为运行时多态"></a>7. 多态有两种体现重载和重写（覆盖），重载称为编译时多态，重写为运行时多态</h6><hr>
<h3 id="第六章-字符串"><a href="#第六章-字符串" class="headerlink" title="第六章 字符串"></a>第六章 字符串</h3><h6 id="1-字符串分为静态字符串（String）和动态字符串（StringBuffer）"><a href="#1-字符串分为静态字符串（String）和动态字符串（StringBuffer）" class="headerlink" title="1. 字符串分为静态字符串（String）和动态字符串（StringBuffer）"></a>1. 字符串分为静态字符串（String）和动态字符串（StringBuffer）</h6><h6 id="2-使用length（）方法获得字符串的长度"><a href="#2-使用length（）方法获得字符串的长度" class="headerlink" title="2. 使用length（）方法获得字符串的长度"></a>2. 使用length（）方法获得字符串的长度</h6><pre><code>String str=&quot;asdfghjkl&quot;;
str.length();//9</code></pre><h6 id="3-其他常用方法chatAt（）、equals（）"><a href="#3-其他常用方法chatAt（）、equals（）" class="headerlink" title="3. 其他常用方法chatAt（）、equals（）"></a>3. 其他常用方法chatAt（）、equals（）</h6><ul>
<li>chatAt（）<ul>
<li>返回位于字符串的指定索引处的字符</li>
</ul>
</li>
</ul>
<ul>
<li>equals（）<ol>
<li>所有的对象都拥有标识(内存地址)和状态(数据)，“==”比较两个对象的的内存地址，使用Object的equals()方法是比较两个对象的内存地址是否相等，即若object1.equals(object2)为true，则表示equals1和equals2实际上是引用同一个对象。</li>
<li>String、Math等封装类都对equals()方法进行了重写。比较的是两个对象的状态</li>
</ol>
</li>
</ul>
<hr>
<h3 id="第七章-异常处理"><a href="#第七章-异常处理" class="headerlink" title="第七章 异常处理"></a>第七章 异常处理</h3><h6 id="1-什么是异常"><a href="#1-什么是异常" class="headerlink" title="1. 什么是异常"></a>1. 什么是异常</h6><pre><code>异常是程序中的一些错误，但并不是所有的错误都是异常，并且错误有时候是可以避免的。
在程序执行期间发生的事件，它中断正在执行的程序的正常指令流。</code></pre><h6 id="2-为什么要进行异常处理"><a href="#2-为什么要进行异常处理" class="headerlink" title="2. 为什么要进行异常处理"></a>2. 为什么要进行异常处理</h6><p>为了能够及时有效地处理程序中的运行错误，必须使用异常类。</p>
<ul>
<li><p>用户输入了非法数据。</p>
</li>
<li><p>要打开的文件不存在。</p>
</li>
<li><p>网络通信时连接中断，或者JVM内存溢出。</p>
<h6 id="3-所有异常的父类是Throwable类，它有两个直接子类为Error和Exception"><a href="#3-所有异常的父类是Throwable类，它有两个直接子类为Error和Exception" class="headerlink" title="3. 所有异常的父类是Throwable类，它有两个直接子类为Error和Exception"></a>3. 所有异常的父类是Throwable类，它有两个直接子类为Error和Exception</h6></li>
<li><p>Error:程序无法处理的错误，表示运行应用程序中较严重问题。恢复不是不可能但很困难的情况下的一种严重问题。</p>
<p>  例如，内存溢出，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。</p>
</li>
<li><p>Exception:是程序本身可以处理的异常。<br>  exception 设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况</p>
</li>
</ul>
<h6 id="4-异常分为运行时异常和非运行时异常"><a href="#4-异常分为运行时异常和非运行时异常" class="headerlink" title="4. 异常分为运行时异常和非运行时异常"></a>4. 异常分为运行时异常和非运行时异常</h6><p>unchecked exception 非检查异常</p>
<ul>
<li>运行时异常（RuntimeException）</li>
<li>Error</li>
</ul>
<p>对于运行时异常，java编译器不要求必须进行异常捕获处理或者抛出声明，由程序员自行决定。 </p>
<p>checked exception 非运行时异常（运行时异常以外的异常就是非运行时异常）</p>
<ul>
<li>java编译器强制程序员必须进行捕获处理，比如IOExeption和SQLException。</li>
<li>对于非运行时异常如果不进行捕获或者抛出声明处理，编译都不会通过。</li>
</ul>
<h6 id="5-异常的处理过程是先抛弃后捕获"><a href="#5-异常的处理过程是先抛弃后捕获" class="headerlink" title="5. 异常的处理过程是先抛弃后捕获"></a>5. 异常的处理过程是先抛弃后捕获</h6><h6 id="6-处理方法有三种："><a href="#6-处理方法有三种：" class="headerlink" title="6. 处理方法有三种："></a>6. 处理方法有三种：</h6><ul>
<li>运行时异常可回避</li>
<li>throws可回避交给上级调用模块处理</li>
<li>try-catch-finally自行处理</li>
</ul>
<h6 id="7-进行异常捕获时，先发生的放在前面，后发生的放后面；子类异常放前面，父类放后面"><a href="#7-进行异常捕获时，先发生的放在前面，后发生的放后面；子类异常放前面，父类放后面" class="headerlink" title="7. 进行异常捕获时，先发生的放在前面，后发生的放后面；子类异常放前面，父类放后面"></a>7. 进行异常捕获时，先发生的放在前面，后发生的放后面；子类异常放前面，父类放后面</h6><h6 id="8-使用throw制造异常"><a href="#8-使用throw制造异常" class="headerlink" title="8. 使用throw制造异常"></a>8. 使用throw制造异常</h6><p>throw 抛出的只能够是可抛出类Throwable 或者其子类的实例对象</p>
<hr>
<h3 id="第八章-输入输出"><a href="#第八章-输入输出" class="headerlink" title="第八章 输入输出"></a>第八章 输入输出</h3><h6 id="1-输入输出需要引入java-io包"><a href="#1-输入输出需要引入java-io包" class="headerlink" title="1. 输入输出需要引入java.io包"></a>1. 输入输出需要引入java.io包</h6><h6 id="2-文件和目录使用File类"><a href="#2-文件和目录使用File类" class="headerlink" title="2. 文件和目录使用File类"></a>2. 文件和目录使用File类</h6><h6 id="3-InputStream和OutputStream是字节输入输出流父接口，Reader和Writer是字符输入输出流父接口"><a href="#3-InputStream和OutputStream是字节输入输出流父接口，Reader和Writer是字符输入输出流父接口" class="headerlink" title="3. InputStream和OutputStream是字节输入输出流父接口，Reader和Writer是字符输入输出流父接口"></a>3. InputStream和OutputStream是字节输入输出流父接口，Reader和Writer是字符输入输出流父接口</h6><h6 id="4-完成文件内容拷贝练习题"><a href="#4-完成文件内容拷贝练习题" class="headerlink" title="4. 完成文件内容拷贝练习题"></a>4. 完成文件内容拷贝练习题</h6><h3 id="第九章-JDBC"><a href="#第九章-JDBC" class="headerlink" title="第九章 JDBC"></a>第九章 JDBC</h3><h6 id="1-需要引入的包是java-sql"><a href="#1-需要引入的包是java-sql" class="headerlink" title="1. 需要引入的包是java.sql"></a>1. 需要引入的包是java.sql</h6><h3 id="第十章-事件处理"><a href="#第十章-事件处理" class="headerlink" title="第十章 事件处理"></a>第十章 事件处理</h3><h6 id="1-事件处理模型是授权处理模型"><a href="#1-事件处理模型是授权处理模型" class="headerlink" title="1. 事件处理模型是授权处理模型"></a>1. 事件处理模型是授权处理模型</h6><h6 id="2-常用的五种布局管理器是哪些？"><a href="#2-常用的五种布局管理器是哪些？" class="headerlink" title="2. 常用的五种布局管理器是哪些？"></a>2. 常用的五种布局管理器是哪些？</h6><ul>
<li><p>FlowLayout 流式布局</p>
</li>
<li><p>BorderLayout 边框式布局</p>
</li>
<li><p>GridLayout 网格布局</p>
</li>
<li><p>CardLayout 卡片布局</p>
</li>
<li><p>BoxLayout 盒式布局</p>
<h6 id="3-JFrame的默认布局管理器是BorderLayout"><a href="#3-JFrame的默认布局管理器是BorderLayout" class="headerlink" title="3.JFrame的默认布局管理器是BorderLayout"></a>3.JFrame的默认布局管理器是BorderLayout</h6><h6 id="4-JPanel是FlowLayout，FlowLayout的控件大小不随容器大小变化而改变"><a href="#4-JPanel是FlowLayout，FlowLayout的控件大小不随容器大小变化而改变" class="headerlink" title="4. JPanel是FlowLayout，FlowLayout的控件大小不随容器大小变化而改变"></a>4. JPanel是FlowLayout，FlowLayout的控件大小不随容器大小变化而改变</h6><h3 id="第十章-多线程"><a href="#第十章-多线程" class="headerlink" title="第十章 多线程"></a>第十章 多线程</h3><h6 id="1-线程的状态：初始状态、就绪状态、运行状态、阻塞状态、终止状态；新建的线程不能立即运行"><a href="#1-线程的状态：初始状态、就绪状态、运行状态、阻塞状态、终止状态；新建的线程不能立即运行" class="headerlink" title="1 .线程的状态：初始状态、就绪状态、运行状态、阻塞状态、终止状态；新建的线程不能立即运行"></a>1 .线程的状态：初始状态、就绪状态、运行状态、阻塞状态、终止状态；新建的线程不能立即运行</h6><h6 id="2-启动线程需要调用start（）方法，不需要调用run（）方法"><a href="#2-启动线程需要调用start（）方法，不需要调用run（）方法" class="headerlink" title="2. 启动线程需要调用start（）方法，不需要调用run（）方法"></a>2. 启动线程需要调用start（）方法，不需要调用run（）方法</h6><h6 id="3-在定义Thread类时，run（）方法必须要重写"><a href="#3-在定义Thread类时，run（）方法必须要重写" class="headerlink" title="3. 在定义Thread类时，run（）方法必须要重写"></a>3. 在定义Thread类时，run（）方法必须要重写</h6><h6 id="4-线程提供了wait、notify和notifyAll方法实现线程的同步"><a href="#4-线程提供了wait、notify和notifyAll方法实现线程的同步" class="headerlink" title="4. 线程提供了wait、notify和notifyAll方法实现线程的同步"></a>4. 线程提供了wait、notify和notifyAll方法实现线程的同步</h6></li>
<li><p>start()：启动线程</p>
</li>
<li><p>wait()：将当前线程置入休眠状态</p>
</li>
<li><p>notify()：唤醒在此对象监视器上等待的单个线程。</p>
</li>
<li><p>notifyAll()：唤醒在此对象监视器上等待的所有线程。</p>
</li>
<li><p>setPriority()：更改线程的优先级。</p>
</li>
<li><p>join()：使其他线程等待当前线程终止</p>
</li>
<li><p>interrupt()：中断线程</p>
</li>
<li><p>isAlive()：测试线程是否处于活动状态。<br><strong>static：</strong></p>
</li>
<li><p>sleep()：线程休眠</p>
</li>
<li><p>yield()：暂停当前正在执行的线程对象，并执行其他线程。</p>
</li>
<li><p>currentThread()：返回对当前正在执行的线程对象的引用。</p>
</li>
</ul>
<h6 id="5-线程的优先级从1到10，程序员可以在编程时定义"><a href="#5-线程的优先级从1到10，程序员可以在编程时定义" class="headerlink" title="5. 线程的优先级从1到10，程序员可以在编程时定义"></a>5. 线程的优先级从1到10，程序员可以在编程时定义</h6><h6 id="6-创建线程的方法继承Thread类和实现Runnable方法"><a href="#6-创建线程的方法继承Thread类和实现Runnable方法" class="headerlink" title="6. 创建线程的方法继承Thread类和实现Runnable方法"></a>6. 创建线程的方法继承Thread类和实现Runnable方法</h6><h3 id="第十一章-网络编程"><a href="#第十一章-网络编程" class="headerlink" title="第十一章 网络编程"></a>第十一章 网络编程</h3><h6 id="1-TCP编程使用ServerSocket和Socket，采用流式进行通讯，Socket代表客户端，ServerSocket代表服务器端"><a href="#1-TCP编程使用ServerSocket和Socket，采用流式进行通讯，Socket代表客户端，ServerSocket代表服务器端" class="headerlink" title="1. TCP编程使用ServerSocket和Socket，采用流式进行通讯，Socket代表客户端，ServerSocket代表服务器端"></a>1. TCP编程使用ServerSocket和Socket，采用流式进行通讯，Socket代表客户端，ServerSocket代表服务器端</h6><h6 id="2-与网络通讯相关的类都封装在java-net包下"><a href="#2-与网络通讯相关的类都封装在java-net包下" class="headerlink" title="2. 与网络通讯相关的类都封装在java.net包下"></a>2. 与网络通讯相关的类都封装在java.net包下</h6><hr>
<h3 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h3><h4 id="1、评委打分"><a href="#1、评委打分" class="headerlink" title="1、评委打分"></a>1、评委打分</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dafen;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">a1</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//评委打分</span></span><br><span class="line">		Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="keyword">int</span> N=scanner.nextInt();</span><br><span class="line">		<span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			arr[i] = scanner.nextInt();</span><br><span class="line">		&#125;</span><br><span class="line">		Arrays.sort(arr);</span><br><span class="line">		<span class="keyword">int</span> score=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">			score += arr[i];</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"最终得分："</span>+score/(arr.length-<span class="number">2</span>));	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、工厂零件"><a href="#2、工厂零件" class="headerlink" title="2、工厂零件"></a>2、工厂零件</h4><pre><code>//Area.java
package area;

import java.util.Scanner;

import area.JieKou.Jiekou;


public class Area {

    public static void main(String[] arg)
    {
        //工厂零件求面积
        Scanner scanner = new Scanner(System.in);
        double r;
        r=scanner.nextDouble();
        Jiekou jk = new Yuan(r);
        System.out.println(jk.getArea()+&quot; &quot;+jk.getZhouchang());
        h=scanner.nextDouble();
        Jiekou jk = new YuanZhu(r,h);
        System.out.println(jk.getArea()+&quot; &quot;);
    }
}

//JieKou.java
package area;

public class JieKou {

    public interface Jiekou
    {
        double getArea();
        double getZhouchang();
    }
}

//Yuan.java
package area;

import area.JieKou.Jiekou;

public class Yuan implements Jiekou{

    private final double PI = 3.14;
    private double r;

    public Yuan() {}

    public Yuan(double r)
    {
        this.r = r;
    }

    public double getArea()
    {
        return PI*r*r;
    }

    public double getZhouchang()
    {
        return 2*PI*r;
    }
}
//YuanZhu.java
package area;

public class YuanZhu extends Yuan{

    private double h;

    public YuanZhu(double r,double h)
    {
        super(r);
        this.h=h;
    }
    public double getArea() {
        return (super.getArea()*h);
    }

}</code></pre><h4 id="3、文件copy操作"><a href="#3、文件copy操作" class="headerlink" title="3、文件copy操作"></a>3、文件copy操作</h4><pre><code>package file;

import java.io.*;
public class filecopy {

    public static void main(String[] avg) throws Exception
    {
        try {
            //复制
            song();
            //字符读写 切割处理
            rwFileSplitEnglish();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }


    private static void rwFileSplitEnglish() throws Exception {
        String str = &quot;&quot;;
        //FileReader reader = new FileReader(&quot;fileIn\\txt1&quot;);
        BufferedReader reader = new BufferedReader(new FileReader(&quot;fileIn\\txt1&quot;));

        int len;
        while((len = reader.read())!=-1)
            str +=(char)len;
        reader.close();

        System.out.println(str);

        String re  = &quot; &quot;;
        String s[] = str.split(re);

        for (int i = 0; i &lt; s.length; i++) {
            System.out.print(s[i]);
        }
        System.out.println(str.length());
    }

    private static void song() throws Exception {
        InputStream in = new FileInputStream(&quot;fileIn\\你一生的故事.mp3&quot;);

        OutputStream out =  new FileOutputStream(&quot;fileOut\\你一生的故事2.mp3&quot;);
        int len;
        long begintime = System.currentTimeMillis();
        while((len=in.read())!=-1)
        {
            out.write(len);
        }
        long endtime = System.currentTimeMillis();
        System.out.println(endtime-begintime);
        in.close();
        out.close();
    }
}</code></pre><h4 id="4、JDBC"><a href="#4、JDBC" class="headerlink" title="4、JDBC"></a>4、JDBC</h4><p><a href="https://danbo3110.github.io/2019/10/16/JDBC_DAO%E6%A8%A1%E5%BC%8F/">Dao模式</a></p>
</div><div class="post-copyright"><blockquote><p>原文作者: 冯亚杰(DanBoard·Feng)</p><p>原文链接: <a href="http://danbo3110.github.io/2019/10/23/Java程序设计复习总结/">http://danbo3110.github.io/2019/10/23/Java程序设计复习总结/</a></p><p>版权声明: 转载请注明出处(必须保留作者署名及链接)</p></blockquote></div><div class="tags"></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2019/10/23/Java文件的读(写)汇总[ InputStream（Reader）、BufferedInputStream 、BufferedReader、FileInputStream、FileReader ]/" class="pre">Java文件的读(写)汇总[ InputStream（Reader）、BufferedInputStream 、BufferedReader、FileInputStream、FileReader ]</a><a href="/2019/10/23/JavaSE实战——网络编程【客户端上传文件到服务端】/" class="next">JavaSE实战——网络编程【客户端上传文件到服务端】</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java程序设计期中复习总结"><span class="toc-text">Java程序设计期中复习总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#第一章-概述"><span class="toc-text">第一章 概述</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-应用程序的结构：package-import-class"><span class="toc-text">1. 应用程序的结构：package import class</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-源文件的扩展名-java，字节文件的扩展名：-class"><span class="toc-text">2. 源文件的扩展名.java，字节文件的扩展名：.class</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-Java语言的工作原理：先编译后解释"><span class="toc-text">3. Java语言的工作原理：先编译后解释</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-一个源文件中最多可以有一个public类，并且文件名与public类名相同。"><span class="toc-text">4. 一个源文件中最多可以有一个public类，并且文件名与public类名相同。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#5-常用命令javac编译，java运行。"><span class="toc-text">5. 常用命令javac编译，java运行。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#6-一个应用程序最少有一个main方法。"><span class="toc-text">6. 一个应用程序最少有一个main方法。</span></a></li></ol></li></ol></li></ol><li class="toc-item toc-level-3"><a class="toc-link" href="#第二章-Java基础"><span class="toc-text">第二章 Java基础</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-标识符命名规则，能够区分合法标识符"><span class="toc-text">1. 标识符命名规则，能够区分合法标识符</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-所有关键字都是小写"><span class="toc-text">2. 所有关键字都是小写</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-基本数据类型的名称、长度和默认值，注意float类型的定义方法：float-f-3-14F；float-f-3-14f；没有大写或者小写f是错误的。"><span class="toc-text">3. 基本数据类型的名称、长度和默认值，注意float类型的定义方法：float f=3.14F；float f=3.14f；没有大写或者小写f是错误的。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-while和do-while的区别"><span class="toc-text">4. while和do-while的区别</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#5-数组使用length属性获得长度"><span class="toc-text">5. 数组使用length属性获得长度</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#6-int-a-b-c是定义了3个数组，int-a-b-c是定义了一个数组a，两个变量b，c"><span class="toc-text">6. int [] a,b,c是定义了3个数组，int a[],b,c是定义了一个数组a，两个变量b，c</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#7-掌握基本数据类型的名称、长度、默认值和数据类型对应的封装类"><span class="toc-text">7. 掌握基本数据类型的名称、长度、默认值和数据类型对应的封装类</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#8-字符串转基本类型的方法"><span class="toc-text">8. 字符串转基本类型的方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第三章-类和对象"><span class="toc-text">第三章 类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-什么是方法的重载"><span class="toc-text">1. 什么是方法的重载</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-构造方法是用来进行成员变量初始化的"><span class="toc-text">2. 构造方法是用来进行成员变量初始化的</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-构造方法的名字和类名相同"><span class="toc-text">3. 构造方法的名字和类名相同</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-构造方法可以有也可以没有，没有系统会自动添加一个无参的方法，也可以有多个构造方法，构造方法可重载"><span class="toc-text">4. 构造方法可以有也可以没有，没有系统会自动添加一个无参的方法，也可以有多个构造方法，构造方法可重载</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#5-static关键字可以修饰变量和方法，可以使用类名直接调用，也可以使用对象调用"><span class="toc-text">5. static关键字可以修饰变量和方法，可以使用类名直接调用，也可以使用对象调用</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#6-public、private、默认、peorected修饰符可以修饰什么？作用范围分别是什么"><span class="toc-text">6. public、private、默认、peorected修饰符可以修饰什么？作用范围分别是什么</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#7-类、方法和变量等可以使用多个修饰符修饰"><span class="toc-text">7. 类、方法和变量等可以使用多个修饰符修饰</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#8-所有类的直接或者间接父类是Object类"><span class="toc-text">8. 所有类的直接或者间接父类是Object类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第四章-继承"><span class="toc-text">第四章 继承</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-类之间使用extends关键字继承"><span class="toc-text">1. 类之间使用extends关键字继承</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-子类继承父类成员后，在子类中定义与父类相同的成员叫重写（覆盖）"><span class="toc-text">2. 子类继承父类成员后，在子类中定义与父类相同的成员叫重写（覆盖）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-final修饰类、变量和方法，不能被继承和改写"><span class="toc-text">3. final修饰类、变量和方法，不能被继承和改写</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-Java所有的类都是java-lang-Object类的子类"><span class="toc-text">4. Java所有的类都是java.lang.Object类的子类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第五章-抽象类、接口"><span class="toc-text">第五章 抽象类、接口</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-定义接口使用interface，实现接口implements"><span class="toc-text">1. 定义接口使用interface，实现接口implements</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-abstract修饰的类为抽象类，方法为抽象方法，抽象方法没有方法体"><span class="toc-text">2. abstract修饰的类为抽象类，方法为抽象方法，抽象方法没有方法体</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-抽象类可以没有抽象方法，有抽象方法的类必定是抽象类"><span class="toc-text">3. 抽象类可以没有抽象方法，有抽象方法的类必定是抽象类</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-使用interface关键字定义接口，类使用implements实现（继承）接口"><span class="toc-text">4. 使用interface关键字定义接口，类使用implements实现（继承）接口</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#5-接口中只有常量和抽象方法，并且都是public-abstract的抽象方法，都是public-static-final的常量"><span class="toc-text">5. 接口中只有常量和抽象方法，并且都是public abstract的抽象方法，都是public static final的常量</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#6-接口可以实现多重继承，定义类的模板"><span class="toc-text">6. 接口可以实现多重继承，定义类的模板</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#7-多态有两种体现重载和重写（覆盖），重载称为编译时多态，重写为运行时多态"><span class="toc-text">7. 多态有两种体现重载和重写（覆盖），重载称为编译时多态，重写为运行时多态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第六章-字符串"><span class="toc-text">第六章 字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-字符串分为静态字符串（String）和动态字符串（StringBuffer）"><span class="toc-text">1. 字符串分为静态字符串（String）和动态字符串（StringBuffer）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-使用length（）方法获得字符串的长度"><span class="toc-text">2. 使用length（）方法获得字符串的长度</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-其他常用方法chatAt（）、equals（）"><span class="toc-text">3. 其他常用方法chatAt（）、equals（）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第七章-异常处理"><span class="toc-text">第七章 异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-什么是异常"><span class="toc-text">1. 什么是异常</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-为什么要进行异常处理"><span class="toc-text">2. 为什么要进行异常处理</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-所有异常的父类是Throwable类，它有两个直接子类为Error和Exception"><span class="toc-text">3. 所有异常的父类是Throwable类，它有两个直接子类为Error和Exception</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-异常分为运行时异常和非运行时异常"><span class="toc-text">4. 异常分为运行时异常和非运行时异常</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#5-异常的处理过程是先抛弃后捕获"><span class="toc-text">5. 异常的处理过程是先抛弃后捕获</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#6-处理方法有三种："><span class="toc-text">6. 处理方法有三种：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#7-进行异常捕获时，先发生的放在前面，后发生的放后面；子类异常放前面，父类放后面"><span class="toc-text">7. 进行异常捕获时，先发生的放在前面，后发生的放后面；子类异常放前面，父类放后面</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#8-使用throw制造异常"><span class="toc-text">8. 使用throw制造异常</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第八章-输入输出"><span class="toc-text">第八章 输入输出</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-输入输出需要引入java-io包"><span class="toc-text">1. 输入输出需要引入java.io包</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-文件和目录使用File类"><span class="toc-text">2. 文件和目录使用File类</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-InputStream和OutputStream是字节输入输出流父接口，Reader和Writer是字符输入输出流父接口"><span class="toc-text">3. InputStream和OutputStream是字节输入输出流父接口，Reader和Writer是字符输入输出流父接口</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-完成文件内容拷贝练习题"><span class="toc-text">4. 完成文件内容拷贝练习题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第九章-JDBC"><span class="toc-text">第九章 JDBC</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-需要引入的包是java-sql"><span class="toc-text">1. 需要引入的包是java.sql</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第十章-事件处理"><span class="toc-text">第十章 事件处理</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-事件处理模型是授权处理模型"><span class="toc-text">1. 事件处理模型是授权处理模型</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-常用的五种布局管理器是哪些？"><span class="toc-text">2. 常用的五种布局管理器是哪些？</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-JFrame的默认布局管理器是BorderLayout"><span class="toc-text">3.JFrame的默认布局管理器是BorderLayout</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-JPanel是FlowLayout，FlowLayout的控件大小不随容器大小变化而改变"><span class="toc-text">4. JPanel是FlowLayout，FlowLayout的控件大小不随容器大小变化而改变</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第十章-多线程"><span class="toc-text">第十章 多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-线程的状态：初始状态、就绪状态、运行状态、阻塞状态、终止状态；新建的线程不能立即运行"><span class="toc-text">1 .线程的状态：初始状态、就绪状态、运行状态、阻塞状态、终止状态；新建的线程不能立即运行</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-启动线程需要调用start（）方法，不需要调用run（）方法"><span class="toc-text">2. 启动线程需要调用start（）方法，不需要调用run（）方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-在定义Thread类时，run（）方法必须要重写"><span class="toc-text">3. 在定义Thread类时，run（）方法必须要重写</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-线程提供了wait、notify和notifyAll方法实现线程的同步"><span class="toc-text">4. 线程提供了wait、notify和notifyAll方法实现线程的同步</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#5-线程的优先级从1到10，程序员可以在编程时定义"><span class="toc-text">5. 线程的优先级从1到10，程序员可以在编程时定义</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#6-创建线程的方法继承Thread类和实现Runnable方法"><span class="toc-text">6. 创建线程的方法继承Thread类和实现Runnable方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第十一章-网络编程"><span class="toc-text">第十一章 网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-TCP编程使用ServerSocket和Socket，采用流式进行通讯，Socket代表客户端，ServerSocket代表服务器端"><span class="toc-text">1. TCP编程使用ServerSocket和Socket，采用流式进行通讯，Socket代表客户端，ServerSocket代表服务器端</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-与网络通讯相关的类都封装在java-net包下"><span class="toc-text">2. 与网络通讯相关的类都封装在java.net包下</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#编程题"><span class="toc-text">编程题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、评委打分"><span class="toc-text">1、评委打分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、工厂零件"><span class="toc-text">2、工厂零件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3、文件copy操作"><span class="toc-text">3、文件copy操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4、JDBC"><span class="toc-text">4、JDBC</span></a></li></ol></li></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/02/18/WebGIS应用分析 [Ⅰ]/">WebGIS应用分析 [Ⅰ]</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/11/计算机地图制图 知识总结/">计算机地图制图 知识总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/11/GIS程序设计 知识总结/">GIS程序设计 知识总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/11/空间数据库总结/">空间数据库总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/11/GPS测量原理及应用 知识总结/">GPS测量原理及应用 知识总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/11/github码云操作---合并分支，推送/">github/码云操作---合并分支，推送</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/01/11/IDEA连接Mysql数据库没有jar包，报错/">IDEA连接Mysql数据库没有jar包报错</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/07/Vue工程化环境(模块化规范、webpack、单文件组件、脚手架、Element-UI)/">Vue工程化</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/03/解决nodejs报错 Cannot find module/">完美解决nodejs报错 Cannot find module './application'</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/11/25/AE - 04.专题图绘制及打印功能实现/">AE - 04.专题图绘制及打印功能实现</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">十二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="https://blog.csdn.net/DanBo_C" title="CSDN" target="_blank">CSDN</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">冯亚杰(DanBoard·Feng).</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.4"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.4" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>