<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DanBoCode</title>
  
  <subtitle>句子跟标点落入四个区间，有人能懂真理，有人读出文艺。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-02-18T11:08:54.632Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>冯亚杰(DanBoard·Feng)</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2020/02/18/WebGIS%E5%BA%94%E7%94%A8%E5%88%86%E6%9E%90%20%5B%E2%85%A0%5D/"/>
    <id>http://yoursite.com/2020/02/18/WebGIS应用分析 [Ⅰ]/</id>
    <published>2020-02-18T11:09:22.126Z</published>
    <updated>2020-02-18T11:08:54.632Z</updated>
    
    <content type="html"><![CDATA[<h2 id="WebGIS应用分析-Ⅰ"><a href="#WebGIS应用分析-Ⅰ" class="headerlink" title="WebGIS应用分析 [Ⅰ]"></a>WebGIS应用分析 [Ⅰ]</h2><h3 id="智能交通管理指挥调度系统"><a href="#智能交通管理指挥调度系统" class="headerlink" title="智能交通管理指挥调度系统"></a>智能交通管理指挥调度系统</h3><ul><li>主题：智能交通管理系统</li><li>C/S模式的管理系统：<ul><li>功能单一</li><li>冗余大</li><li>缺少集成</li><li>效率低</li><li>局限性强（局域网）</li></ul></li></ul><blockquote><p>B/S系统（WebGIS）旨在解决C/S中存在的已知问题。</p></blockquote><ul><li>B/S模式的管理系统：<ul><li>访问范围广泛</li><li>平台独立</li><li>平衡高效的计算负载</li><li>良好的可扩展性</li></ul></li></ul><h4 id="系统功能"><a href="#系统功能" class="headerlink" title="系统功能"></a>系统功能</h4><ol><li><p>地图管理及交通状况监视功能。</p><ul><li><p>对地图图层的管理</p></li><li><p>基本的地图操作</p></li><li><p>道路交通流状况显示与分析</p></li><li><p>检测并报警</p></li></ul></li><li><p>视频监视功能</p><ul><li>查看交通实时监控</li><li>自动弹出与报警地点相关的视频图像</li><li>指挥调度时，实时点击视频标记查看实时视频图像</li></ul></li><li><p>信息诱导功能</p><ul><li>诱导屏分组管理</li><li>发布诱导信息</li><li>评价诱导信息</li><li>诱导信息屏群组优化及信息发布</li></ul></li><li><p>动/静态交通组织及预案管理</p><ul><li>对活动或灾害等的预案生成、修改、实施及辅助决策</li><li>预案管理及评价</li></ul></li><li><p>指挥调整</p><ul><li>通过GPS系统实时调度警力配置</li><li>实时调整监控</li><li>发布实时诱导信息及调整信号控制</li></ul></li><li><p>其他</p><ul><li>系统管理</li><li>日志管理</li></ul></li></ol><h4 id="WebGIS功能设计"><a href="#WebGIS功能设计" class="headerlink" title="WebGIS功能设计"></a>WebGIS功能设计</h4><ol><li>显示层（用户层）<ul><li>向Web服务器发送查询等请求</li><li>接收服务器返回的HTML</li></ul></li><li>Web服务层<ul><li>Web服务器（IIS、Apache、tomcat）内置系统有关交通管理的专业组件（路况评价，交通流仿真等）</li><li>接收显示层的请求，并封装请求为命令发送给WebGIS服务器</li><li>接受返回的信息在组件中进行处理，将结果返回给显示层</li></ul></li><li>WebGIS服务层<ul><li>接收上层命令，与数据库交互。</li><li>返回为用户地理信息GIS服务，实现用户与服务器的动态交互</li><li>负载平衡、服务管理</li></ul></li><li>数据资源层<ul><li>通过网络连接并集成异构分布的计算资源、数据服务器、文件系统等</li></ul></li></ol><blockquote><p>XML进行数据交换（目前使用Geojson合适）</p><p>Oracle9i实现数据存储与管理</p><p>ArcGIS作为GIS开发工具</p><p>ArcSDE实现对空间数据的管理</p><p>ArcIMS实现WebGIS功能</p><p>开发环境为.NET</p><p>开发语言为C#</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;WebGIS应用分析-Ⅰ&quot;&gt;&lt;a href=&quot;#WebGIS应用分析-Ⅰ&quot; class=&quot;headerlink&quot; title=&quot;WebGIS应用分析 [Ⅰ]&quot;&gt;&lt;/a&gt;WebGIS应用分析 [Ⅰ]&lt;/h2&gt;&lt;h3 id=&quot;智能交通管理指挥调度系统&quot;&gt;&lt;a href
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>计算机地图制图 知识总结</title>
    <link href="http://yoursite.com/2020/01/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9C%B0%E5%9B%BE%E5%88%B6%E5%9B%BE%20%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/01/11/计算机地图制图 知识总结/</id>
    <published>2020-01-11T06:57:12.345Z</published>
    <updated>2020-01-11T07:00:55.210Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h4 id="1-计算机制图的概念-P1-数字地图，电子地图的概念（PPT），区分，名词解释"><a href="#1-计算机制图的概念-P1-数字地图，电子地图的概念（PPT），区分，名词解释" class="headerlink" title="1. 计算机制图的概念 P1 数字地图，电子地图的概念（PPT），区分，名词解释"></a>1. 计算机制图的概念 P1 数字地图，电子地图的概念（PPT），区分，名词解释</h4><ul><li>计算机地图制图（数字地图制图）：以传统的地图制图原理为基础，以计算机为工具，采用数据库技术和图形数据处理方法，实现地图信息的采集、存储、处理、显示和绘图的应用科学。<strong>实质:</strong> 从图形（连续）转换为数字（离散），经过一定处理，再由数字转换为图形的过程。</li><li>数字地图：一定坐标系内，空间数据 + 属性标志的离散数据，以数字形式存储的数据 。</li><li>电子地图：利用计算机技术，以数字方式存储和查阅的地图，数字地图在屏幕上显示的地图。</li><li>模拟地图（传统地图）：电子地图在一定比例尺下出图，打印成纸质地图。</li></ul><img src="https://img-blog.csdnimg.cn/20191218193213975.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70" style="zoom: 50%;"><h4 id="2-计算机制图的优点-P2"><a href="#2-计算机制图的优点-P2" class="headerlink" title="2. 计算机制图的优点 P2"></a>2. 计算机制图的优点 P2</h4><ol><li><p>易于编辑更新，交互性强：固定成型，按需修改</p></li><li><p>提高绘图速度和精度：计算机制图，无主观偏差</p></li><li><p>易于存储，容量大，降低了成本：计算机存储，不变形，减少工作强度，降低印刷费用</p></li><li><p>丰富了地图品种：坡度图，晕渲图</p></li><li><p>便于信息共享：复制传播</p></li><li><p>动态调整载负量：太小信息量不足，无极缩放</p></li></ol><h4 id="3-计算机制图的构成-P6"><a href="#3-计算机制图的构成-P6" class="headerlink" title="3. 计算机制图的构成 P6"></a>3. 计算机制图的构成 P6</h4><ol><li><p>硬件 - 各种设备-物质基础</p><ul><li>输入设备：键盘、鼠标、数字化仪（跟踪式、扫描式）扫描仪</li><li>输出设备：图形显示终端、打印机、绘图仪</li></ul><table><thead><tr><th>设 备</th><th>图形输出方式</th><th>精度</th><th>特      点</th></tr></thead><tbody><tr><td>矢量绘图机</td><td>矢量线划</td><td>高</td><td>绘制线划图；进行刻图等</td></tr><tr><td>喷墨打印机</td><td>网格点阵</td><td>高</td><td>彩色地图和影像地图</td></tr><tr><td>高分辨率彩显</td><td>屏幕像元点阵</td><td>一般</td><td>实时显示GIS的各种图形、图像产品</td></tr><tr><td>行式打印机</td><td>字符点阵</td><td>差</td><td>以打印字符输出各类地图。</td></tr><tr><td>胶片拷贝机</td><td>光栅</td><td>较高</td><td>将屏幕图形复制至胶片，用于制作幻灯片和正胶片。</td></tr></tbody></table></li><li><p>软件 - 支持数据采集、存储、加工、回答用户问题的计算机程序系统</p><ul><li>计算机系统软件</li><li>计算机制图数据库软件</li><li>计算机地图制图应用软件</li></ul></li><li><p>制图数据 - 系统分析与处理的对象、构成系统的应用基础</p><ul><li>地理要素空间数据</li><li>地理要素属性数据</li><li>地理要素空间关系</li><li>地图符号库</li><li>地图注记</li><li>元数据</li></ul></li><li><p>制图人员 - GIS服务的对象，分为一般用户和从事建立、维护、管理和更新的高级用户</p></li></ol><h4 id="4-计算机制图的基本过程-P13"><a href="#4-计算机制图的基本过程-P13" class="headerlink" title="4. 计算机制图的基本过程 P13"></a>4. 计算机制图的基本过程 P13</h4><ol><li>数据获取<ul><li>二 –》1</li></ul></li><li>数据处理<ul><li>预处理</li><li>投影变换</li><li>图形处理</li><li>制图综合　</li><li>符号化</li></ul></li><li>数据输出<ul><li>普通地图</li><li>专题地图</li><li>统计图表</li></ul></li></ol><h4 id="5-计算机制图与地理信息系统（CAD）之间的区别联系-P18"><a href="#5-计算机制图与地理信息系统（CAD）之间的区别联系-P18" class="headerlink" title="5. 计算机制图与地理信息系统（CAD）之间的区别联系 P18"></a>5. 计算机制图与地理信息系统（CAD）之间的区别联系 P18</h4><ol><li><p>与GIS</p><p>都是基于空间数据库的空间信息的表达、显示和处理。</p><ul><li>计算机地图制图是地理信息系统的一部分；</li><li>GIS是计算机地图制图之上的超结构。</li></ul><table><thead><tr><th>名称</th><th>制图</th><th>GIS</th></tr></thead><tbody><tr><td>模型</td><td>位置＋符号</td><td>位置＋符号＋属性</td></tr><tr><td>数据管理</td><td>地图数据库</td><td>空间数据库、关系数据库</td></tr><tr><td>应用</td><td>输出地图</td><td>输出地图，提供空间对象供用户使用，查询检索和分析决策</td></tr></tbody></table></li><li><p>CAD</p><ul><li>CAD和GIS都有坐标参考系统，CAD的是相对坐标，没有空间意义，不能空间分析。地图制图是对空间数据的处理，是有坐标的。</li><li>计算机辅助制图多为规则的几何图形或组合，图形及其关系更复杂，空间数据和属性数据的相互操作频繁，空间数据的处理和符号化功能较强，属性功能相对较弱；</li><li>CAD是平面设计软件，建筑行业频繁使用的软件。</li></ul></li></ol><h2 id="第二章-数据采集"><a href="#第二章-数据采集" class="headerlink" title="第二章 数据采集"></a>第二章 数据采集</h2><h4 id="1-数字地图的数据源有哪些？怎么获取？"><a href="#1-数字地图的数据源有哪些？怎么获取？" class="headerlink" title="1. 数字地图的数据源有哪些？怎么获取？"></a>1. 数字地图的数据源有哪些？怎么获取？</h4><p>地图数据 ，遥感数据， 文本数据，统计数据  实测数据，多媒体数据，已有地图数据库…</p><ol><li>几何数据采集：<ol><li>已有数字数据：转换后输入数据库</li><li>外野测量获取的几何数据：预处理（平板测量、全野外数字测图、空间定位测量）后导入地图数据库</li><li>遥感影像数据：预处理（几何纠正、图像变换、影响分类、特征提取）</li><li>纸质地图：地图数字化（手扶跟踪数字化、扫描矢量化）</li><li>摄影测量方法：摄影测量包括航空摄影测量和地面摄影测量</li></ol></li><li>属性数据采集：<ol><li>键盘，人机对话</li><li>程序批量输入</li></ol></li></ol><h4 id="2-GIS里面矢量、栅格数据"><a href="#2-GIS里面矢量、栅格数据" class="headerlink" title="2. GIS里面矢量、栅格数据"></a>2. GIS里面矢量、栅格数据</h4><p>矢量数据结构和栅格数据结构是两种地图空间数据结构。</p><p>矢量数据结构：通过记录坐标的方式尽可能精确地理实体，坐标空间设为连续，允许任意位置、长度和面积的精确定义。<strong>特点：定位明显，属性隐含</strong></p><p>栅格数据结构：将地表划分成为紧密相邻的网格阵列。每个网格的位置由行列号定义，并包含一个代码，以表示该网格的属性。<strong>特点：属性明显，定位隐含</strong></p><p><img src="https://img-blog.csdnimg.cn/20200103212951526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70" style="zoom: 50%;"><img src="https://img-blog.csdnimg.cn/20200103213038212.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70" style="zoom: 67%;"></p><h6 id="如何选择？"><a href="#如何选择？" class="headerlink" title="如何选择？"></a>如何选择？</h6><ul><li>栅格结构：利于叠加分析。大范围小比例尺的自然资源、环境、农林业等区域问题的研究。</li><li>矢量结构：表达事物比较精细。城市分区或详细规划、土地管理、公用事业管理等方面的应用。</li></ul><h4 id="3-数据质量"><a href="#3-数据质量" class="headerlink" title="3. 数据质量"></a>3. 数据质量</h4><p>数据的质量包括五个方面：</p><ol><li>位置（几何）精度：如数学基础、平面精度、高程精度等，用以描述几何数据的误差。</li><li>属性精度：如要素分类的正确性、属性编码的正确性、注记的正确性等，用以反映属性数据的质量。</li><li>完备性：如数据分类的完备性、实体类型的完备性、属性数据的完备性、注记的完整性，数据层完整性，检验完整性等。</li><li>现势性：如数据的采集时间、数据的更新时间等。 </li><li>逻辑一致性：如多边形的闭合精度、结点匹配精度、拓扑关系的正确性等，由几何或属性误差也会引起逻辑误差。</li></ol><p>质量的控制：</p><ol><li>误差带法：该方法适用于任何类型的GIS数据，关键是如何给出合理的ε值。</li><li>对比法：把数字化后的数据，用绘图机绘出，与原图叠合，选择明显地物点进行量测，以确定误差。</li><li>相关法：依据地图要素自身的相关性来分析数据的质量。如河流与等高线的套合程度。</li></ol><h2 id="第五章-P103"><a href="#第五章-P103" class="headerlink" title="第五章 P103"></a>第五章 P103</h2><h4 id="1-数据预处理"><a href="#1-数据预处理" class="headerlink" title="1. 数据预处理"></a>1. 数据预处理</h4><p>坐标变换，数据压缩，数据匹配</p><ul><li>坐标变换<ul><li>几何纠正</li><li>投影变换</li></ul></li><li>数据压缩 主要对象：现状要素中心轴线和面状要素边界数据<ul><li>间隔取点法</li><li>垂距法</li><li>偏角法</li><li>道格拉斯普克法</li><li>光栏法</li></ul></li><li>数据匹配：实现误差纠正。<ul><li>顶点匹配</li><li>数字接边</li></ul></li></ul><h4 id="2-几何纠正"><a href="#2-几何纠正" class="headerlink" title="2. 几何纠正"></a>2. 几何纠正</h4><p>P105 性质，什么情况使用哪个，有多少个未知数，道理是啥。</p><ul><li><p>高次变换（多项式拟合法、非线性形变）：12个未知数，需要6对以上控制点坐标</p></li><li><p>二次变换（多项式拟合法、非线性形变）：10个未知数，需要5对以上控制点坐标。适用于原图有非线性变形</p></li><li><p>一次变换：6个未知数，需要不在一条直线上的3对以上控制点坐标。由于误差，需要多观测一组。一共需要四对控制点坐标</p><ul><li><p>同素变换：复杂的变换方式</p><p>特点：</p><ul><li>直线变换后仍为直线</li><li>平行线变换后为直线束</li><li>同一线束中任一割线的交叉比保持不变</li><li>同一割线上相应个点的线束的交叉比保持不变</li></ul></li><li><p>仿射变换：只考虑x方向和y方向上的变形。（经过对坐标的缩放，旋转，平移后原坐标在新坐标域中的值）</p><p>特点：</p><ul><li>直线变换后仍为直线</li><li>平行线变换后仍为平行线，长度比不变</li><li>不同方向上的长度比发生变化    </li></ul></li></ul></li></ul><h4 id="3-投影变换（转换的思想）"><a href="#3-投影变换（转换的思想）" class="headerlink" title="3. 投影变换（转换的思想）"></a>3. 投影变换（转换的思想）</h4><ul><li>解析变换：找出两投影间坐标变换的解析计算公式<ul><li>正解变换：将具有经纬度的地理坐标转换为直角坐标系下的坐标</li><li>反解变换：将具有直角坐标系下的坐标转换为经纬度</li></ul></li><li>数值变换：在不易求出两投影坐标之间的直接关系，采用多项式逼近建立公式。20个未知数，10个控制点坐标</li><li>数值解析变换：已知新的投影公式，但不知道原投影公式，可选择通过数值变化求出原投影点的地理坐标，然后代入新投影公式中，求出新投影点的坐标。</li></ul><h4 id="4-数据压缩"><a href="#4-数据压缩" class="headerlink" title="4. 数据压缩"></a>4. 数据压缩</h4><p>压缩条件：</p><ol><li>保持曲线的形状特征</li><li>保持密度对比</li><li>保持转折点的精度</li><li>保持空间关系正确</li></ol><h5 id="道格拉斯普克法：（画图，思路）"><a href="#道格拉斯普克法：（画图，思路）" class="headerlink" title="道格拉斯普克法：（画图，思路）"></a>道格拉斯普克法：（画图，思路）</h5><p>对给定曲线的首末点虚连一条直线，求中间所有点与直线间的距离，并找出最大距离dmax，用dmax与限差 L比较。dmax ≥L，保留对应点，以该点为界将曲线分为两段，对每一段重复使用该方法。dmax&lt;L，舍去所有中间点。</p><img src="https://img-blog.csdnimg.cn/20191231201130626.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70" style="zoom:50%;"><h5 id="光栏法：（画图，思路，简单说）"><a href="#光栏法：（画图，思路，简单说）" class="headerlink" title="光栏法：（画图，思路，简单说）"></a>光栏法：（画图，思路，简单说）</h5><p>定义一个扇形区域，通过判断曲线上的点在扇形外还是在扇形内，确定保留还是舍去。</p><p><img src="https://img-blog.csdnimg.cn/20191231202136388.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70" style="zoom:50%;"><img src="https://img-blog.csdnimg.cn/20191231202151609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70" style="zoom:50%;"></p><p><img src="https://img-blog.csdnimg.cn/20191231202222116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70" style="zoom:47%;"><img src="https://img-blog.csdnimg.cn/20191231202236243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70" style="zoom:45%;"></p><h4 id="5-图形编辑"><a href="#5-图形编辑" class="headerlink" title="5. 图形编辑"></a>5. 图形编辑</h4><p>P110 </p><ul><li><p>地图开窗：按照用户指定的空间范围，进行图形子集的选取。这个指定的范围被称为窗口</p></li><li><p>正开窗：选取整个图形数据在窗口内的子集合</p></li><li><p>负开窗：选取整个图形数据在窗口外的子集合</p></li></ul><ul><li>点的选取：计算C和P之间的距离是否小于限差</li><li>线的选取：通过计算光标点C到该线的每条线段的距离d，与搜索半径D比较。如果d&lt;D，则认为找到；反之则未成功。</li><li>面的选取：铅垂线法：从待判别点引铅垂线，由该铅垂线（注意：是一条射线）与多边形交点个数的奇偶性来判断点是否在多边形内。</li></ul><h6 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h6><ol><li>第一步，计算多边形最小投影矩形，若点在最小投影矩形外，则点一定在多边形外，算法结束；否则执行第二步。</li><li>第二步，设置记录交点个数的计数器Num=0。</li><li>第三步，从待判断的点作铅垂线，顺次判断该铅垂线与多边形各边是否相交，若相交，求出交点并记录下来。每有一次相交，把Num数值增加1。</li><li>第四步，若Num为偶数，则该点在多边形外；否则，该点在多边形内。算法结束。</li></ol><p>异常情况：</p><ol><li>交点位于多边形顶点：若在同侧，Num不变，否则Num加1。 </li><li>铅垂线与多边形的一条边重合：若在同侧，Num不变，否则Num加1。 </li></ol><img src="https://img-blog.csdnimg.cn/20191231213953664.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70" style="zoom:50%;"><img src="https://img-blog.csdnimg.cn/20191231214019233.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70" style="zoom:50%;"><h4 id="6-几何变换-P114"><a href="#6-几何变换-P114" class="headerlink" title="6. 几何变换  P114"></a>6. 几何变换  P114</h4><ol><li><p>二维变换矩阵</p><p><img src="https://img-blog.csdnimg.cn/20200106222033127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70" style="zoom:50%;"><img src="https://img-blog.csdnimg.cn/20200106222153891.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70" style="zoom:50%;"></p></li><li><p>平移变化：只改变图形的位置，不改变图形的大小和形状</p><img src="https://img-blog.csdnimg.cn/20200101200854117.png" style="zoom:50%;"></li><li><p>比例变换：</p><img src="https://img-blog.csdnimg.cn/20200101200943545.png" style="zoom:50%;"><ul><li>以坐标原点为放缩参照点。</li><li>当Sx=Sy=1时：恒等比例变换。</li><li>当Sx=Sy&gt;1时：沿x,y方向等比例放大。</li><li>当Sx=Sy&lt;1时：沿x,y方向等比例缩小。</li><li>当SxSy时：沿x,y方向作非均匀的比例变换，图形变形。</li><li>当Sx=1，Sy=－1，关于X轴的对称变换。</li><li>当Sx=－1，Sy=1时，为关于Y轴的对称变换。</li><li>当Sx=Sy=－1，为关于坐标原点的对称变换。</li></ul></li><li><p>对称变换：</p><img src="https://img-blog.csdnimg.cn/20200101201216683.png" style="zoom:50%;"><ul><li>当d=b=0,a=-1,e=1时，(x* y* 1)=(-x y 1)：与y轴对称的反射变换。</li><li>当d=b=0,a=1,e=-1时，(x* y* 1)=( x -y 1)：与x轴对称的反射变换。</li><li>当d=b=0,a=e=-1时，(x* y* 1)=(-x -y 1)：与原点对称的反射变换。</li><li>当d=b=1,a=e=0时，(x* y* 1)=(y x 1)：与y=x对称的反射变换。</li><li>当d=b=-1,a=e=0时，(x* y* 1)=(-y -x 1)：与y=-x对称的反射变换</li></ul></li><li><p>旋转变换：</p><p><img src="https://img-blog.csdnimg.cn/2020010120125550.png" alt></p><img src="https://img-blog.csdnimg.cn/20200101201312626.png" style="zoom:50%;"></li><li><p>错切变换：错切变换引起图形角度关系的改变，甚至导致图形发生变形</p><img src="https://img-blog.csdnimg.cn/20200101201432607.png" style="zoom:50%;"><ul><li>当b=0时， (x* y* 1)=(x+by y 1)：图形的y坐标不变；</li><li>当d&gt;0：图形沿+x方向作错切位移。ABCD→A1B1C1D1</li><li>当d&lt;0：图形沿-x方向作错切位移。ABCD→ A2B2C2D2</li></ul><img src="https://img-blog.csdnimg.cn/20200101201532799.png" style="zoom:50%;"></li><li><p>复合变换：指在XY平面内，对一个已定义的图形，按一定顺序进行多次变换而得到新的图形，也即对图形做一次以上的几何变换。<br>注意：任何一个线性变换都可以分解为上述几类变换。</p><p>​    <img src="https://img-blog.csdnimg.cn/20200101204211481.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70" style="zoom: 50%;"></p></li></ol><h4 id="7-矢量数据向栅格数据转换-P123（简答）"><a href="#7-矢量数据向栅格数据转换-P123（简答）" class="headerlink" title="7. 矢量数据向栅格数据转换 P123（简答）"></a>7. 矢量数据向栅格数据转换 P123（简答）</h4><h5 id="矢量转栅格："><a href="#矢量转栅格：" class="headerlink" title="矢量转栅格："></a>矢量转栅格：</h5><p>栅格数据分辨率和栅格数的确定</p><ol start="2"><li>点的栅格化：实质上是将点的矢量坐标转换成栅格数据中行列值i和j，从而得到点所在栅格元素的位置。</li><li>线的栅格化：当折线上取点足够多时，所画的折线在视觉上成为曲线。实质上是完成相邻两点之间直线的转换。若已知一直线AB其两端点坐标分别为A(x1，y1)和B(x2，y2)，则其转换过程不仅包括坐标点A，B分别从点矢量数据转换成栅格数据，还包括求出直线AB所经过的中间栅格数据。八方向栅格化、分带法、恒密度栅格化</li><li>面的栅格化：使矢量表示的多边形内部所有栅格用多边形的属性填充，形成栅格数据集合。内部点扩散法、射线算法、扫描算法边界代数算法</li></ol><h2 id="第六章-栅格数据的处理"><a href="#第六章-栅格数据的处理" class="headerlink" title="第六章 栅格数据的处理"></a>第六章 栅格数据的处理</h2><h4 id="1-栅格图像平移-P128"><a href="#1-栅格图像平移-P128" class="headerlink" title="1.  栅格图像平移 P128"></a>1.  栅格图像平移 P128</h4><p>平移、算术运算、逻辑运算、宏运算  看懂</p><ul><li>灰度级变换：对每一像素的灰度级进行变换，扩大图像灰度的范围，达到图像增强的目的。</li><li>平移：原始的栅格影像按照一定的方向平移确定的像元数目。</li><li>算术组合：两个栅格图像相互叠置，对应的像元灰度值相加、相减、相乘等</li><li>逻辑组合：对应的像元灰度进行逻辑运算，或，与，非，异或</li></ul><p>宏运算</p><ul><li><p>扩张：向指定的方向和给定的像元数据进行扩张，平移同时做或运算</p><p>例：向右平移一个像元</p><p><img src="https://img-blog.csdnimg.cn/20200101212900685.png" style="zoom:50%;"><img src="https://img-blog.csdnimg.cn/2020010121295142.png" style="zoom:50%;"><img src="https://img-blog.csdnimg.cn/20200101213217330.png" style="zoom:50%;"></p></li><li><p>侵蚀：向侵蚀方向移动确定的像元格</p><p><img src="https://img-blog.csdnimg.cn/20200101213700473.png" style="zoom:50%;"><img src="https://img-blog.csdnimg.cn/20200101213711480.png" style="zoom:50%;"></p></li><li><p>加粗：分为四方向和八方向</p><p><img src="https://img-blog.csdnimg.cn/20200101214852656.png" style="zoom:50%;"><img src="https://img-blog.csdnimg.cn/20200101214946115.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70" style="zoom:50%;"></p></li></ul><ul><li><p>减细：加粗的逆运算</p></li><li><p>填充</p><ul><li><p>逐步蔓延加粗法：让单个像元作为填充胚，在给定的区域范围内，通过某种方法进行蔓延，最终填充满整个多边形区域。四邻法、八邻法</p><img src="https://img-blog.csdnimg.cn/20200101215216926.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70" style="zoom:67%;"></li><li><p>逐行填充法：对种子所在的行进行填充，在每次填充一行后，应搜索该行的上下两侧以确定新的种子，对于相互连通的一侧，只需一个种子，并将其放入栈中。</p><img src="https://img-blog.csdnimg.cn/20200101215839985.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70" style="zoom: 67%;"></li></ul></li></ul><h4 id="2-栅格数据向矢量数据转换的算法-P139"><a href="#2-栅格数据向矢量数据转换的算法-P139" class="headerlink" title="2. 栅格数据向矢量数据转换的算法 P139"></a>2. 栅格数据向矢量数据转换的算法 P139</h4><h5 id="栅格转矢量："><a href="#栅格转矢量：" class="headerlink" title="栅格转矢量："></a>栅格转矢量：</h5><p>注意：1.拓扑转换 2.转换正确的外形</p><ol><li><p>点的矢量化：</p></li><li><p>线的矢量化：实质：将具有相同属性值的连续的单元格搜索出来，最后得到细化的一条线。具体实施：先将具有一定粗细的栅格数据先进行细化，使其最后成为单像素的线段，然后进行矢量化。两种算法思想：细化矢量化和非细化矢量化</p></li><li><p>多边形的矢量化：实质：将具有同一属性的单元归为一类，再检测两类不同属性的边界作为多边形的边，提取以栅格集合表示的区域边界和边界的拓扑关系。</p></li></ol><p>   一般过程：栅格数据的二值化、多边形边界提取和细化、多边界跟踪、去除多余及曲线光滑、矢量数据转换的过程</p><ol><li><p>二值化。栅格数据是按0～255的不同灰度值表达的。为了简化追踪算法，将256个灰阶压缩为2个灰阶，即0和1两级。</p></li><li><p>边界提取和细化。使每一条线只保留代表其轴线或周围轮廓线（对多边形而言）位置的单个栅格的宽度。</p></li><li><p>边界跟踪。把细化后的栅格数据整理为从结点出发的线段或闭合的线条，并以矢量形式加以存储。</p></li><li><p>曲线化简及光滑 。直接提取的边界线节点密集、有明显的抖动锯齿感，需进行化简及光滑处理。</p></li><li><p>生成拓扑关系，建立节点、弧段及多边形间的连接关系。</p></li></ol><h2 id="第七章-地图符号"><a href="#第七章-地图符号" class="headerlink" title="第七章 地图符号"></a>第七章 地图符号</h2><h4 id="1-地图符号和地图符号化的概念"><a href="#1-地图符号和地图符号化的概念" class="headerlink" title="1. 地图符号和地图符号化的概念"></a>1. 地图符号和地图符号化的概念</h4><p>地图符号：地图的主要表达形式，它是地图区别于其他表示地理环境方法的一个重要特征。地图符号不仅能反映地图要素的存在、类别及其数量和质量特征，而且通过他们的组合，还能反映出地理要素的空间分布、结构、联系以及变化等。</p><p>地图符号化：地图数据的符号化，两层含义：</p><ol><li>在地图设计工作中，指利用符号将地图数据进行分类、分级、概括、抽象的过程；</li><li>在数字地图转换为模拟地图的过程中，指将已处理好的矢量地图数据恢复成可见的图形，并附之以不同符号表示的过程。</li></ol><ul><li>编程法</li><li>信息法<ul><li>直接信息法：直接表示符号图形的各个细部，在信息块中直接存储符号图形的矢量数据或栅格数据</li><li>间接信息法：信息块中不直接存储符号图形数据，而只存储符号图形的几何参数</li></ul></li></ul><h4 id="2-符号绘制-P214"><a href="#2-符号绘制-P214" class="headerlink" title="2. 符号绘制 P214"></a>2. 符号绘制 P214</h4><h4 id="3-地图符号库采用的算法"><a href="#3-地图符号库采用的算法" class="headerlink" title="3. 地图符号库采用的算法"></a>3. 地图符号库采用的算法</h4><p>矢量符号库：信息块法，程序块法，综合法</p><p>栅格符号库：信息块法</p><ul><li>信息块法：用人工或程序将要绘制的符号里的坐标信息，用统一的结构和方法进行描述，这些描述信息存放在数据文件中形成符号库。</li><li>程序块法：对每一类地图符号编写一个绘图子程序，由这些子程序组成符号库。绘图时按照符号的编号调用库中相应的程序，输入相应参数，由程序根据参数及已知数据计算矢量，从而完成地图符号的绘制。</li><li>综合法：其实质是把信息块法和程序法结合在一起，绘制组合式符号。</li></ul><h4 id="4-点符号的生成算法-P215"><a href="#4-点符号的生成算法-P215" class="headerlink" title="4. 点符号的生成算法 P215"></a>4. 点符号的生成算法 P215</h4><ul><li>点状符号信息块法</li></ul><img src="https://img-blog.csdnimg.cn/20200102132406959.png" style="zoom:67%;"><ul><li><p>程序块法</p><p>任何圆都可以用正多边形来逼近，边数越多，圆越光滑。</p><ul><li>以圆弧的起始点坐标，圆弧的起始角、圆弧的终止角、圆弧的起始点半径和终止点半径为参数设计绘圆程序，这个程序就既能绘制圆也能绘制圆弧和螺线。</li><li>以椭圆的起始点坐标、长半轴、短半轴、长半轴与 x 轴的夹角、起始点和终止点到中心点连线分别于x轴的夹角为参数来设计绘制椭圆的程序，这个程序就能绘制椭圆，也能绘制椭圆弧并调整椭圆长轴的方向。</li></ul></li></ul><h4 id="5-线符号的生成算法，线状符号信息块法、土堤符号绘制原理-P219"><a href="#5-线符号的生成算法，线状符号信息块法、土堤符号绘制原理-P219" class="headerlink" title="5. 线符号的生成算法，线状符号信息块法、土堤符号绘制原理 P219"></a>5. 线符号的生成算法，线状符号信息块法、土堤符号绘制原理 P219</h4><ul><li><p>信息块法：把各类线状符号看作是由符号单元沿线状要素中轴线重复串接而成。</p></li><li><p>程序块法：</p><p>解决两个问题：</p><ol><li>确定每一条短横线的位置，确定横短线与中轴线的交点坐标</li><li>确定横短线两端点的坐标</li></ol></li></ul><h4 id="6-面符号信息块法"><a href="#6-面符号信息块法" class="headerlink" title="6. 面符号信息块法"></a>6. 面符号信息块法</h4><ul><li><p>信息块法：存储的是填充符号的单元信息，结构类似线状符号中线—线信息块，但需要增加三种信息：行距、行向倾角（晕线与x轴夹角）、排列方式（“井”型、交错和散列）。</p></li><li><p>程序法：</p><ul><li><p>填充点状符号算法</p><img src="https://img-blog.csdnimg.cn/20200102142050754.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70" style="zoom:50%;"></li><li><p>填充线状符号算法</p><p>算法总体思路:计算所填绘的每条线符与多边形的交点，然后调绘线符绘制程序在两交点间绘制出所要求的线符即可。</p><img src="https://img-blog.csdnimg.cn/20200102142207900.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70" style="zoom:50%;"></li></ul></li></ul><h2 id="第八章-数字表面模型"><a href="#第八章-数字表面模型" class="headerlink" title="第八章 数字表面模型"></a>第八章 数字表面模型</h2><h4 id="1-DEM和数字地面模型（DTM）的区别"><a href="#1-DEM和数字地面模型（DTM）的区别" class="headerlink" title="1. DEM和数字地面模型（DTM）的区别"></a>1. DEM和数字地面模型（DTM）的区别</h4><p>数字正射影像(DOM)</p><ul><li>数字地面模型(DTM)，是要素的平面坐标(x，y)和其他性质的数据集合。如果此属性是高程z，则此数字地面模型又称为数字高程模型(DEM)。</li><li>DEM是建立DTM的基础数据。</li><li>实际上DTM不仅包含高程属性，还包含其它的地表形态属性，如坡度、坡向等。</li></ul><p>DEM和DTM主要用于描述地面起伏状况，可以用于提取各种地形参数，如坡度、坡向、粗糙度等，并进行通视分析、流域结构生成等应用分析。</p><p>DEM可以有多种表达方法，包括网格、等高线、三角网等。</p><h4 id="2-Delaunay三角网、泰森多边形的概念，关系。"><a href="#2-Delaunay三角网、泰森多边形的概念，关系。" class="headerlink" title="2. Delaunay三角网、泰森多边形的概念，关系。"></a>2. Delaunay三角网、泰森多边形的概念，关系。</h4><ul><li><p>定义：</p><p><strong>不规则三角网（TIN）</strong>：由一系列相连的但不重叠的三角形的集合, 而且这些三角形的外接圆不包含这个面域的其他任何点。存储表达：对于每一个三角形、边和节点都对应一个记录。</p><p><strong>Delaunay三角网</strong>：表示数字高程模型的方法，它既减少规则格网方法带来的数据冗余，同时在计算（如坡度）效率方面又优于纯粹基于等高线的方法。</p><p><strong>泰森多边形—冯洛诺伊图（Voronoi diagram）</strong>：指用不规则的小面块来逼近和模拟自然界不规则地理单元的一种方法。对Delaunay三角网的各个边做中垂线，中垂线上的顶点相连就构成了泰森多边形。</p></li><li><p>关系：Voronoi图（泰森多边形） 和 Delaunay三角形 互为对偶图</p></li></ul><h4 id="3-三角网的特点，性质。"><a href="#3-三角网的特点，性质。" class="headerlink" title="3. 三角网的特点，性质。"></a>3. 三角网的特点，性质。</h4><ul><li>Delaunay三角网特性：<br>1）其Delaunay三角网是唯一的；<br>2）三角网的外边界构成了点集P的凸多边形“外壳”；<br>3）没有任何点在三角形的外接圆内部，反之，如果一个三角网满足此条件，那么它就是Delaunay三角网。<br>4）如果将三角网中的每个三角形的最小角进行升序排列，则Delaunay三角网的排列得到的数值最大，从这个意义上讲，Delaunay三角网是“最接近于规则化”的三角网。 </li><li>Delaunay三角形性质（基本准则）：<br>1) 外接圆准则：任何一个Delaunay三角形的外接圆的内部不能包含其它任何点。<br>2) 最大化最小角原则：每两个相邻的三角形构成的凸四边形的对角线，在相互交换后，六个内角的最小角不再增大。<br>3) 局部优化准则：先求出包含新插入点p的外接圆的三角形，这种三角形称为影响三角形。删除影响三角形的公共边，将p与全部影响三角形的顶点连接，完成p点在原Delaunay三角形中的插入。</li></ul><h4 id="4-泰森的应用范围，应用场景，多边形特征"><a href="#4-泰森的应用范围，应用场景，多边形特征" class="headerlink" title="4. 泰森的应用范围，应用场景，多边形特征"></a>4. 泰森的应用范围，应用场景，多边形特征</h4><ul><li>泰森多边形应用范围：<ul><li>泰森多边形可用于定性分析、统计分析、邻近分析等。</li><li>例如，可以用离散点的性质来描述泰森多边形区域的性质；可用离散点的数据来计算泰森多边形区域的数据；判断一个离散点与其它哪些离散点相邻时，可根据泰森多边形直接得出，且若泰森多边形是n边形，则就与n个离散点相邻；当某一数据点落入某一泰森多边形中时，它与相应的离散点最邻近，无需计算距离。</li></ul></li><li>泰森多边形特点<ul><li>多边形的边总垂直平分两个邻接采样点的连线</li><li>多边形内任何位置总是离该多边形内样点的距离最近，离相邻多边形内样点最远</li><li>每个多边形内只有一个点</li><li>泰森多边形内部的顶点必有3条边同它连接，这些边相邻的3个三多边形的两两拼接的公共边</li><li>泰森多边形内部的顶点周围有3个离散数据点，将其连成三角形后，该三角形的外接圆心即为该顶点</li></ul></li></ul><h4 id="3-如何用点集生成TIN"><a href="#3-如何用点集生成TIN" class="headerlink" title="3. 如何用点集生成TIN"></a>3. 如何用点集生成TIN</h4><p>不规则点集生成TIN</p><ol><li><p>凸包生成</p><ol><li>min(x-y)、min(x+y)、max(x-y)、max(x+y)的四个点构成的多边形作为初始凸包。</li><li>对于每个凸包上的点I，设它的后续点为J，计算矢量线段IJ右侧的所有点到IJ的距离，求出距离最大的点K。</li><li>将K插入I、J之间，并将K赋给J。</li><li>当凸包中任意相邻两点连线的右侧不存在离散点时，结束点集凸包求取过程。</li></ol></li><li><p>环切边界法凸包三角剖分</p><ol><li>在凸包链表中每次寻找由相邻两条凸包边组成的三角形</li><li>该三角形的内部和边界上都不包含凸包上的任何其它点。</li><li>将这个点去掉后得到新的凸包链表。</li><li>重复这个过程，直到凸包链表中只剩三个离散点为止。</li><li>将凸包链表中的最后三个离散点构成一个三角形，结束凸包三角剖分过程。</li><li>完成将凸包中的点构成了若干Delaunay三角形。</li></ol></li><li><p>离散点内插(局部优化准则)</p><p>三角剖分之后，不在凸包上的其余离散点，可采用逐点内插的方法进行剖分。</p><ol><li>找出外接圆包含待插入点的所有三角形，构成插入区域。</li><li>删除插入区域内的三角形公共边，形成由影响三角形顶点构成的多边形。 </li><li>将插入点与多边形所有顶点相连，构成新的Delaunay三角形。</li><li>重复1、2、3，直到所有非凸壳离散点都插入完为止。</li><li>完成了Delaunay三角网的构建。</li></ol></li></ol><h4 id="4-蒂洛尼三角网–空壳-PPT"><a href="#4-蒂洛尼三角网–空壳-PPT" class="headerlink" title="4. 蒂洛尼三角网–空壳 (PPT)"></a>4. 蒂洛尼三角网–空壳 (PPT)</h4><p>点集P的空集的交集</p><h2 id="第三、四章-地图的设计和制作"><a href="#第三、四章-地图的设计和制作" class="headerlink" title="第三、四章 地图的设计和制作"></a>第三、四章 地图的设计和制作</h2><h4 id="1-色彩-P83"><a href="#1-色彩-P83" class="headerlink" title="1. 色彩 P83"></a>1. 色彩 P83</h4><ul><li><p>设色的要求P87 </p><ol><li>地图的色彩应与地图的性质、用途相协调</li><li>地图的色彩应层次分明突出重点内容</li><li>充分利用色彩的感觉和象征性</li><li>地图色彩应系统协调突出特色</li></ol></li><li><p>色彩在地图的应用和设计  P88-P102</p><ol><li><p>色彩三要素</p><ul><li>色相（色别、色种）</li><li>明度（亮度）</li><li>纯度（饱和度、彩度、鲜艳度）</li></ul></li><li><p><font color="orange">地图色彩的类别</font></p><ul><li>点状色彩</li><li>线状色彩</li><li>面状色彩（质别底色、区域底色、色级底色、衬托底色）</li><li>注记色彩</li></ul></li><li><p><font color="orange">地图设计中的色彩设计</font></p><ul><li>点状符号的色彩设计</li><li>线状符号的色彩设计</li><li>面状符号的色彩设计<ol><li>根据性质选用色值</li><li>同类元素应在同一色系中选色</li><li>面状色之间协调选色</li><li>面状色应选用柔和的色值</li></ol></li></ul><p>应用：</p><p><strong>行政区划图的色彩设计</strong></p><p>总体用同一色系，分区用多色相，避免用原色</p><p><strong>分层设色法的色彩设计</strong></p><ul><li>运用色彩视觉心理特性</li><li>色彩过渡自然</li><li>注意等值线的色彩</li></ul></li><li><p>色彩对比的应用</p><ol><li><p>色彩明度对比的应用：清晰感、层次感、节奏感、空间感、多样统一美</p></li><li><p>色相对比的应用</p></li><li><p>纯度对比的应用</p><p>应用：</p></li></ol><p><strong>地图层次设计中色彩对比手法的综合运用：</strong></p></li></ol><ul><li>冷暖对比<ul><li>纯度对比</li></ul></li><li>明度对比</li></ul></li><li><p>地图色彩在地图制作中如何运用和设计的？</p><ol><li>分区用多色相，避免用原色</li><li>运用色彩视觉心理特性</li><li>色彩过渡自然</li><li>注意等值线的色彩</li></ol></li><li><p>色彩的作用</p><ol><li>色彩的运用简化了图形符号系统</li><li>丰富了地图内容，提高了地图传递空间信息的容量</li><li>提高地图内容表现的科学性</li><li>改善地图语言的视觉效果</li><li>提高地图的审美价值 </li></ol></li></ul><h4 id="色彩的设计使用"><a href="#色彩的设计使用" class="headerlink" title="色彩的设计使用"></a>色彩的设计使用</h4><p>色彩可提高地图的表现力及清晰度，还可增强地图的艺术性。首先确定图幅或图组的主色调，然后再进入局部的色彩设计，地图色彩设计具有不确定性和多义性。<font color="red">特别忌讳孤立地对待某一种色彩，而不顾及周围的色彩对它的影响。</font>设计时必须从整体出发来选用色彩、确定色彩构成的协调关系。</p><h5 id="点符号"><a href="#点符号" class="headerlink" title="点符号"></a>点符号</h5><p>点状符号设计的特点：</p><ol><li>表示呈点状分布的专题要素</li><li>表示顺序分级、间隔分级和数值表示的呈线状和呈面状分布的专题要素</li><li>表示专题要素的定性特征、分类特征</li><li>表示出专题要素的数量特征、分级特征。</li></ol><p>设计的规律和方法：</p><ol><li>不同的色相表示现象的类别即质量特征。</li><li>尽量与实物的固有色或心理印象色相似，便于读者引起联想。</li></ol><h5 id="线符号"><a href="#线符号" class="headerlink" title="线符号"></a>线符号</h5><p>在地图中起骨架作用，是地图信息的主要载体。由于线状符号十分狭窄细长，只有通过色彩的加重表示，才能将线状符号凸显出来。</p><p>设色：</p><ol><li>主要界线色彩要“鲜、浓、深、粗”，如大红、黑色等，次要界线色彩要“灰、淡、浅、细”，如浅绿、浅褐等。</li><li>对于交通线、河流、海岸线等线状符号，若属专题要素则按主要界线色彩处理，若属底图要素则依次要界线色彩处理。</li></ol><h5 id="面符号"><a href="#面符号" class="headerlink" title="面符号"></a>面符号</h5><p>区分层次，选用不同的色值。</p><p>设色：</p><ul><li>对于分级统计图，分级数≤4时，用单色系列，即用一个色相的不同浓淡逐渐过渡；</li><li>分级数≥5时，可用多色系列，即色阶中包含2个或更多的色相。</li><li>数量等级高的用饱和度高的颜色，数量等级低的用饱和度低的颜色。</li></ul><p>应用：</p><ol><li><strong>分层设色</strong>主要考虑色彩的象征意义，例如地势图中用橙色到紫色的过渡表示山地的起伏。</li><li><strong>范围法设色</strong>，若反映质量差别以对比色为主，反映不同时期范围的以类比色为主，兼顾现象的象征意义。如易涝区用冷色表示，易旱区用暖色表示</li><li><strong>区域底色设色</strong>应浅淡。</li><li><strong>衬托底色设色</strong>应选择不饱和的原色，突出其他专题要素，不给读者刺目的感觉。</li></ol><h5 id="色彩配合原则"><a href="#色彩配合原则" class="headerlink" title="色彩配合原则"></a>色彩配合原则</h5><ol><li>先选定面积色的主调，再选符号色；</li><li>面积色与符号色的色相最好属对比色关系，也可以是邻近色关系；</li><li>底图线划用色一般用中度复色。当符号表示结构或多项组合指标时，其选色要注意冷暖相间和明暗相间。</li></ol><h4 id="符号的设计使用"><a href="#符号的设计使用" class="headerlink" title="符号的设计使用"></a>符号的设计使用</h4><h6 id="主要表现为类别和层次两方面"><a href="#主要表现为类别和层次两方面" class="headerlink" title="主要表现为类别和层次两方面"></a><strong>主要表现为类别和层次两方面</strong></h6><p>点状：</p><ul><li>不同类型的地图要素符号系统之间的形态要有差异(横向对比设计)。</li><li>利用尺寸、结构、虚实、明度表示层级差异(纵向对比设计)。</li></ul><p>线状：</p><ul><li>不同类型的地图要素符号系统之间的形态要有差异(横向对比设计)。</li><li>利用宽度、明度、虚实度等反映层次，重要、等级高的线用实线、粗线表示；次要、等级低的线用虚线、细线表示(纵向对比设计)。</li><li>对于道路，河流，境界有其特殊的规范。</li></ul><p>面状：</p><ul><li>利用几何网纹设计出相对多的纹样，纹样越简单越好，网纹的种类不易过多(横向对比设计)。</li><li>利用网纹密度和明度的对比反映不同的层次(纵向对比设计)。</li><li>网纹线条的宽度不宜超过边界线，要注意网纹密度和网纹明度的对比。</li></ul><h4 id="注记的设计使用"><a href="#注记的设计使用" class="headerlink" title="注记的设计使用"></a>注记的设计使用</h4><p><strong>字体</strong>的不同主要用于区分不同事物的类别。图名、区域名称要求最明显突出；斜体多用于海洋、河流和湖泊。</p><p><strong>字色</strong>可以加强分类概念，如水体用蓝色，地貌用棕色。</p><p><strong>字号</strong>反映对象的重要性和数量等级，等级高、数量大的对象的注记应该大而明显。</p><p><strong>字隔</strong>在某种程度上隐含了对象的分布特征(点、线、面)，最小字隔为0.2mm，最大不应超过字大的5~6倍。点状物用小字隔标记；线状物用较大字隔沿线状物注出；面状物根据其面积大小更改字隔，图形较大时应重复注记。</p><p><strong>字位</strong>明确显示对象，注记不能离对象太远，也不能互相覆盖。</p><p><strong>布置</strong>表示对象的走向等信息。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第一章&quot;&gt;&lt;a href=&quot;#第一章&quot; class=&quot;headerlink&quot; title=&quot;第一章&quot;&gt;&lt;/a&gt;第一章&lt;/h2&gt;&lt;h4 id=&quot;1-计算机制图的概念-P1-数字地图，电子地图的概念（PPT），区分，名词解释&quot;&gt;&lt;a href=&quot;#1-计算机制图的概念
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>GIS程序设计 知识总结</title>
    <link href="http://yoursite.com/2020/01/11/GIS%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%20%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/01/11/GIS程序设计 知识总结/</id>
    <published>2020-01-11T06:54:49.225Z</published>
    <updated>2020-01-11T06:56:34.433Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简答"><a href="#简答" class="headerlink" title="简答"></a>简答</h2><h4 id="1-开发模式，开发软件的特点，概念"><a href="#1-开发模式，开发软件的特点，概念" class="headerlink" title="1. 开发模式，开发软件的特点，概念"></a>1. 开发模式，开发软件的特点，概念</h4><ol><li>独立开发：<ul><li>定义：不依赖于任何GIS工具软件，从空间数据的采集、编辑到数据的处理分析及结果输出，所有的算法都由开发者独立设计，然后选用某种程序设计语言，如VC++、VB、Delphi、C++ Builder等，在一定的操作系统平台上编程实现。</li><li>特点：<ul><li>无需依赖任何商业GIS工具软件，减少了开发成本</li><li>综合程度和操作效率最高</li></ul></li></ul></li><li>单纯二次开发：<ul><li>定义：在宏语言中调用DLL库，定义GIS系统工具不提供或不支持的功能，</li><li>特点：<ul><li>功能弱，程序不美观，开发收到限制</li><li>增加学习负担</li></ul></li></ul></li><li>集成二次开发：<ul><li>定义：利用专业GIS工具软件或其提供的组件来实现GIS的基本功能，采用可视化开发工具，进行集成开发。集成二次开发目前主要有OLE／DDE方式和组件式方式两种。</li><li>特点：<ul><li>GIS工具软件能够提供成熟的功能。例如：空间数据库存储、空间分析等</li><li>高效，便捷，不需要从底层学习具体的实现原理，易上手。</li></ul></li></ul></li></ol><blockquote><pre><code>1. 基于arcengine或者arcobject 2. 基于com（原理）</code></pre></blockquote><h4 id="2-接口及类：特，用，概，接口应用"><a href="#2-接口及类：特，用，概，接口应用" class="headerlink" title="2. 接口及类：特，用，概，接口应用"></a>2. 接口及类：特，用，概，接口应用</h4><p>   接口的特点：</p><pre><code>1. 接口的多态性：许多不同的类可以支持相同的接口2. 接口的继承性：所有的子类都继承了父类的接口</code></pre><p>   面向接口编程：</p><ul><li><p>接口定义了能做什么，类定义了该怎么做。类实现了接口中的方法。</p></li><li><p>接口描述了一系列外部可见操作</p></li><li><p>接口具有类内置的一组属性和方法</p><p>Com类代码：</p></li><li><p>接口模块：定义方法和属性</p></li><li><p>类模块：实现方法和属性</p><blockquote><p>COM 对象的接口是抽象的，接口与类不同。因为接口没有 任何的实现，所以不能通过自身实例化。因为接口没有任何的实现，所以不能通过自身实例化。接口由具体的类来实现由具体的类来实现，功能用接口抽象地模拟，并且用类去真正实现。</p></blockquote><h6 id="地图接口"><a href="#地图接口" class="headerlink" title="地图接口"></a>地图接口</h6><ol><li>ILayer接口:所有图层类都可以实现该接口，定义了所有图层公共的方法和属性。<ul><li>Name属性:返回图层名称；</li><li>MaximumScale属性:显示或设置图层可以出现的最大比例尺；</li><li>MinmumScale属性:显示或设置图层可以出现的最小比例尺；</li><li>ShowTips属性：指示当鼠标放在图层中某个要素上时，是否出现Tips;</li><li>SpatialReference属性：设置图层的空间参考。</li></ul></li><li>IFeatureLayer接口:主要用于设置要素图层的数据源（FeatureClass）<ul><li>DataSourceType属性：返回图层的数据源类型；</li><li>Search方法：通过2个参数，过滤器（IQueryFilter类型的对象）和布尔值（用于返回要素游标是否循环，返回一个Icursor对象）</li></ul></li></ol><blockquote><p>IFeatureLayer接口继承自Ilayer接口，IFeatureClass接口继承自Iclass接口。</p><p>FeatureLayer可以创建自己的对象，FeatureClass不行</p></blockquote><h6 id="类"><a href="#类" class="headerlink" title="类"></a>类</h6></li></ul><ol><li><p>Version类库：ArcEngine 10.0新出的类库，包含里将独立应用程序绑定到特定的ArcGIS系列产品的函数和方法。</p></li><li><p>System：ystem库是ArcGIS框架中最底层的一个库，它包含了一些被其他库使用的一些基础组件。 </p></li><li><p>SystemUI：SystemUI库定义了一些在ArcGIS中被用户界面组件使用的类型。象ICommand和ITool这样的接口就在这里定义。</p></li><li><p>Geometry：几何库包含了核心的几何对象，比如点，面，线等。在几何库中还定义和实现了空间参考的对象，包括投影坐标系和几何坐标系。</p></li><li><p>Display：显示库包含了支持在输出设备上显示图形的组件，屏幕显示、符号、颜色、显示交互（Feedback)等都在这个库中定义。</p></li><li><p>Server：提供了连接、管理ArcGIS Server的核心类，如IServerObjectManager、IServerObject等，其他类库的对象可以通过ArcGIS Server的IServerContext进行远程创建。</p></li><li><p>Output：提供了将MapControl和PagelayoutControl中的地图输出到打印机以及其他设备文件中。</p></li></ol><h4 id="3-对象模型图：类和关系，分别有什么特点"><a href="#3-对象模型图：类和关系，分别有什么特点" class="headerlink" title="3. 对象模型图：类和关系，分别有什么特点"></a>3. 对象模型图：类和关系，分别有什么特点</h4><ol><li><p>类</p><ul><li>抽象类：不能用于创建对象，对子类例程进行了规定（通过类型继承）。</li><li>普通类：不能直接创建对象，但可以作为另一个类的属性或者通过另一个类的实例化来创建对象。</li><li>组件类：可以直接创建对象。</li></ul></li><li><p>关系</p><ul><li><p>关联关系：表示类之间的关系。关联的两端都定义了多样性。</p></li><li><p>组成关系：是一种“整体类”对象控制着“部分类”对象的生命期关系。</p></li><li><p>类型继承关系：定义共享父类的属性和方法，同时又具有了自己独特的属性和方法的特定对象类。</p></li><li><p>实例化关系：表示某个类的对象具有创建另一个类的对象的方法。</p></li><li><p>N元关系：表示两个以上的类相互关联。在各个关联分支的交叉点上放置一个菱形。</p></li><li><p>多样性关系：是对能于另一个对象关联的对象数目的一种限制。关联和组成关系的两端都定义了多样性。</p><img src="https://img-blog.csdnimg.cn/20191106115227332.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70" style="zoom:67%;"></li></ul><h5 id="抽象类-AbstractClass-："><a href="#抽象类-AbstractClass-：" class="headerlink" title="抽象类(AbstractClass)："></a>抽象类(AbstractClass)：</h5><ol><li><p>不能创建或实例化</p><ol start="2"><li>抽象类永远不能有实例</li></ol></li><li><p>为子类定义了泛化（general）</p><ol start="4"><li>子类集成了抽象类的接口</li></ol><blockquote><p>抽象类的OMD 符号: 2维灰色矩形</p></blockquote></li></ol><h5 id="普通类-可实例化类-Class"><a href="#普通类-可实例化类-Class" class="headerlink" title="普通类/可实例化类 (Class)"></a>普通类/可实例化类 (Class)</h5><ol><li><p>不能创建或实例化</p></li><li><p>抽象类永远不能有实例</p></li><li><p>为子类定义了泛化（general）</p></li><li><p>子类集成了抽象类的接口</p><p>IRow pNewRow；</p><pre><code>ITable  pTable;</code></pre><p>pNewRow  = pTable.CreateRow();</p><pre><code>IRow row = table.CreateRow();</code></pre><blockquote><p>实例化类的OMD符号： 3维白色的矩形</p></blockquote></li></ol><h5 id="组件类-可创建的类-CoClass"><a href="#组件类-可创建的类-CoClass" class="headerlink" title="组件类/可创建的类(CoClass)"></a>组件类/可创建的类(CoClass)</h5><ol><li><p>可以创建:使用 New关键字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IMap pmap = new Map();</span><br></pre></td></tr></table></figure></li><li><p>实例化: 从其它对象获得</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Imap pMap;</span><br><span class="line">pMap = m_MapDocument.get_Map(i);</span><br></pre></td></tr></table></figure><blockquote><p>可创建类的OMD符号：3维灰色矩形         </p></blockquote></li></ol></li><li><h4 id="AE控件有哪些，分类特点"><a href="#AE控件有哪些，分类特点" class="headerlink" title="AE控件有哪些，分类特点"></a>AE控件有哪些，分类特点</h4><ol><li>制图控件: MapControl 和PageLayoutControl</li><li>框架控件: TOCControl（内容表控件） 和ToolbarControl(工具条控件)–（buddy控件捆绑）</li><li>许可控件：LicenseControl（启动时执行License初始化）</li><li>符号控件:SymbologyControl</li><li>Reader Control: ReaderControl和ReaderControl</li><li>三维控件：GlobeControl和SceneControl </li></ol></li><li><h4 id="矢量数据集相关类的关系"><a href="#矢量数据集相关类的关系" class="headerlink" title="矢量数据集相关类的关系"></a>矢量数据集相关类的关系</h4><ol><li>矢量数据数据的加载，分析，查询</li></ol><p>接口：</p><pre><code>1. **IWorkspaceFactory**：创建工作工厂2. **IWorkspace**：工作化工作空间   3. **IFeatureWorkspace**：接口转换为要素工作空间   4. **IFeatureClass**：创建featureClass   5. **IFeatureLayer**：创建要素图层   6. **IMap**：接收AxMapControl中的地图对象</code></pre><p>类：</p><ol><li><strong>ShapefileWorkspaceFactory</strong>：作为子类创建工作空间</li><li><strong>FeatureLayer</strong>：创建要素图层用于接收打开的shpfile文件的featureClass，作为图层，只是表现形式，真正的数据在FeatureClass中。</li><li><strong>FeatureClass</strong>是从Dataset继承过来的,FeatureClass是有空间数据字段的数据集。</li></ol></li></ol><h2 id="程序流程（简答）"><a href="#程序流程（简答）" class="headerlink" title="程序流程（简答）"></a>程序流程（简答）</h2><h5 id="1-数据访问，添加矢量"><a href="#1-数据访问，添加矢量" class="headerlink" title="1. 数据访问，添加矢量"></a>1. 数据访问，添加矢量</h5><p>矢量加载：</p><ol><li>获取文件路径和文件名称</li><li>创建地理空间工厂WorkspaceFactory（怎么创建）</li><li>实例化地理空间Workspace（怎么实例化）</li><li>获取FeatureClass</li><li>创建要素图层FeatureLayer</li><li>为要素图层定义数据集FeatureClass</li><li>添加至地图控件</li><li>刷新地图视图</li></ol><h5 id="2-空间数据显示—图层渲染"><a href="#2-空间数据显示—图层渲染" class="headerlink" title="2. 空间数据显示—图层渲染"></a>2. 空间数据显示—图层渲染</h5><pre><code>1. 抽象类：Symbol，MarkerSymbol，LineSymbol，FillSymbol2. 组件类：       1. RgbColor：颜色       2. SimpleMarkerSymbol，SimplelineSymbol，SimplefillSymbol：简单点线面符号       3. SimpleRenderer：简单渲染</code></pre><ol><li>实例化<code>ISimpleMarkerSymbol</code>，提供简单点符号</li><li>实例化<code>ISimpleRenderer</code>，提供简单渲染器</li><li>获取渲染图层赋值给<code>IGeoFeatureLayer</code>，提供要素图层对成员控制地理特征渲染的入口,获取渲染图层</li><li>调用<code>pGeoFeatureLayer.Renderer</code>属性赋值渲染器</li><li>刷新地图视图</li></ol><h5 id="3-元素添加至地图"><a href="#3-元素添加至地图" class="headerlink" title="3. 元素添加至地图"></a>3. 元素添加至地图</h5><ol><li>获取<code>pagelayerout</code>对象、活动视图<code>pActiveView</code>、图形容器<code>pGraphicsContainer</code>、地图窗口<code>MapFrame</code></li><li>创建<code>UID</code>对象，设置<code>value</code></li><li>通过<code>MapFrame</code>的<code>CreateSurroundFrame(uid,null)</code>方法创建<code>mapSurroundFrame</code></li><li>实例化一个区域几何<code>envelope</code>（包裹元素的盒子）。通过<code>PutCoords(xmin, ymin, xmax, ymax)</code>方法设置地图上的位置</li><li>通过<code>mapSurroundFrame</code>获取<code>Element</code>，设置框架的几何体属性<code>Geometry</code>为区域几何对象<code>envelope</code></li><li>通过图形容器<code>pGraphicsContainer</code>的<code>AddElement(Element，ZOrder)</code>方法把地图要素添加地图布局。</li><li>刷新视图。</li></ol><p>接口：</p><ol><li>IGraphicsContainer：管理map上的Element对象，获取图形容器</li><li>IMapFrame：访问控制地图元素对象的成员</li><li>IMapSurroundFrame：获取或更新存储在帧中的环绕对象（指北针、比例尺条或图例）</li><li>IEnvelope：地物的外接矩形，用来放置元素。</li><li>IElement：通过这一属性设置该元素的外接矩形在地图上的位置。所有图形元素和框架元素都实现的接口，可以确定元素的Geometry属性。</li></ol><p>类：</p><ol><li>UID用来设置元素类型的编码</li><li>MapFrame： 用于显示地图的图形元素。</li><li>MapSurroundFrame：用于显示地图包围的图形元素。</li><li>Envelope：包络线，是每个几何形体的最小外接矩形。每个Geometry都拥有一个Envelope</li><li>Element：抽象类</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span>(<span class="params"><span class="keyword">string</span> <span class="keyword">value</span>,<span class="keyword">double</span> xmin,<span class="keyword">double</span> ymin, <span class="keyword">double</span> xmax, <span class="keyword">double</span> ymax</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取图形容器</span></span><br><span class="line">    IGraphicsContainer graphicsContainer = pageLayoutControl.PageLayout <span class="keyword">as</span> IGraphicsContainer;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据MapSurround的uid，创建相应的MapSurroundFrame和MapSurround</span></span><br><span class="line">    UID uid = <span class="keyword">new</span> UID();</span><br><span class="line">    uid.Value = <span class="keyword">value</span>;</span><br><span class="line">    IMapFrame mapFrame = pageLayoutControl.PageLayout <span class="keyword">as</span> IMapFrame;</span><br><span class="line">    IMapSurroundFrame mapSurroundFrame = mapFrame.CreateSurroundFrame(uid, <span class="literal">null</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//为要素实例化一个区域几何。元素的外接矩形</span></span><br><span class="line">    envelope = <span class="keyword">new</span> Envelope() <span class="keyword">as</span> IEnvelope;</span><br><span class="line">    envelope.PutCoords(xmin, ymin, xmax, ymax);</span><br><span class="line">       </span><br><span class="line">    <span class="comment">//获取Element，用来设置框架的几何体属性</span></span><br><span class="line">    IElement eement = mapSurroundFrame <span class="keyword">as</span> IElement;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//geometry属性控制区域几何在地图上的位置</span></span><br><span class="line">    element.Geometry = envelope;</span><br><span class="line">    </span><br><span class="line">    graphicsContainer.AddElement(element, <span class="number">0</span>);  </span><br><span class="line">    activeView.Refresh();</span><br><span class="line">    pagelayoutcontrol.Refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-属性查询"><a href="#4-属性查询" class="headerlink" title="4. 属性查询"></a>4. 属性查询</h5><h6 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h6><ol><li>获取数据源<code>FeatureClass</code></li><li>循环给每一列写字段名</li><li>获取查询返回的游标，<code>null</code>代表没有查询条件，返回整个表</li><li>用<code>IFeature</code>接收指针指向的数据</li><li>将指针指向第一个要素属性行</li><li>如果<code>pFeature</code>不为空则循环7，8，9步</li><li>获取表中的新行，并将引用赋值给<code>DataRow</code></li><li>为每一个属性单元格赋值</li><li>游标指向下一行要素并重新赋值给<code>pFeature</code></li><li>将<code>DataTable</code>赋值给<code>dataGridView</code>的数据源</li></ol><h6 id="类："><a href="#类：" class="headerlink" title="类："></a>类：</h6><ol><li>QueryFilter：过滤数据通过属性值或者属性之间的关系</li><li>QueryDef：代表了数据库中基于一个或多个表、要素类的进行的属性查询，通过这个对象，用户可以在多个表间建立连接，并且保证在这个连接基础上的查询可以实现。</li><li>FeatureCursor：普通类，通过<code>pFeatureClass.Search(filter, false);</code>实例化</li></ol><h6 id="接口："><a href="#接口：" class="headerlink" title="接口："></a>接口：</h6><ol><li>IFeatureClass：数据源</li><li>IQueryFilter：用于属性查询</li><li>IFeatureCursor：查询返回的游标</li><li>IFeature：要素，返回游标中要素集单位</li></ol><h5 id="5-空间查询"><a href="#5-空间查询" class="headerlink" title="5. 空间查询"></a>5. 空间查询</h5><h6 id="步骤：-1"><a href="#步骤：-1" class="headerlink" title="步骤："></a>步骤：</h6><ol><li>获取<code>pFeatureLayer</code></li><li>实例化过滤器<code>pSpatialFilter</code></li><li>创建<code>geometry</code>，用来装载框选范围</li><li>将框选几何<code>geometry</code>赋给<code>pSpatialFilter</code></li><li>设置空间范围的查询条件（从空间查询窗体获得）</li><li>实例化查询接口<code>pfeatureSelection</code></li><li>调用查询方法<code>SelectFeatures(过滤器, esriSelectionResultEnum.esriSelectionResultNew, false);</code>实现高亮</li><li>刷新图层</li></ol><h6 id="接口：-1"><a href="#接口：-1" class="headerlink" title="接口："></a>接口：</h6><ol><li>IFeatureLayer：当前的要素图层，用于接口转换</li><li>ISpatialFilter：过滤器，用来设置空间范围的查询条件</li><li>IGeometry：几何类型，获取框选范围</li><li>IFeatureSelection：查询接口，用于查询，没有返回值，实现高亮</li></ol><h6 id="类：-1"><a href="#类：-1" class="headerlink" title="类："></a>类：</h6><ol><li>FeatureLayer：组件类，要素图层</li><li>SpatialFilter：组件类，过滤器</li><li>Geometry：普通类，通过<code>mapControl.TrackRectangle();</code>实例化，几何类型</li></ol><h2 id="程序设计题"><a href="#程序设计题" class="headerlink" title="程序设计题"></a>程序设计题</h2><h4 id="1-面向接口的编程及接口转换"><a href="#1-面向接口的编程及接口转换" class="headerlink" title="1. 面向接口的编程及接口转换"></a>1. 面向接口的编程及接口转换</h4><h4 id="2-接口的继承"><a href="#2-接口的继承" class="headerlink" title="2. 接口的继承"></a>2. 接口的继承</h4><h4 id="3-图层的显示及渲染"><a href="#3-图层的显示及渲染" class="headerlink" title="3. 图层的显示及渲染"></a>3. 图层的显示及渲染</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span></span></span><br><span class="line"><span class="comment">//Shp</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span></span></span><br><span class="line">OpenFileDialog pOpenfileDialog = <span class="keyword">new</span> OpenFileDialog();</span><br><span class="line"><span class="keyword">if</span> (pOpenfileDialog.ShowDialog() == DialogResult.OK)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">string</span> path = pOpenfileDialog.FileName;</span><br><span class="line">    <span class="keyword">bool</span> shp = path.EndsWith(<span class="string">".shp"</span>);</span><br><span class="line">    <span class="keyword">if</span> (shp)</span><br><span class="line">        openShpFile(path);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">openShpFile</span>(<span class="params"><span class="keyword">string</span> file</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//获取最后一个“\\”时的索引位置</span></span><br><span class="line">    index = file.LastIndexOf(<span class="string">"\\"</span>);</span><br><span class="line">    <span class="comment">//获得shp文件的路径</span></span><br><span class="line">    <span class="keyword">string</span> filePath = file.Substring(<span class="number">0</span>, index);</span><br><span class="line">    <span class="comment">//获得shp文件名</span></span><br><span class="line">    <span class="keyword">string</span> fileName = file.Substring(index + <span class="number">1</span>, file.Length - (index + <span class="number">1</span>));</span><br><span class="line">    <span class="comment">//由工作空间工厂创建shp工作空间工厂类</span></span><br><span class="line">    IWorkspaceFactory pWorkspaceFactory = <span class="keyword">new</span> ShapefileWorkspaceFactory();</span><br><span class="line">    <span class="comment">//打开工作空间</span></span><br><span class="line">    IWorkspace pWorkspace = pWorkspaceFactory.OpenFromFile(filePath, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//转换工作空间为要素工作空间</span></span><br><span class="line">    IFeatureWorkspace pFeatureWorkspace = pWorkspace <span class="keyword">as</span> IFeatureWorkspace;</span><br><span class="line">    <span class="comment">//打开要素类</span></span><br><span class="line">    IFeatureClass pFC = pFeatureWorkspace.OpenFeatureClass(fileName);</span><br><span class="line">    <span class="comment">//创建要素图层</span></span><br><span class="line">    IFeatureLayer pFLayer = <span class="keyword">new</span> FeatureLayer();</span><br><span class="line">    <span class="comment">//设置图层的featureclass为上面打开的文件</span></span><br><span class="line">    pFLayer.FeatureClass = pFC;</span><br><span class="line">    <span class="comment">//设置图层的名称</span></span><br><span class="line">    pFLayer.Name = pFC.AliasName;</span><br><span class="line">    <span class="comment">//转换featurelayer为layer</span></span><br><span class="line">    ILayer pLayer = pFLayer <span class="keyword">as</span> ILayer;</span><br><span class="line">    IMap pMap = mapControl.Map;</span><br><span class="line">    <span class="comment">//添加图层</span></span><br><span class="line">    pMap.AddLayer(pLayer);</span><br><span class="line">    <span class="comment">//刷新</span></span><br><span class="line">    mapControl.ActiveView.Refresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span></span></span><br><span class="line"><span class="comment">//渲染</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//简单渲染，点符号</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">easy_point</span>(<span class="params"><span class="keyword">string</span> filename, IRgbColor point_rgb, <span class="keyword">int</span> width</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="comment">//实例化ISimpleFillSysmbol变量, 提供简单的填充符号类型</span></span><br><span class="line">ISimpleMarkerSymbol pSimplemarkerSymbol = <span class="keyword">new</span> SimpleMarkerSymbol();</span><br><span class="line">     pSimplemarkerSymbol.Color = point_rgb;</span><br><span class="line">     pSimplemarkerSymbol.OutlineSize = width;</span><br><span class="line">     <span class="comment">//实例化简单渲染变量</span></span><br><span class="line">     ISimpleRenderer pSimpleRender = <span class="keyword">new</span> SimpleRenderer();</span><br><span class="line">     <span class="comment">//设置pSimpleRender的符号样式</span></span><br><span class="line">     pSimpleRender.Symbol = pSimplemarkerSymbol <span class="keyword">as</span> ISymbol;</span><br><span class="line">Render_tool(pSimpleRender, filename);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Render_tool</span>(<span class="params">ISimpleRenderer pSimpleRenderer, <span class="keyword">string</span> filename</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="comment">//提供要素图层对成员控制地理特征渲染的入口,获取渲染图层</span></span><br><span class="line">      IGeoFeatureLayer pGeoFeatureLayer = getGeoLayer(filename);</span><br><span class="line">      <span class="keyword">if</span> (pGeoFeatureLayer != <span class="literal">null</span>)</span><br><span class="line">          <span class="comment">//调用Renderer属性, 具体说明如何通过图层要素渲染器渲染图层</span></span><br><span class="line">          pGeoFeatureLayer.Renderer = pSimpleRenderer <span class="keyword">as</span> IFeatureRenderer;</span><br><span class="line">      mapControl.ActiveView.Refresh();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IGeoFeatureLayer <span class="title">getGeoLayer</span>(<span class="params"><span class="keyword">string</span> layerName</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      ILayer pLayer; <span class="comment">//定义图层</span></span><br><span class="line">      IGeoFeatureLayer pGeoFeatureLayer; <span class="comment">//定义要素图层</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CSR_mapControl.LayerCount; i++)</span><br><span class="line">      &#123;</span><br><span class="line">           pLayer = CSR_mapControl.get_Layer(i);</span><br><span class="line">           <span class="comment">//若当前图层不为空且与与layerName的值相同</span></span><br><span class="line">           <span class="keyword">if</span> (pLayer != <span class="literal">null</span> &amp;&amp; pLayer.Name == layerName)</span><br><span class="line">           &#123;</span><br><span class="line">                pGeoFeatureLayer = pLayer <span class="keyword">as</span> IGeoFeatureLayer;</span><br><span class="line">                <span class="keyword">return</span> pGeoFeatureLayer;</span><br><span class="line">           &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span></span></span><br><span class="line"><span class="comment">//Tiff</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//工作空间实例化</span></span><br><span class="line">IWorkspaceFactory pRasterWsF = <span class="keyword">new</span> RasterWorkspaceFactory();</span><br><span class="line">IWorkspace pWs = pRasterWsF.OpenFromFile(RasterPath, <span class="number">0</span>);</span><br><span class="line">IRasterWorkspace pRasterWs = pWs <span class="keyword">as</span> IRasterWorkspace;</span><br><span class="line">IRasterDataset pRasterDS = pRasterWs.OpenRasterDataset(RasterName);</span><br><span class="line"><span class="comment">//影像金字塔的判断和创建</span></span><br><span class="line">IRasterPyramid pRasterPyramid = pRasterDS <span class="keyword">as</span> IRasterPyramid;</span><br><span class="line"><span class="keyword">if</span> ((pRasterPyramid != <span class="literal">null</span>) &amp;&amp; (!pRasterPyramid.Present))</span><br><span class="line">&#123;</span><br><span class="line">    pRasterPyramid.Create();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//新建栅格图层</span></span><br><span class="line">IRasterLayer pRasterLayer = <span class="keyword">new</span> RasterLayer();</span><br><span class="line">pRasterLayer.CreateFromRaster(pRasterDS.CreateDefaultRaster());</span><br><span class="line">IMap pmap = mapControl.Map;</span><br><span class="line"><span class="comment">//加载显示</span></span><br><span class="line">pmap.AddLayer(pRasterLayer);</span><br><span class="line">mapControl.ActiveView.Refresh();</span><br></pre></td></tr></table></figure><h4 id="4-属性查询-1"><a href="#4-属性查询-1" class="headerlink" title="4. 属性查询"></a>4. 属性查询</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DataTable <span class="title">getFeatureLayerTable</span>(<span class="params">IFeatureLayer pFeatureLayer</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取数据源FeatureClass</span></span><br><span class="line">    IFeatureClass pFeatureClass = pFeatureLayer.FeatureClass;</span><br><span class="line">    DataTable dt = <span class="keyword">new</span> DataTable();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pFeatureClass.Fields.FieldCount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//循环给每一列写字段名</span></span><br><span class="line">    dt.Columns.Add(pFeatureClass.Fields.get_Field(i).Name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取查询返回的游标，null代表没有查询条件，返回整个表</span></span><br><span class="line">    IFeatureCursor pFeatureCursor = pFeatureClass.Search(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//将指针指向第一个要素属性行</span></span><br><span class="line">    IFeature pFeature = pFeatureCursor.NextFeature();</span><br><span class="line">    <span class="keyword">while</span> (pFeature != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//获取表中的新行，并将引用赋值给DataRow</span></span><br><span class="line">        DataRow dataR = dt.Rows.Add();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; pFeatureClass.Fields.FieldCount; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//为每一个属性单元格赋值</span></span><br><span class="line">            <span class="keyword">if</span> (pFeature.get_Value(j) == <span class="literal">null</span>)</span><br><span class="line">                dataR[j] = pFeatureClass.ShapeType.ToString();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dataR[j] = pFeature.get_Value(j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//游标指向下一行要素</span></span><br><span class="line">        pFeature = pFeatureCursor.NextFeature();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-空间查询-1"><a href="#5-空间查询-1" class="headerlink" title="5. 空间查询"></a>5. 空间查询</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">IFeatureLayer pFeatureLayer = pLayer <span class="keyword">as</span> IFeatureLayer;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化一个过滤器，用来设置空间范围的查询条件</span></span><br><span class="line">ISpatialFilter pSpatialFilter = <span class="keyword">new</span> SpatialFilter();</span><br><span class="line">IGeometry geometry = mapControl.TrackRectangle();</span><br><span class="line"><span class="comment">//将几何范围赋值给pSpatialFilter</span></span><br><span class="line">pSpatialFilter.Geometry = geometry;</span><br><span class="line"><span class="comment">//设置空间范围的查询条件</span></span><br><span class="line">pSpatialFilter.SpatialRel = esriSpatialRelEnum.esriSpatialRelIntersects;</span><br><span class="line"><span class="comment">//实例化查询接口</span></span><br><span class="line">IFeatureSelection pfeatureSelection = pFeatureLayer <span class="keyword">as</span> IFeatureSelection;</span><br><span class="line"><span class="comment">//实现高亮</span></span><br><span class="line">pfeatureSelection.SelectFeatures(pSpatialFilter, esriSelectionResultEnum.esriSelectionResultNew, <span class="literal">false</span>);</span><br><span class="line">mapControl.Refresh();<span class="comment">//地图刷新</span></span><br></pre></td></tr></table></figure><h2 id="分值"><a href="#分值" class="headerlink" title="分值"></a>分值</h2><ol><li>填空：1*15</li><li>选择：2*10</li><li>简答：基本概念、总结及功能流程 4*5</li><li>程序阅读：改错、对象模型图 5*3</li><li>程序设计：2*15</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简答&quot;&gt;&lt;a href=&quot;#简答&quot; class=&quot;headerlink&quot; title=&quot;简答&quot;&gt;&lt;/a&gt;简答&lt;/h2&gt;&lt;h4 id=&quot;1-开发模式，开发软件的特点，概念&quot;&gt;&lt;a href=&quot;#1-开发模式，开发软件的特点，概念&quot; class=&quot;headerlink
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>空间数据库总结</title>
    <link href="http://yoursite.com/2020/01/11/%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/01/11/空间数据库总结/</id>
    <published>2020-01-11T06:54:21.990Z</published>
    <updated>2020-01-11T06:56:44.594Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h4 id="1-数据的特点：数据与其语义不可分割"><a href="#1-数据的特点：数据与其语义不可分割" class="headerlink" title="1. 数据的特点：数据与其语义不可分割"></a>1. 数据的特点：数据与其语义不可分割</h4><h4 id="2-数据库的特点："><a href="#2-数据库的特点：" class="headerlink" title="2. 数据库的特点："></a>2. 数据库的特点：</h4><ul><li>数据共享</li><li>数据独立（程序和数据结构之间相互独立）</li><li>减少数据冗余</li><li>避免数据不一致和加强了数据保护</li></ul><h4 id="3-数据库管理系统DBMS的功能："><a href="#3-数据库管理系统DBMS的功能：" class="headerlink" title="3. 数据库管理系统DBMS的功能："></a>3. 数据库管理系统DBMS的功能：</h4><ol><li>数据定义功能：提供数据定义语言(DDL)，对数据库、表、索引的定义</li><li>数据操作功能：提供数据操纵语言(DML)，实现对数据库的基本操作  (查询、插入、删除和修改)</li><li>数据库运行控制功能：并发控制、安全性检查、完整性约束条件的检查和执行、索引的自动建立</li><li>数据库的建立和维护功能：初始数据的输入、转换，数据的存储组织，数据库的转储恢复，性能监视、分析功能等</li></ol><h4 id="4-数据库系统DBS的构成"><a href="#4-数据库系统DBS的构成" class="headerlink" title="4. 数据库系统DBS的构成"></a>4. 数据库系统DBS的构成</h4><ul><li>数据库</li><li>数据库管理系统</li><li>数据库管理员、用户</li><li>应用程序</li></ul><h4 id="5-数据库系统DBS特点"><a href="#5-数据库系统DBS特点" class="headerlink" title="5. 数据库系统DBS特点"></a>5. 数据库系统DBS特点</h4><ul><li>数据结构化</li><li>数据的共享性高，冗余度低，易扩充</li><li>数据独立性高</li><li>数据由DBMS统一管理和控制</li></ul><h4 id="6-数据管理技术"><a href="#6-数据管理技术" class="headerlink" title="6. 数据管理技术"></a>6. 数据管理技术</h4><ul><li>人工管理阶段(20世纪40年代中–50年代中)</li><li>文件系统阶段(20世纪50年代末–60年代中)</li><li>数据库系统阶段(20世纪60年代末–现在)</li></ul><h4 id="7-内部结构：三级模式，两级映像，逻辑独立性和物理独立性"><a href="#7-内部结构：三级模式，两级映像，逻辑独立性和物理独立性" class="headerlink" title="7. 内部结构：三级模式，两级映像，逻辑独立性和物理独立性"></a>7. 内部结构：三级模式，两级映像，逻辑独立性和物理独立性</h4><ul><li><h5 id="三级模式：对数据的三个抽象级别"><a href="#三级模式：对数据的三个抽象级别" class="headerlink" title="三级模式：对数据的三个抽象级别"></a>三级模式：对数据的三个抽象级别</h5><ul><li>模式</li><li>外模式（子模式或用户模式）：介于模式与应用之间。同一个模式可以有任意多个外模式。模式与外模式的关系：一对多，外模式与应用的关系：一对多</li><li>内模式（也称存储模式）：数据物理结构和存储方式的描述。一个数据库只有一个内模式</li></ul></li><li><h5 id="两级映像：在DBMS内部实现这三个抽象层次的联系和转换"><a href="#两级映像：在DBMS内部实现这三个抽象层次的联系和转换" class="headerlink" title="两级映像：在DBMS内部实现这三个抽象层次的联系和转换"></a>两级映像：在DBMS内部实现这三个抽象层次的联系和转换</h5><ul><li>外模式／模式映像：每一个外模式，数据库系统都有一个外模式／模式映象，定义外模式与模式之间的对应关系，保证数据的逻辑独立性</li><li>模式／内模式映像 ：定义了数据全局逻辑结构与存储结构之间的对应关系。模式／内模式映象是唯一的。保证数据的物理独立性</li></ul></li></ul><h4 id="8-数据模型"><a href="#8-数据模型" class="headerlink" title="8. 数据模型"></a>8. 数据模型</h4><ul><li>概念模型：实体－联系法(E-R图法)</li><li>逻辑模型</li><li>物理模型</li></ul><p>三要素：</p><ul><li>数据结构</li><li>数据操作</li><li>完整性约束条件</li></ul><h4 id="9-常用模型"><a href="#9-常用模型" class="headerlink" title="9.  常用模型"></a>9.  常用模型</h4><ul><li>层次（树形结构）</li><li>网状（图）</li><li>关系（二维表)</li></ul><h4 id="10-关系的完整性约束条件"><a href="#10-关系的完整性约束条件" class="headerlink" title="10. 关系的完整性约束条件"></a>10. 关系的完整性约束条件</h4><ul><li>实体完整性</li><li>参照完整性</li><li>用户定义的完整性</li></ul><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h4 id="1-空间数据及特征："><a href="#1-空间数据及特征：" class="headerlink" title="1.  空间数据及特征："></a>1.  空间数据及特征：</h4><blockquote><p> 空间数据：</p><ol><li><p>对空间事物的描述</p></li><li><p>以地球表面空间位置为参照，用来描述空间实体的位置、形状、大小及其分布特征诸多方面信息的数据</p></li><li><p>一种带有空间坐标的数据</p></li><li><p>空间数据获取方式包括人工统计、仪器测量等必然产生误差</p><p>特征：</p></li></ol><ul><li><p>时空特征（空间特征、属性特征、时态特征）</p></li><li><p>多维特征（空间三维与时间维，多维属性信息）</p></li><li><p>多尺度特征（空间多尺度、时间多尺度，空间坐标和空间关系变长结构，非结构化特征）</p></li><li><p>海量数据特征</p><p>空间数据类型（P9）</p></li><li><p>地图数据</p></li><li><p>影像数据</p></li><li><p>地形数据</p></li><li><p>属性数据</p></li></ul></blockquote><h4 id="2-空间数据库SDB的概念和构成"><a href="#2-空间数据库SDB的概念和构成" class="headerlink" title="2. 空间数据库SDB的概念和构成"></a>2. 空间数据库SDB的概念和构成</h4><p>概念：描述与特定空间位置相关的真实世界对象的数据集合</p><p>构成</p><ul><li>空间数据库</li><li>空间数据管理系统</li><li>空间数据库应用程序</li><li>用户</li></ul><h4 id="3-五种空间数据的管理模式"><a href="#3-五种空间数据的管理模式" class="headerlink" title="3.五种空间数据的管理模式"></a>3.五种空间数据的管理模式</h4><blockquote><ol><li>文件管理方式</li><li>二元化空间数据库管理系统</li><li>全关系型空间数据库管理系统</li><li>对象－关系空间数据库管理系统</li><li>面向对象空间数据库管理系统</li></ol></blockquote><h4 id="4-空间信息（概念）模型"><a href="#4-空间信息（概念）模型" class="headerlink" title="4. 空间信息（概念）模型"></a>4. 空间信息（概念）模型</h4><blockquote><ul><li>数据模型：表示空间参考对象也即要将空间实体抽象为数据模型。</li></ul><ul><li>场模型：连续对象的描述（二维，三维），不能够对单独对象进行描述</li><li>对象模型：强调单个对象，把空间对象当做空间要素来表达（点线面体）</li><li>网络模型：网络状对象的描述</li></ul><h5 id="场的组成部分"><a href="#场的组成部分" class="headerlink" title="场的组成部分"></a>场的组成部分</h5><ul><li><p>空间框架：构建了场的定义域</p><ul><li>连续平面：坐标定位</li><li>离散网格：编码定位</li></ul></li><li><p>场函数：属性域</p><ul><li>例子中的森林单一场：空间框架f(x,y)→属性域（冷杉，橡树，松树）</li></ul></li><li><p>场操作</p><ul><li>局部操作</li><li>聚焦操作</li><li>区域操作</li></ul><img src="https://img-blog.csdnimg.cn/20191226144811744.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70" style="zoom:50%;"></li></ul></blockquote><h4 id="5-拓扑操作（几何不变性）、九交矩阵描述"><a href="#5-拓扑操作（几何不变性）、九交矩阵描述" class="headerlink" title="5. 拓扑操作（几何不变性）、九交矩阵描述"></a>5. 拓扑操作（几何不变性）、九交矩阵描述</h4><blockquote><img src="https://img-blog.csdnimg.cn/20191226150029325.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70" style="zoom: 67%;"></blockquote><h2 id="第三章-第四章"><a href="#第三章-第四章" class="headerlink" title="第三章 + 第四章"></a>第三章 + 第四章</h2><h4 id="1-关系模型的三要素-1-8"><a href="#1-关系模型的三要素-1-8" class="headerlink" title="1. 关系模型的三要素 1.8"></a>1. 关系模型的三要素 1.8</h4><ul><li>集合运算：并、交、差、笛卡尔积</li><li>专门的关系运算：选择、投影、连接、除</li><li>五种基本：并、差、笛卡尔积、选择、投影</li></ul><h4 id="2-关系的性质（了解）"><a href="#2-关系的性质（了解）" class="headerlink" title="2. 关系的性质（了解）"></a>2. 关系的性质（了解）</h4><ol><li><p>列是同质的：同一属性名下的诸属性是同类型数据，且必须来自同一个域</p></li><li><p>不同列属性必须有不同属性名</p></li><li><p>列、行的次序无所谓、可以任意交换</p></li><li><p>任意两个元组不能完全相同</p></li><li><p>不允许“表中套表”，即分量必须取原子值，每一个分量必须是不可分的数据项</p></li></ol><h4 id="3-关系代数的写法"><a href="#3-关系代数的写法" class="headerlink" title="3. 关系代数的写法"></a>3. 关系代数的写法</h4><blockquote><p><code>&lt;!-- 写关系代数 --&gt;</code></p></blockquote><h4 id="4-SQL语句的写法"><a href="#4-SQL语句的写法" class="headerlink" title="4. SQL语句的写法"></a>4. SQL语句的写法</h4><blockquote><p><code>&lt;!-- SQL语句 --&gt;</code></p></blockquote><h4 id="5-SQL的特点：非过程化（了解）"><a href="#5-SQL的特点：非过程化（了解）" class="headerlink" title="5. SQL的特点：非过程化（了解）"></a>5. SQL的特点：非过程化（了解）</h4><ol><li>一体化特点。</li><li>高度非过程化。</li><li>语言简洁，易学易用。</li><li>统一的语法结构对待不同的工作方式。</li><li>面向集合的操作方式。</li><li>SQL语言可以对两种基本数据结构进行操作，一种是“表”，另一种是“视图(View)”。</li></ol><h4 id="6-数据定义的命令"><a href="#6-数据定义的命令" class="headerlink" title="6.  数据定义的命令"></a>6.  数据定义的命令</h4><blockquote><ul><li>表<ul><li>create</li><li>Alter ( add, drop, modify修改 )</li><li>drop</li></ul></li><li>视图<ul><li>create</li><li>( update, delete, Insert )</li><li>drop</li></ul></li><li>索引<ul><li>create</li><li>drop</li><li>×</li></ul></li></ul></blockquote><h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><h4 id="1-E-R图-，带象形图的E-R图：将对象插在方框内的微缩图"><a href="#1-E-R图-，带象形图的E-R图：将对象插在方框内的微缩图" class="headerlink" title="1. E-R图 ，带象形图的E-R图：将对象插在方框内的微缩图"></a>1. E-R图 ，带象形图的E-R图：将对象插在方框内的微缩图</h4><img src="https://img-blog.csdnimg.cn/20191226150541297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70" style="zoom:67%;"><h4 id="2-扩展SQL，SQL3和SQL99版本，有了用户自定义类型"><a href="#2-扩展SQL，SQL3和SQL99版本，有了用户自定义类型" class="headerlink" title="2. 扩展SQL，SQL3和SQL99版本，有了用户自定义类型"></a>2. 扩展SQL，SQL3和SQL99版本，有了用户自定义类型</h4><p>对象关系数据库</p><ul><li>关键特性就是支持SQL3/SQL99。</li><li>SQL3中支持用户自定义数据类型。</li><li>空间数据库就是要研究SQL3/SQL99，对标准SQL语言进行扩展，从而操纵和获取空间数据。</li></ul><h4 id="3-OGIS联盟-标准操作：8种-P74-75"><a href="#3-OGIS联盟-标准操作：8种-P74-75" class="headerlink" title="3. OGIS联盟 标准操作：8种 P74-75"></a>3. OGIS联盟 标准操作：8种 P74-75</h4><blockquote><h5 id="拓朴-集合运算："><a href="#拓朴-集合运算：" class="headerlink" title="拓朴/集合运算："></a>拓朴/集合运算：</h5><table><thead><tr><th><strong>Equal</strong></th><th><strong>如果两个几何体完全相同返回真</strong></th></tr></thead><tbody><tr><td><strong>Disjoint</strong></td><td><strong>两个几何体内部和边界都不相交返回真</strong></td></tr><tr><td><strong>Intersect</strong></td><td><strong>两几何体相交则返回真</strong></td></tr><tr><td><strong>Touch</strong></td><td><strong>两几何体边界相交则返回真</strong></td></tr><tr><td><strong>Cross</strong></td><td><strong>如果线和面的内部相交则返回真</strong></td></tr><tr><td><strong>Within</strong></td><td><strong>给定几何内部不和另一几何的外部相交返回真</strong></td></tr><tr><td><strong>Contains</strong></td><td><strong>判断给定几何体是否包含另一几何体</strong></td></tr><tr><td><strong>Overlap</strong></td><td><strong>如果两几何体内部有非空交集返回真</strong></td></tr></tbody></table></blockquote><h4 id="4-创建空间表"><a href="#4-创建空间表" class="headerlink" title="4. 创建空间表"></a>4. 创建空间表</h4><blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; CREATE TABLE Country(</span><br><span class="line">&gt; Name  varchar(35)   Primary key, </span><br><span class="line">&gt; Pop  Integer, </span><br><span class="line">&gt; GDP  double</span><br><span class="line">&gt; Life  FLOAT,</span><br><span class="line">&gt; Shape  Polygon)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h4 id="5-空间查询"><a href="#5-空间查询" class="headerlink" title="5. 空间查询"></a>5. 空间查询</h4><blockquote><p>P76  第五章PPT P52</p></blockquote><h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><h4 id="1-物理、空间模型：实现逻辑模型"><a href="#1-物理、空间模型：实现逻辑模型" class="headerlink" title="1. 物理、空间模型：实现逻辑模型"></a>1. 物理、空间模型：实现逻辑模型</h4><h4 id="2-存储架构"><a href="#2-存储架构" class="headerlink" title="2. 存储架构"></a>2. 存储架构</h4><ul><li>主存（提升性能）——速度很快（纳秒级），但关电源后存储内容丢失</li><li>二级存储设备（存储数据）——速度慢（微秒级），但存储内容不受电源的影响</li><li>三级存储设备（存储备份）——速度更慢，存储内容不受电源影响，往往存储容量非常大。</li></ul><h4 id="3-磁盘物理结构："><a href="#3-磁盘物理结构：" class="headerlink" title="3. 磁盘物理结构："></a>3. 磁盘物理结构：</h4><ul><li>盘片：物理圆形磁片</li><li>磁道：盘片上的同心圆，磁道密度决定容量</li><li>柱面：所有盘片上的直径相同的磁道</li><li>扇区：组成页面（存储）的最小单位，有扇区号</li><li>页面：磁盘和主存间的最小传输单位，一般为扇区的整数倍</li></ul><h4 id="4-存取时间和构成：ts、tt、tl"><a href="#4-存取时间和构成：ts、tt、tl" class="headerlink" title="4. 存取时间和构成：ts、tt、tl"></a>4. 存取时间和构成：ts、tt、tl</h4><blockquote><ul><li>寻道时间：移动磁头到相应磁道上的时间ts</li><li>延迟时间：要读取页面旋转到磁头下的时间tl</li><li>传输时间：磁头读或写相应数据的时间tt</li><li>ts&gt;tl&gt;tt</li><li>tt一般在初始时固定，但ts和tl可能通过优化策略缩短。</li></ul></blockquote><h4 id="5-主存上缓冲区管理器及缓冲策略-DBMS模块：先进先出"><a href="#5-主存上缓冲区管理器及缓冲策略-DBMS模块：先进先出" class="headerlink" title="5. 主存上缓冲区管理器及缓冲策略 DBMS模块：先进先出"></a>5. 主存上缓冲区管理器及缓冲策略 DBMS模块：先进先出</h4><ul><li>缓冲区管理器<ul><li>DBMS的一个软件模块</li><li>负责缓冲区空间分配调度的子系统</li></ul></li><li>缓冲区替换策略<ul><li>最近使用（LRU）<ul><li>替换出最长时间没有读或写过的块</li></ul></li><li>先进先出（FIFO）<ul><li>替换出被同一个块占用时间最长的缓冲块</li></ul></li><li>“时钟”算法<ul><li>LRU的一个常见的、有效的近似</li></ul></li><li>系统控制<ul><li>查询优化器或者其它的DBMS部件可以给缓冲区管理器提供建议来避免象LRU，FIFO，或者时钟这样的严格的策略可能引起的问题</li></ul></li></ul></li></ul><h4 id="6-根据存储容量从小到大采用什么存储策略"><a href="#6-根据存储容量从小到大采用什么存储策略" class="headerlink" title="6. 根据存储容量从小到大采用什么存储策略"></a>6. 根据存储容量从小到大采用什么存储策略</h4><blockquote><p>从小到大</p><ul><li>同一扇区</li><li>相邻扇区 = 同一个磁道</li><li>同一柱面 减少存到时间</li><li>相邻柱面</li></ul></blockquote><h4 id="7-文件结构-PPT-P33"><a href="#7-文件结构-PPT-P33" class="headerlink" title="7. 文件结构 PPT P33"></a>7. 文件结构 PPT P33</h4><ul><li>无序（堆）文件</li><li>顺序文件</li><li>散列文件</li><li>聚类文件（用于空间数据存储）</li></ul><h4 id="8-空间填充曲线（过程）"><a href="#8-空间填充曲线（过程）" class="headerlink" title="8. 空间填充曲线（过程）"></a>8. 空间填充曲线（过程）</h4><blockquote><p><code>&lt;!-- 画图 --&gt;</code></p><ul><li>Z曲线</li><li>hilbert</li></ul></blockquote><h4 id="9-空间数据的组织"><a href="#9-空间数据的组织" class="headerlink" title="9. 空间数据的组织"></a>9. 空间数据的组织</h4><ul><li><p>横向分幅（标准分幅或区域分幅等）</p><ul><li>标准经纬度分块</li><li>矩形分块</li><li>任意区域多边形分块</li></ul><p><code>&lt;!--小比例尺按经纬线分幅，大比例尺地图按矩形分幅。--&gt;</code></p></li><li><p>纵向分层</p><ul><li>专题分层<ul><li>每个图层对应一个专题，包含某一种或某一类数据。如地貌层、水系层、道路层、居民地层等。</li></ul></li><li>时间序列分层<ul><li>把不同时间或不同时期的数据作为多个数据层。</li></ul></li><li>地面垂直高度分层<ul><li>把不同垂直高度的数据作为一个数据层。</li></ul></li></ul></li><li><p>分层分块索引</p></li><li><p>金字塔含义和性质（分辨率变、范围不变、每块不同）</p><ul><li>核心：对遥感影像进行分层、分块<ul><li>分层就是把原始影像数据按照不同分辨率进行管理，具体就是把分辨率高的影像层依次通过重采样算法生成其上层的影像数据。</li><li>分块是对分层之后的影像数据按照设定好的影像块进行分割存储。分块之后只需要将需要显示和处理的若干个影像块数据读入内存，而并非未分块前的一整幅影像。</li><li>最后对每层的影像块（分块大小相等）统一组织存储。</li></ul></li><li>性质：<ul><li>从底层到顶层，分辨率越来越低，但表示的空间范围不变。</li><li>一般采用固定大小（通常取2的幂次方）的分块方法。目前建立影像数据库多采用数据块大小为 128×128或 256×256。</li></ul></li></ul><p><code>&lt;!--影像的尺寸越来越小，但描述的空间范围是不变的，最终分辨率降低。--&gt;</code></p></li></ul><h4 id="10-B-数和B-数-–》R树"><a href="#10-B-数和B-数-–》R树" class="headerlink" title="10. B-数和B+数  –》R树"></a>10. B-数和B+数  –》R树</h4><ul><li><p>B-树是一种平衡的多路查找树，m阶树</p><ol><li>根结点或者是叶子，或者至少有两棵子树，至多有m棵子树</li><li>除根结点外，所有非终端结点至少有m/2棵子树，至多有m棵子树； </li><li>所有叶子结点都在树的同一层上；</li><li>每个结点应包含如下信息：<pre><code>(n，A0，K1，A1，K2，A2，… ，Kn，An)</code></pre>其中Ki(1≤i≤n)是关键字，且Ki&lt;Ki+1 (1≤i≤n-1)；Ai(i=0，1，… ，n)为指向孩子结点的指针，且Ai-1所指向的子树中所有结点的关键字都小于Ki ，Ai所指向的子树中所有结点的关键字都大于Ki ；n是结点中关键字的个数，且（m/2)-1≤n≤m-1，n+1为子树的棵数。</li></ol><table><thead><tr><th align="center">B- 树</th><th>3阶</th><th>4阶</th><th>5阶</th></tr></thead><tbody><tr><td align="center">根结点子树</td><td>2-3</td><td>2-4</td><td>2-5</td></tr><tr><td align="center">根/非终端结点子树</td><td>2-3</td><td>2-4</td><td>3-5</td></tr><tr><td align="center">根/结点中关键字</td><td>1-2</td><td>1-3</td><td>2-4</td></tr><tr><td align="center">根结点中关键字</td><td>1-2</td><td>1-3</td><td>1-4</td></tr></tbody></table></li></ul><ul><li><p>B+树</p><ul><li><p>从最小关键字顺序查找</p></li><li><p>从根结点开始随机查找</p></li></ul><ol><li>每个结点至多有m个子结点； </li><li>除根结点和叶结点外，其它每个结点至少有m/2 个子结点；</li><li>若根结点不是叶子结点，则至少有两个子结点；</li><li>所有的叶结点在同一层；</li></ol><table><thead><tr><th align="center">B+ 树</th><th>3阶</th><th>4阶</th><th>5阶</th></tr></thead><tbody><tr><td align="center">根结点子树</td><td>2-3</td><td>2-4</td><td>2-5</td></tr><tr><td align="center">根/非终端结点子树</td><td>2-3</td><td>2-4</td><td>3-5</td></tr><tr><td align="center">根/结点中关键字</td><td>2-3</td><td>2-4</td><td>3-5</td></tr><tr><td align="center">根结点中关键字</td><td>1-3</td><td>1-4</td><td>1-5</td></tr></tbody></table></li></ul><h4 id="11-什么是空间索引？"><a href="#11-什么是空间索引？" class="headerlink" title="11. 什么是空间索引？"></a>11. 什么是空间索引？</h4><blockquote><p>空间索引：依据空间对象的位置和形状或空间对象之间的空间关系，按一定的顺序排列的一种数据结构。</p><p>基本思想：近似体的使用</p><ul><li><p>常见的空间索引：</p><ul><li><p>对象范围索引（两级过滤）</p><ul><li>初次过滤根据空间要素外包矩形来过滤掉大部分不在查询范围的空间要素；</li><li>第二级过滤则用查询空间范围直接和初次过滤结果集中空间要素的二进制边界坐标比较，从而得到查询的准确结果</li></ul><p><code>&lt;!-- 没有真正的空间索引文件，而是为空间对象添加外接矩形，依靠空间计算能力判别 --&gt;</code></p><p><code>&lt;!-- 查询时仍需要对整个空间对象进行检索，某些对象可以通过矩形范围直接判别 --&gt;</code></p><p><code>&lt;!-- 该方法仍需要花费大量时间进行空间检索，计算机处理速度加快，弥补了效率的要求 --&gt;</code></p></li><li><p>格网索引（固定网格结构，固定网格结构是固定的，它的目录稀疏而巨大）</p><p><code>&lt;!-- 将研究区域用横竖线条划分大小相等或不等的格网，记录每一个格网所包含的空间实体 --&gt;</code></p><p><code>&lt;!-- 空间查询时，首先计算出用户查询对象所在格网，然后在该网格中快速查询所选空间实体 --&gt;</code></p><img src="https://img-blog.csdnimg.cn/20191226174219994.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70" style="zoom:50%;"><ul><li><p>第一阶段（RDBMS完成）：</p><ul><li>接收SQL语句，获取空间过滤器的封装边界</li><li>检测空间过滤器的封装边界跨越的网格</li><li>到空间索引表中检索出封装边界所在网格内的要素</li></ul><img src="https://img-blog.csdnimg.cn/20191226175417164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70" style="zoom:50%;"></li><li><p>第二阶段：几何过滤器的封装边界与第一阶段检索出的要素的边界相比较，找出具有重叠关系的要素</p><img src="https://img-blog.csdnimg.cn/20191226175436550.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70" style="zoom:50%;"></li><li><p>第三阶段：几何过滤器的坐标与第二阶段检索出的要素的边界比较，找出<strong>边界</strong>在几何过滤器内的要素</p><img src="https://img-blog.csdnimg.cn/20191226175558410.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70" style="zoom:50%;"></li><li><p>第四阶段：几何过滤器的坐标与第三阶段检索出的要素的坐标比较，找出最终在几何过滤器内的要素类</p><img src="C:\Users\盒子先生\AppData\Roaming\Typora\typora-user-images\image-20191226175620184.png" alt="image-20191226175620184" style="zoom:50%;"></li></ul></li><li><p>格网索引（网格文件）</p></li><li><p>四叉树索引</p><ul><li>在建立四叉树索引时，根据所有空间对象覆盖的范围，进行四叉树分割，使每个子块中包含单个实体，然后根据包含每个实体的子块层数或子块大小，建立相应的索引。</li></ul><img src="https://img-blog.csdnimg.cn/20191226193222179.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70" style="zoom:50%;"></li></ul></li><li><p>R树索引</p><ul><li>根结点到每一个叶结点的深度相等 。            </li><li>树中每个非叶结点有n到M个子结点，M 对特定的树是固定的(阶数)。2=&lt; n&lt;= M/2</li></ul></li></ul></blockquote><h4 id="12-对象范围索引中有一个检索关系式"><a href="#12-对象范围索引中有一个检索关系式" class="headerlink" title="12.对象范围索引中有一个检索关系式"></a>12.对象范围索引中有一个检索关系式</h4><p>空间对象被检索    <code>Xmax ≥ XW and Xmin≤XE AND Ymax ≥ YS and Ymin≤YN</code></p><p>空间对象不被检索<code>Xmax ≤ XW  OR  Xmin ≥ XE OR Ymax ≤ YS  OR  Ymin ≥YN</code></p><img src="https://img-blog.csdnimg.cn/20191226194319587.png" style="zoom:67%;"><h4 id="13-网格文件索引"><a href="#13-网格文件索引" class="headerlink" title="13. 网格文件索引"></a>13. 网格文件索引</h4><blockquote><p><code>&lt;!-- 画图 --&gt;</code></p><ul><li>根据空间维度划分k维空间。</li><li>将平面索引空间划分为相等或不等的一些小方格网。</li><li>与每个格网相关联的空间目标存储到同一磁盘页面（桶）或多个磁盘页面（溢出桶）。</li><li>页面的访问地址通过格网的线性标量（数组下标）求得。</li><li>线性标量是空间目标实际坐标按照线型比例生成的索引。</li></ul><p><img src="https://img-blog.csdnimg.cn/20191226175935417.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70" style="zoom:33%;"><img src="https://img-blog.csdnimg.cn/20191226175949699.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70" style="zoom:33%;"></p></blockquote><h4 id="14-R树特征-10-12条"><a href="#14-R树特征-10-12条" class="headerlink" title="14. R树特征(10-12条)"></a>14. R树特征(10-12条)</h4><blockquote><ol><li>每个叶结点包含m至M条索引记录(其中m&lt;=M/2 )</li><li>一个叶结点上的每条索引记录了最小外包矩形。</li><li>每个非叶结点都有m至M个子结点。</li><li>对于非叶结点中的每个条目包含其子结点中矩形的最小外包矩形。</li><li>根结点至少有两子结点。</li><li>所有叶结点出现在同一层。</li><li>所有MBR的边与一个全局坐标系的轴平行。</li></ol><ul><li>R树允许结点相互覆盖,这种交叠可以使R树保持较高的空间利用率和保持树的平衡。</li><li>过多交叠可能会造成查询效率的降低,最坏的情况下对某一对象的查询可能造成对整个树的搜索。</li><li>R树搜索的性能取决于两个参数：覆盖和交叠。<ul><li>树的某一层覆盖是指这一层所有节点的MBR所覆盖的全部区域。</li></ul></li><li>若想要得到一个高效的R树，覆盖和交叠都应该很小。</li></ul></blockquote><h4 id="15-最优R树画法"><a href="#15-最优R树画法" class="headerlink" title="15. 最优R树画法"></a>15. 最优R树画法</h4><blockquote><p><code>&lt;!-- 画图 --&gt;</code></p></blockquote><h2 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h2><h4 id="1-策略"><a href="#1-策略" class="headerlink" title="1. 策略"></a>1. 策略</h4><blockquote><ul><li>选择运算尽可能先做</li><li>投影运算和选择运算同时进行</li><li>把投影运算同其前后的双目运算结合执行</li><li>执行连接运算前，进行适当的预处理</li><li>选择运算和笛卡尔积运算结合成连接运算</li><li>找出公共子表达式，避免重复运算</li></ul></blockquote><h4 id="2-空间操作的两步处理：过滤步骤、精炼步骤"><a href="#2-空间操作的两步处理：过滤步骤、精炼步骤" class="headerlink" title="2. 空间操作的两步处理：过滤步骤、精炼步骤"></a>2. 空间操作的两步处理：过滤步骤、精炼步骤</h4><h2 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h2><ol><li>数据库系统的特点是<code>数据共享</code>、数据独立、减少数据冗余、避免数据不一致和加强了数据保护。</li><li>数据库管理系统（DBMS）是<code>系统软件</code></li><li>数据库管理系统能实现对数据库中数据的查询、插入、修改和删除等操作．这种功能称为<code>数据操纵功能</code></li><li>在数据库的三级模式结构中，描述数据库中全体数据的全局逻辑结构和特征的是<code>模式</code></li><li>数据库系统的数据独立性是指<code>不会因为数据的变化而影响应用程序</code></li><li>数据库类型是按照<code>数据模型</code>来划分的</li><li>一组具有相同数据类型的值的集合称为<code>域</code></li><li>在数据库中存储的是<code>数据以及数据之间的联系</code></li><li>按所使用的数据模型来分，数据库可分为<code>层次、关系和网状</code>三种模型</li><li>在数据库设计中用关系模型来表示实体和实体之间的联系。关系模型的结构是<code>二维表结构</code></li><li>在关系模型中，实现”关系中不允许出现相同的元组”的约束是通过<code>主键</code></li><li><code>关系模型</code>由数据结构、关系操作集合和完整性约束三部分组成</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第一章&quot;&gt;&lt;a href=&quot;#第一章&quot; class=&quot;headerlink&quot; title=&quot;第一章&quot;&gt;&lt;/a&gt;第一章&lt;/h2&gt;&lt;h4 id=&quot;1-数据的特点：数据与其语义不可分割&quot;&gt;&lt;a href=&quot;#1-数据的特点：数据与其语义不可分割&quot; class=&quot;head
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>GPS测量原理及应用 知识总结</title>
    <link href="http://yoursite.com/2020/01/11/GPS%E6%B5%8B%E9%87%8F%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%20%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/01/11/GPS测量原理及应用 知识总结/</id>
    <published>2020-01-11T06:51:17.647Z</published>
    <updated>2020-01-11T06:56:52.689Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h4 id="1-北斗的优势及应用-（至少三点）"><a href="#1-北斗的优势及应用-（至少三点）" class="headerlink" title="1. 北斗的优势及应用 （至少三点）"></a>1. 北斗的优势及应用 （至少三点）</h4><ul><li><p>优势</p><ol><li><p>三频定位，卫星定位精度更高。</p><p>通过三个不同频率的信号可以有效消除定位的时候产生的误差，并且多个频率的信号可以在某一个频率信号出现问题的时候改用其他信号，提高定位系统的可靠性和抗干扰能力</p></li><li><p>短报互文功能</p></li><li><p>安全、方便</p></li></ol></li><li><p>应用</p><ol><li><strong>气象应用</strong>： 北斗系统在卫星气象方面的应用，可以提升中国天气分析和数值天气预报、气候变化监测和预测的水平，也可以提高空间天气预警业务水平，提升中国气象防灾减灾能力。</li><li><strong>铁路智能交通</strong>：北斗卫星导航系统将可提供高可靠、高精度的定位、测速、授时服务。</li><li><strong>应急救援：</strong> 全海域出海渔船加装北斗系统装备，利用北斗特有的短报互文通信功能及时回传海上遇险搜救信息，成为海上渔民保障安全的重要工具。</li><li><strong>居家智慧养老项目</strong>：利用“互联网+北斗定位+社区服务组织+医疗机构+居家养老智能服务终端”，构建智能化医、养、服务结合的居家养老实施体系，</li><li><strong>北斗+纪检</strong> ：实时查询目标车辆的精确位置和历史轨迹，对公车实行动态监管。</li></ol></li></ul><h4 id="2-GPS系统的组成、地面监控、GPS接收机任务"><a href="#2-GPS系统的组成、地面监控、GPS接收机任务" class="headerlink" title="2. GPS系统的组成、地面监控、GPS接收机任务"></a>2. GPS系统的组成、地面监控、GPS接收机任务</h4><ol><li><h5 id="系统组成"><a href="#系统组成" class="headerlink" title="系统组成"></a>系统组成</h5><ul><li><p><strong>空间部分——GPS卫星星座</strong></p><p>作用：</p><p>​                1. 用两个无限载波向用户连续发送导航定位信号</p><pre><code>2. 接收导航电文及其他信息，适时的发送给广大用户3. 接收地面主控站通过注入站发送到卫星的调度命令，实时的改正运行偏差或启用备用时钟等。</code></pre></li><li><p><strong>地面控制部分——地面监控系统</strong></p><ul><li><p>一个主控站。</p><p>美国本土科罗拉多。收集、处理本站和监测站收到的全部资料 ，编算出每颗卫星的星历和GPS时间系统，将预测的卫星星历、钟差、状态数据以及大气传播改正编制成导航电文传送到注入站。</p></li><li><p>三个注入站</p><p>将主控站发来的导航电文注入到相应卫星的存储器。</p></li><li><p>五个监测站</p><p>为主控站提供卫星的观测数据</p></li></ul></li><li><p><strong>用户设备部分——GPS信号接收机</strong></p><ul><li><p>捕获按一定卫星高度截止角所选择的待测卫星的信号，并跟踪卫星运行</p></li><li><p>对所接收到的GPS信号进行变换、放大和处理</p></li><li><p>测量出信号传播的时间，解译出GPS卫星所发送的导航电文</p></li><li><p>实时计算出测站的三维信息，甚至三位速度和时间。</p></li></ul></li></ul></li><li><h5 id="系统特点"><a href="#系统特点" class="headerlink" title="系统特点"></a>系统特点</h5><ol><li>定位精度高：50km以内可达10-6 </li><li>观测时间短： 20km以内的相对静态定位，仅需15~20 分钟</li><li>测站间无需通视：只需测站上空开阔。</li><li>可提供三维坐标、时间、速度：经典大地测量将平面与高程分别施测，GPS可同时测定点的三维坐标。</li><li>操作简便</li><li>全天候作业：24小时行。</li><li>功能多、应用广</li></ol></li></ol><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h4 id="1-天球坐标系和地球坐标系是用来干什么的？"><a href="#1-天球坐标系和地球坐标系是用来干什么的？" class="headerlink" title="1. 天球坐标系和地球坐标系是用来干什么的？"></a>1. 天球坐标系和地球坐标系是用来干什么的？</h4><ul><li><p><strong>天球坐标系</strong>:描述卫星的运行位置和状态。该坐标系与地球自转无关。</p><ul><li>原点—地球质心M</li><li>Z轴—指向天球北极Pn</li><li>X轴—指向春分点</li><li>Y轴—垂直于XMZ平面，与X轴Z轴构成右手坐标系统。</li></ul><img src="https://img-blog.csdnimg.cn/20191220205809534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70" style="zoom:50%;"></li><li><p><strong>地球坐标系</strong>:描述地面观测站的位置，该坐标系随同地球自转。通常采用<strong>空间直角坐标系</strong>进行坐标转换。</p><ul><li>原点O：地球质心</li><li>Z轴：指向地球北极Pn</li><li>X轴：指格林尼治子午面与地球赤道的交点E</li><li>Y轴：垂直于XOZ平面，与X轴和Y轴构成右手坐标系。</li></ul><img src="https://img-blog.csdnimg.cn/20191220205725464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70" style="zoom:50%;"></li><li><p>为什么选用空间直角坐标系？</p><pre><code>任一点的空间位置可由该点在三个坐标面的投影（X，Y，Z）唯一地确定，通过坐标平移、旋转和尺度转换，可以将一个点的位置方便的从一个坐标系转换至另一个坐标系。</code></pre><p>  与某一空间直角坐标系所相应的大地坐标系（B，L，H），只是坐标表现形式不同，实质上是完全等价的，两者之间可相互转化。</p></li></ul><h4 id="2-怎么定义坐标系？"><a href="#2-怎么定义坐标系？" class="headerlink" title="2. 怎么定义坐标系？"></a>2. 怎么定义坐标系？</h4><ol><li>坐标原点的位置。</li><li>三个坐标轴的指向。</li><li>长度单位</li></ol><h4 id="3-坐标系统之间的转换"><a href="#3-坐标系统之间的转换" class="headerlink" title="3. 坐标系统之间的转换"></a>3. 坐标系统之间的转换</h4><p>七参数</p><ul><li><p>同一基准</p><ol><li>空间直角坐标系与空间大地坐标系间的转换。</li><li>空间坐标系与平面直角坐标系间的转换。</li></ol></li><li><p>不同基准</p><ol><li>不同坐标系之间的转换实质上就是不同基准间的转换，常用布尔萨七参数转换方法。</li><li>布尔萨七参数：即3个平移参数，3个旋转参数，1个尺度参数。</li></ol></li></ul><p><strong>GPS坐标与我国北京54（西安80）坐标的转换流程图</strong>：</p><img src="https://img-blog.csdnimg.cn/20191220204424881.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:50%;"><h4 id="4-时间系统-判断"><a href="#4-时间系统-判断" class="headerlink" title="4. 时间系统   判断"></a>4. 时间系统   判断</h4><ol><li><h5 id="时间："><a href="#时间：" class="headerlink" title="时间："></a>时间：</h5><ul><li>时刻：发生某一现象的瞬间.</li><li>时间段：发生某一现象所经历的过程，是这一过程始末的时刻之差。</li></ul></li><li><h5 id="时间基准"><a href="#时间基准" class="headerlink" title="时间基准"></a>时间基准</h5><ul><li><p>时间原点（时刻）</p></li><li><p>时间尺度（时间段）</p></li></ul></li><li><h5 id="GPS定位对时间系统的要求"><a href="#GPS定位对时间系统的要求" class="headerlink" title="GPS定位对时间系统的要求"></a>GPS定位对时间系统的要求</h5><p>全球统一的时间原点和高精度的时间尺度。</p><p>原因：</p><ol><li>时间度量的精度就意味着空间位置的精度。</li><li>GPS定位是通过测定电磁波信号的传播时间来测定站星距离的。</li></ol></li></ol><h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><h4 id="1-卫星的无赦运动，确定开普勒轨道方程，要知道参数"><a href="#1-卫星的无赦运动，确定开普勒轨道方程，要知道参数" class="headerlink" title="1. 卫星的无赦运动，确定开普勒轨道方程，要知道参数"></a>1. 卫星的无赦运动，确定开普勒轨道方程，要知道参数</h4><ol><li><h5 id="无赦运动：地球质心引力（中心引力）"><a href="#无赦运动：地球质心引力（中心引力）" class="headerlink" title="无赦运动：地球质心引力（中心引力）"></a>无赦运动：地球质心引力（中心引力）</h5><ol><li>第一定律：卫星运动的轨道是一个椭圆，而该椭圆的一个焦点与地球质心重合。</li><li>第二定律：卫星到地心的距离在相等的时间内所扫过的面积相等。</li><li>第三定律：卫星运行周期的平方，与轨道椭圆长半径的立方之比为一常量。</li></ol><ul><li>理想轨道</li><li>中心引力</li><li>二体问题：将地球和卫星视为两个质点，仅考虑地球质心引力<pre><code>研究卫星运动规律</code></pre></li></ul></li><li><h5 id="受摄运动：地球非对称性引力"><a href="#受摄运动：地球非对称性引力" class="headerlink" title="受摄运动：地球非对称性引力"></a>受摄运动：地球非对称性引力</h5><ul><li>日月引力；</li><li>大气阻力；</li><li>光辐射压力</li></ul></li><li><p>摄动力</p><ul><li>地球非中心引力Fm；</li><li>太阳引力Fs和月球引力Fn；</li><li>太阳光的直接与间接辐射压力Fr；</li><li>大气阻力Fa；</li><li>地球潮汐作用力；</li><li>磁力及其他作用力</li></ul></li><li><p>开普勒运动</p></li><li><p>轨道六参数</p><ul><li><p>卫星轨道面与赤道面的相对位置</p><ul><li><p>升交点赤经Ω ：升交点和赤道面春分点的夹角</p></li><li><p>近地点角距 ：轨道平面近地点和升交点的夹角</p></li><li><p>轨道倾角 ：轨道面和赤道面的夹角</p></li><li><p>卫星过近地点时刻 </p></li></ul></li><li><p>卫星轨道的形状</p><ul><li><p>卫星轨道长半轴</p></li><li><p>卫星轨道扁率</p><img src="https://img-blog.csdnimg.cn/20190415120749522.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70" style="zoom:67%;"></li></ul></li></ul></li></ol><h4 id="2-GPS卫星星历"><a href="#2-GPS卫星星历" class="headerlink" title="2. GPS卫星星历"></a>2. GPS卫星星历</h4><p>描述卫星某一时刻运动轨道的信息</p><ol><li><h5 id="预报星历（广播星历）"><a href="#预报星历（广播星历）" class="headerlink" title="预报星历（广播星历）"></a>预报星历（广播星历）</h5><ol><li><p>定义：通过卫星发射到用户接收机的含有轨道信息的导航电文信号</p></li><li><p>内容：共计17个星历参数。</p></li><li><p>特点：</p><ul><li><p>每2个小时更新一次，</p></li><li><p>外推的时间间隔不超过1小时</p></li><li><p>预报星历的精度一般约为20-40m</p></li><li><p>注入站—-将卫星星历、卫星钟差等参数和各种控制命令发送到GPS卫星。</p></li></ul></li><li><p>预报星历的编制和传送过程：</p><img src="https://img-blog.csdnimg.cn/20191220210903616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70" style="zoom:55%;"></li></ol></li><li><h5 id="后处理星历（精密星历）"><a href="#后处理星历（精密星历）" class="headerlink" title="后处理星历（精密星历）"></a>后处理星历（精密星历）</h5><ol><li><p>定义：根据地面跟踪站的精密观测资料计算而得到的，不包含外推误差的实测星历。</p></li><li><p>优点： 轨道参数非常准确，也称精密星历。</p></li><li><p>缺点：不能做到实时。</p></li><li><p>后处理星历的编制和传送过程：</p><img src="https://img-blog.csdnimg.cn/20191220211242293.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70" style="zoom:55%;"></li></ol></li></ol><h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><h4 id="1-GPS卫星的导航电文"><a href="#1-GPS卫星的导航电文" class="headerlink" title="1. GPS卫星的导航电文"></a>1. GPS卫星的导航电文</h4><p>​    用户用来定位和导航的数据基础。</p><ol><li>遥测码：位于各子帧的开头，表明卫星注入数据的状态。</li><li>转换码：位于每个子帧的第二个字码，提供帮助用户从所捕获C/A码转换到捕获P码的时间计数（Z）。</li><li>第一数据块：位于第一子帧的第3 ~10字码。<ul><li>卫星时钟改正——以地面主控站的原子钟为基准</li><li>电离层时延改正</li><li>星期序号WN—— GPS周期数</li><li>数据龄期AODC</li><li>卫星的健康状况</li></ul></li><li>第二数据块：包含第2和第3子帧，其内容表示GPS 卫星的星历。</li><li>第三数据块：包含第4和第5子帧，内容包括了所有GPS 卫星的历书数据。可帮助用户选择工作正常的定位卫星。</li></ol><h4 id="2-GPS信号图，信号怎么产生的，为什么要两个载波，消除有什么影响，C-A码，P码"><a href="#2-GPS信号图，信号怎么产生的，为什么要两个载波，消除有什么影响，C-A码，P码" class="headerlink" title="2. GPS信号图，信号怎么产生的，为什么要两个载波，消除有什么影响，C/A码，P码"></a>2. GPS信号图，信号怎么产生的，为什么要两个载波，消除有什么影响，C/A码，P码</h4><ol><li><p>GPS信号</p><ul><li>运载工具（载波L1、L2）</li><li>测距码（C/A码、P码） </li><li>导航电文（数据码、D码） </li></ul></li><li><p>信号图</p><img src="https://img-blog.csdnimg.cn/20191220212217231.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70" style="zoom:50%;"></li><li><p>两个载波</p><p>测量出或消除掉由于电离层效应而引起的延迟误差 </p></li><li><p>消除有什么影响？</p></li></ol><ol start="5"><li><p>粗码C/A码</p><ul><li>码长：1023位</li><li>周期：1ms</li><li>测距误差：3~30m</li><li>特点：<ul><li>由于C/A码的码长较短，易于捕获，而通过捕获C/A码所得到的信息，又可以方便的捕获到P码，称C/A码为捕获码。</li><li>C/A码的码元宽度较大，测距误差可达 3~30m。由于其精度较低，所以，称C/A码为粗捕获码。</li><li>由于C/A码单点定位精度较低，测量上采用非单点定位，即相对定位（差分定位）。</li></ul></li></ul></li><li><p>精码P码</p><ul><li>码长：6.19*1012 bit</li><li>周期：七天</li><li>测距误差：0.3~3m</li><li>特点：<ul><li>码元宽度较小，精度较高，专为军用。</li><li>目前，只有极少数接收机才能接收P码，且价格昂贵。</li></ul></li></ul></li></ol><h4 id="3-接收机的基本工作原理"><a href="#3-接收机的基本工作原理" class="headerlink" title="3. 接收机的基本工作原理"></a>3. 接收机的基本工作原理</h4><img src="https://img-blog.csdnimg.cn/20191220213027275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70" style="zoom:50%;"><ol><li><h5 id="接收天线："><a href="#接收天线：" class="headerlink" title="接收天线："></a>接收天线：</h5><p>将GPS信号的极危若的电磁波能转化为相应的电流</p></li><li><h5 id="前置放大器："><a href="#前置放大器：" class="headerlink" title="前置放大器："></a>前置放大器：</h5><p>将GPS信号电流予以放大。为便于接收机对信号进行跟踪、处理和两侧。</p></li><li><h5 id="接收机主机"><a href="#接收机主机" class="headerlink" title="接收机主机"></a>接收机主机</h5><ol><li><p>变频器及中频放大器</p><p>经过GPS前置放大器的信号仍然很微弱，为了使接收机通道得到稳定的高增益，并使L频段的射频信号变为低频信号。采用变频器</p></li><li><p>信号通道</p><ol><li>搜索卫星，牵引并跟踪卫星</li><li>对广播电文数据信号实行解扩，解调出广播电文</li><li>进行伪距测量、载波相位测量及多普勒频移测量</li></ol></li></ol></li><li><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul><li>当GPS卫星在用户世界升起时，接收机能够捕获到按一定卫星高度截止角所选择的待测卫星，并能够跟踪这些卫星的运行；</li><li>对所接收到的GPS信号，具有变换，放大和处理的功能，</li><li>以便测量出GPS信号从卫星到接收天线的传播时间，</li><li>解译出GPS卫星所发送的导航电文，</li><li>实时的计算出测站的三维位置，甚至三维速度和时间。</li><li>GPS信号接收机不仅需要功能较为强大的机内软件，而且需要一个多功能的GPS数据测后处理软件包。</li><li>接收机加处理软件包，才是完整的GPS信号用户设备。</li></ul></li></ol><h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><h4 id="1-GPS卫星定位的基本原理，分类，四种"><a href="#1-GPS卫星定位的基本原理，分类，四种" class="headerlink" title="1. GPS卫星定位的基本原理，分类，四种"></a>1. GPS卫星定位的基本原理，分类，四种</h4><ol><li><h5 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h5><ul><li>运用空间距离前方交会的方法求出卫星的位置。</li><li>运用空间距离后方交会的方法求测站点的位置。</li><li>观测值：距离</li><li>用距离交会的方法求解P点的三维坐标（X，Y，Z）的观测方程：<img src="https://img-blog.csdnimg.cn/20191221092334772.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70" style="zoom:67%;"></li></ul></li><li><h5 id="实质："><a href="#实质：" class="headerlink" title="实质："></a>实质：</h5><p>​        由GPS接收机在某一时刻，同时接收四颗以上的GPS卫星信号，测量出GPS接收机到GPS卫星的距离，根据空间距离后方交会的方法求测站点的位置。</p></li><li><h5 id="GPS定位方法及分类"><a href="#GPS定位方法及分类" class="headerlink" title="GPS定位方法及分类"></a>GPS定位方法及分类</h5><ul><li><p>按采用观测值</p><ul><li><p>伪距定位</p></li><li><p>载波相位定位</p></li></ul></li><li><p>按获取结果的时间</p><ul><li>实时定位</li><li>事后定位</li></ul></li><li><p>按测站的运动状态</p><ul><li>静态定位</li><li>动态定位</li></ul></li><li><p>按接收机的数量</p><ul><li>绝对定位（单点定位）</li><li>相对定位（差分定位）</li></ul></li></ul></li></ol><h4 id="2-什么是伪距测量？原理是什么，方程（详细）方程各部分的意义"><a href="#2-什么是伪距测量？原理是什么，方程（详细）方程各部分的意义" class="headerlink" title="2. 什么是伪距测量？原理是什么，方程（详细）方程各部分的意义"></a>2. 什么是伪距测量？原理是什么，方程（详细）方程各部分的意义</h4><ol><li><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><ul><li>伪距法定位：由GPS接收机在某一时刻测出四颗以上的GPS卫星的伪距以及已知的卫星位置，采用空间距离后方交会的方法求定天线所在点的三维坐标。</li><li>伪距：由卫星发射的测距码信号到达GPS接收机的传播时间乘以光速所得出的量测距离。而不是卫星与GPS接收机的几何距离。</li></ul></li><li><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><img src="https://img-blog.csdnimg.cn/20191221093105390.png" style="zoom:50%;"><p>时间 <code>t</code> 的测定：</p><ul><li>卫星 — 测距码，经时间<img src="https://img-blog.csdnimg.cn/20191221093315922.png" style="zoom:50%;">到达接收机。</li><li>接收机 — 复制码</li><li>时延器 — 延迟复制码，经延迟时间     使两码对齐，<img src="https://img-blog.csdnimg.cn/20191221093237113.png" style="zoom: 50%;">。</li></ul><p>使<img src="https://img-blog.csdnimg.cn/20191221093442857.png" style="zoom: 60%;">实际上是不可能的，只能使<img src="https://img-blog.csdnimg.cn/20191221093512925.png" style="zoom:60%;">，两种码不可能完全对齐，导致时间有误差。</p></li><li><h5 id="伪距测量方程"><a href="#伪距测量方程" class="headerlink" title="伪距测量方程"></a>伪距测量方程</h5><img src="https://img-blog.csdnimg.cn/20191221093650927.png" style="zoom:50%;"><ul><li><img src="https://img-blog.csdnimg.cn/20191221093727451.png" style="zoom: 67%;">为伪距测量值</li><li><img src="https://img-blog.csdnimg.cn/20191221093749964.png" style="zoom: 67%;">为卫星至接收机几何距离</li><li><code>T</code>为测距码的周期</li><li><img src="https://img-blog.csdnimg.cn/20191221093818530.png" style="zoom: 67%;">为周长</li><li><img src="https://img-blog.csdnimg.cn/20191221093900308.png" style="zoom:67%;">为测距模糊度</li></ul><p>如果已知待测距离小于测距码的波长，则n=0</p></li><li><h5 id="伪距定位观测方程"><a href="#伪距定位观测方程" class="headerlink" title="伪距定位观测方程"></a>伪距定位观测方程</h5><img src="https://img-blog.csdnimg.cn/20191221094354676.png" style="zoom:50%;"><ul><li>优点：定位速度快，无多值性。</li><li>缺点：定位精度低，P码的测距精度0.3m，C/A码  的测距精度3m左右 。</li></ul></li></ol><h4 id="3-载波相位测量的原理，方程"><a href="#3-载波相位测量的原理，方程" class="headerlink" title="3. 载波相位测量的原理，方程"></a>3. 载波相位测量的原理，方程</h4><ol><li>原理</li></ol><img src="https://img-blog.csdnimg.cn/20191221094637739.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70" style="zoom:50%;"><img src="https://img-blog.csdnimg.cn/20191221094829617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70" style="zoom:50%;"><img src="https://img-blog.csdnimg.cn/20191221094907806.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70" style="zoom:50%;"><ol start="2"><li>方程</li></ol><img src="https://img-blog.csdnimg.cn/20191221095224670.png" style="zoom:50%;"><h4 id="4-整周跳变原因，修复方法"><a href="#4-整周跳变原因，修复方法" class="headerlink" title="4. 整周跳变原因，修复方法"></a>4. 整周跳变原因，修复方法</h4><ol><li>定义<ul><li>在载波相位测量中，若接收机保持对卫星信号的连续跟踪，则整周未知数保持不变，整周计数也保持连续.</li><li>但当接收机无法保持对卫星信号连续跟踪时，在卫星信号重新被锁定后，整周未知数将发生变化，整周计数也将不再与前面的值保持连续而发生部分丢失现象.</li><li>不足一周的的相位观测值仍是正确的</li></ul></li><li>原因<ol><li>信号被其它物体遮拦；</li><li>大功率电磁场干扰；</li><li>电源中断，或接收机故障（无法修复周跳，需重新观测）</li></ol></li><li>修复方法<ol><li>屏幕扫描法</li><li>多项式拟合法</li><li>在卫星间求差</li><li>双频观测值修复周跳</li><li>根据平差后的残差修复周跳</li></ol></li></ol><h4 id="5-绝对定位，相对定位"><a href="#5-绝对定位，相对定位" class="headerlink" title="5. 绝对定位，相对定位"></a>5. 绝对定位，相对定位</h4><ol><li><p>绝对定位</p><p>​    接收机天线处于静止状态下，确定观测站坐标的方法称为静态绝对定位。</p></li></ol><p>   这时，可以连续地在不同历元同步观测不同的卫星，测定卫星至观测站的伪距，获得充分的多余观测量。测后通过数据处理求得观测站的绝对坐标。</p><ol start="2"><li><p>相对定位</p><p>至少用两台GPS接收机，同步观测相同的GPS卫星，确定两台接收机天线之间的相对位置（坐标差）。</p><ul><li>特点<ul><li>优点：定位精度高</li><li>缺点：<ul><li>多台接收共同作业</li><li>数据处理复杂</li><li>不能直接获取绝对坐标</li></ul></li></ul></li><li>应用<ul><li>高精度测量定位及导航</li></ul></li></ul></li></ol><h4 id="6-一次两次三次差分定位"><a href="#6-一次两次三次差分定位" class="headerlink" title="6. 一次两次三次差分定位"></a>6. 一次两次三次差分定位</h4><ol><li><p>单差观测（一次差）——在接收机间求差</p><blockquote><p>为什么要进行单差观测？<br> 不同接收机观测同一颗卫星，在不同接收机间求一次差，可消除信号传播的误差（对流层、电离层等的误差），采用单差观测的目的就是要减少误差的影响提高定位结果的精度。<br>优点：①可消除卫星钟差的影响；</p><pre><code>②削弱星历误差的影响；③可削弱电离层和对流层的影响。</code></pre></blockquote></li><li><p>双差观测（二次差）——在卫星间求差</p><p>可以消除接收机间钟差的影响。</p></li><li><h5 id="三次差—在星历间求差（两个历元的星历间求差）"><a href="#三次差—在星历间求差（两个历元的星历间求差）" class="headerlink" title="三次差—在星历间求差（两个历元的星历间求差）"></a>三次差—在星历间求差（两个历元的星历间求差）</h5><p>可消除的影响（过程中由于不准造成的影响）</p></li><li><p>差分定位</p><p>差分GPS定位技术是将一台GPS接收机安置在基准站上进行观测。根据基准站已知精密坐标，计算出基准站到卫星的距离改正数，并由基准站实时地将这一改正数发送出去。用户接收机在进行GPS观测的同时，也接收到基准站的改正数，并对其定位结果进行改正，从而提高定位精度。</p></li></ol><p>   差分GPS可分为:</p><ul><li>单基准站差分<ul><li>位置差分</li><li>伪距差分</li><li>载波相位差分</li></ul></li><li>具有多个基准站的局部区域差分</li><li>广域差分</li></ul><blockquote><p> GPS定位中，存在着三部分误差：</p><ol><li><p>一是多台接收机公有的误差，如：卫星钟误差、星历误差；</p></li><li><p>二是传播延迟误差，如：电离层误差、对流层误差；</p></li><li><p>三是接收机固有的误差，如：内部噪声、通道延迟、多路径效应。</p></li></ol><pre><code>采用差分定位，可完全消除第一部分误差，可大部分消除第二部分误差（视基准站至用户的距离）。</code></pre></blockquote><h2 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h2><h4 id="1-GPS测量的误差来源及消除方法"><a href="#1-GPS测量的误差来源及消除方法" class="headerlink" title="1. GPS测量的误差来源及消除方法"></a>1. GPS测量的误差来源及消除方法</h4><ol><li><p>GPS卫星: 对距离测量的影响：1.5 ~ 15m</p><ol><li><p>星历误差：星历包含17个参数，参数本身存在误差。</p><p>​    消除:</p><ul><li>建立自己的卫星跟踪网；</li><li>轨道松弛法——六个轨道参数的近似值作为已知值，将改正数作为参数进行平差处理。</li><li>同步观测求差——利用两个或多个观测站，对同一卫星的同步观测值求差。</li></ul></li><li><p>钟误差：调制波以一定的频率形成信号，信号本身存在误差；利用调制码求时间，存在误差。</p><p>​    消除:</p><ul><li>加钟差改正模型</li><li>同步观测求差——在接收机间求一次差，可消除卫星钟差和改正后的残余误差。</li></ul></li><li><h6 id="相对论效应：对震荡频率产生影响，会对时间、空间距离产生影响。"><a href="#相对论效应：对震荡频率产生影响，会对时间、空间距离产生影响。" class="headerlink" title="相对论效应：对震荡频率产生影响，会对时间、空间距离产生影响。"></a>相对论效应：对震荡频率产生影响，会对时间、空间距离产生影响。</h6><p>​    消除:</p><ul><li>在制造卫星钟时预先把频率降低为 <img src="https://img-blog.csdnimg.cn/20191221111542834.png" style="zoom:50%;"></li></ul></li></ol></li><li><p>卫星信号的传播过程: 对距离测量的影响：1.5 ~ 15m</p><ol><li><p>电离层：信号在传播时会发生折射。</p><p>​    消除:</p><ul><li>利用电离层改正模型加以修正（模型法）</li><li>利用双频观测</li><li>同步观测求差。</li></ul></li><li><p>对流层：信号在传播时会发生折射。</p><p>​    消除:</p><ul><li>采用对流层模型加以改正；</li><li>引入待估参数；</li><li>同步观测求差。</li></ul></li><li><p>多路径效应：测站周围的反射物所反射的信号进入接收机天 线，与直接来自卫星的信号产生干涉。</p><p>​    消除:</p><ul><li>选择合适的站址；</li><li>对接收机天线的要求；</li><li>同步观测求差。</li></ul></li></ol><blockquote><p>不论是对流层或电离层与高度角都有很大的关系， 正上方影响最小，地平方向最大。高度角越大越好。</p></blockquote></li><li><p>地面接收设备: 对距离测量的影响：1.5 ~ 5m</p><ol><li><p>接收机钟差：接收机钟与卫星钟不同步。</p><p>​    消除:</p><ul><li>作为未知数，一并求解；</li><li>在卫星间求一次差；</li><li>加时钟改正模型。</li></ul></li><li><p>位置误差：对中、整平、水准器校正不好等。</p><p>​    消除:</p><ul><li>校正仪器、仔细安置仪器、强制归心。</li></ul></li><li><p>天线相位中心：天线的几何中心与电磁场相位中心不重合，类似经纬仪度盘的偏心差。</p><p>​    消除:</p><ul><li>同步观测求差。</li><li>所有天线安置时方向要一致，指向标均指向北方向。 </li></ul></li></ol></li><li><p>其他影响</p><ol><li>地球潮汐：海潮，固体潮</li><li>负荷潮：与地球的内部质量分布不均匀有关，与地球的引力有关。对距离测量的影响：1.0m</li></ol></li></ol><h2 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h2><h4 id="1-GPS测量的设计依据，基准设计"><a href="#1-GPS测量的设计依据，基准设计" class="headerlink" title="1. GPS测量的设计依据，基准设计"></a>1. GPS测量的设计依据，基准设计</h4><ol><li>设计依据<ol><li>GPS测量规范：主要指国家、城市以及行业标准。</li><li>测量任务书：布网的设计既要符合有关标准又要满足任务要求。</li></ol></li><li>基准设计<ol><li>位置基准：由给定的起算点确定</li><li>方位基准：由给定边的起算方位角确定 </li><li>尺度基准：测距仪测定的基线边、GPS基线边或<pre><code>两个起算点间的距离确定</code></pre></li></ol></li></ol><h4 id="2-GPS网构成的几个基本概念及网特征条件"><a href="#2-GPS网构成的几个基本概念及网特征条件" class="headerlink" title="2. GPS网构成的几个基本概念及网特征条件"></a>2. GPS网构成的几个基本概念及网特征条件</h4><ol><li><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><ol><li>观测时段：测站上开始接收卫星信号到观测停止，连续工作的时间段。</li><li>同步观测：两台或两台以上接收机同时对同一组卫星进行的观测。</li><li>同步观测环：三台或三台以上接收机同步观测获得的基线向量所构成的闭合环。</li><li>独立观测环：由独立观测所获得的基线向量所构成的闭合环。</li><li>异步观测环：在构成多边形环路的所有基线向量中，只要有非同步观测基线向量，则该多边形环路叫异步观测环。</li><li>独立基线：对于N台GPS接收机构成的同步观测环，有J条同步观测基线，其中独立基线数为  N-1。</li><li>非独立基线：除独立基线外的其他基线，总基线数与独立基线数之差即为非独立基线数。</li></ol></li><li><h5 id="GPS网特征条件的计算"><a href="#GPS网特征条件的计算" class="headerlink" title="GPS网特征条件的计算"></a>GPS网特征条件的计算</h5><ol><li>全网观测时段数</li><li>总基线数</li><li>必要基线数</li><li>独立基线数</li><li>多余基线数</li></ol></li></ol><h4 id="3-GPS网特征条件的计算"><a href="#3-GPS网特征条件的计算" class="headerlink" title="3. GPS网特征条件的计算"></a>3. GPS网特征条件的计算</h4><img src="https://img-blog.csdnimg.cn/20191221112552661.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70" style="zoom: 40%;"><h4 id="4-GPS外野实施，怎么选点，观测，不能做什么"><a href="#4-GPS外野实施，怎么选点，观测，不能做什么" class="headerlink" title="4. GPS外野实施，怎么选点，观测，不能做什么"></a>4. GPS外野实施，怎么选点，观测，不能做什么</h4><ol><li><h5 id="选点"><a href="#选点" class="headerlink" title="选点"></a>选点</h5><ol><li>点位应安置在视野开阔，易安装仪器的地方；</li><li>点位目标明显，视场周围15°以上没有障碍物的地方；</li><li>点位应远离大功率无线电用电器大于200m；远离高压电线，不小50m；</li><li>点位附近无大面积水域，无强烈信号干扰，以免造成信号衰减； </li><li>点位应选在交通便利、有利于其它观测手段扩展和联测；</li><li>地面基础稳定易于点的保存；</li><li>图形应有利于同步观测边、点联测；</li><li>利用旧点时应对旧点的稳定性、完好性和站标的安全性进行检查； </li></ol></li><li><h5 id="观测过程中不允许进行以下操作："><a href="#观测过程中不允许进行以下操作：" class="headerlink" title="观测过程中不允许进行以下操作："></a>观测过程中不允许进行以下操作：</h5><p>​      a)接收机关闭又重新启动；<br>​      b)进行自测试；<br>​      c)改变卫星仰角；<br>​      d)改变数据采样间隔；<br>​      e)改变天线位置；<br>​      f)按动关闭文件和删除文件等功能键。</p></li></ol><h4 id="5-RTK的测量原理，基准站，移动站什么时候发送数据"><a href="#5-RTK的测量原理，基准站，移动站什么时候发送数据" class="headerlink" title="5. RTK的测量原理，基准站，移动站什么时候发送数据"></a>5. RTK的测量原理，基准站，移动站什么时候发送数据</h4><ol><li><h5 id="测量原理"><a href="#测量原理" class="headerlink" title="测量原理"></a>测量原理</h5><ul><li><p>在基准站上安置一台GPS接收机，对所有可见GPS卫星进行连续的观测，并将其观测数据，通过无线电传输设备，实时的发送给用户观测站。</p></li><li><p>在用户站上，GPS接收机在接收GPS卫星信号的同时，通过无线电接收设备，接收基准站传输的观测数据，然后根据相对定位的原理，实时的计算并显示用户站的三维坐标及其精度。</p></li></ul></li></ol><h2 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h2><h4 id="1-GPS测量数据处理过程，原理，方法"><a href="#1-GPS测量数据处理过程，原理，方法" class="headerlink" title="1. GPS测量数据处理过程，原理，方法"></a>1. GPS测量数据处理过程，原理，方法</h4><ol><li><p>过程</p><img src="https://img-blog.csdnimg.cn/20191221113401548.png" style="zoom: 67%;"></li><li><p>数据采集： GPS接收机至卫星的伪距、载波相位和卫星星历等数据。</p></li><li><p>GPS数据处理：从原始的观测值出发得到最终的测量定位成果。</p></li><li><p>基线解算：</p><ol><li>原始观测数据的读入</li><li>外业输入数据的检查与修改</li><li>设置基线解算的控制参数</li><li>基线解算</li><li>基线解算质量的检核</li><li>结束</li></ol></li></ol><h4 id="2-GPS高程：之间的差异"><a href="#2-GPS高程：之间的差异" class="headerlink" title="2. GPS高程：之间的差异"></a>2. GPS高程：之间的差异</h4><ol><li>大地水准面和正高（正高系统）: 以大地水准面为基准面的高程系统。</li><li>似大地水准面和正常高（正常高系统）: 以似大地水准面为基准面的高程系统。</li><li>参考椭球面和大地高（大地高系统）: 以参考椭球面为基准面的高程系统</li></ol><h4 id="3-高程计算方法：3个"><a href="#3-高程计算方法：3个" class="headerlink" title="3. 高程计算方法：3个"></a>3. 高程计算方法：3个</h4><ol><li><p>绘等直线图法—— 几何内插法</p><ol><li><p>测区内有m个点，大地高均已知；</p></li><li><p>选n个点进行水准测量，得其正常高；</p></li><li><p>计算n个点的高程异常：</p></li><li><p>依据各点的坐标按一定比例将点展绘在图纸上，并在n个点旁标注出其高程异常值。</p></li><li><p>选取高程异常等高距（1～5cm），绘等值线图。</p></li><li><p>利用内插法求出其余m-n个点的高程异常值。</p><p>注：n个点选取时要覆盖整个测区。</p></li></ol></li><li><p>多项式曲线拟合法</p><ol><li>在测线上有m个点，经GPS测量得其大地高；</li><li>在m个点中n个点，用水准测量方法测得其正常高。</li><li>计算n个点的高程异常：<img src="https://img-blog.csdnimg.cn/2019122113562624.png" style="zoom: 67%;"></li><li>找出<img src="https://img-blog.csdnimg.cn/20191221135651297.png" style="zoom:67%;">与x（或y）的函数关系：<br><img src="https://img-blog.csdnimg.cn/20191221135705575.png" style="zoom:67%;">  或  <img src="https://img-blog.csdnimg.cn/20191221135722455.png" style="zoom:67%;"><br>可用多项式表示：<img src="https://img-blog.csdnimg.cn/20191221135804350.png" style="zoom:67%;"><pre><code>当工程为带状时利用绘等直线法就不是很方便了，拟合的好坏与点的个数和点的位置有关。</code></pre></li></ol></li><li><p>多项式曲面拟合法</p><ol><li><p>在测区上有m个点，经GPS测量得其大地高；</p></li><li><p>在m个点中n个点，用水准测量方法测得其正常高。</p></li><li><p>计算n个点的高程异常：<img src="https://img-blog.csdnimg.cn/20191221140043244.png" style="zoom:67%;"></p></li><li><p>找出<img src="https://img-blog.csdnimg.cn/20191221135651297.png" style="zoom:67%;"> 与点的坐标（ x，y）的函数关系：<img src="https://img-blog.csdnimg.cn/2019122114012482.png" style="zoom:67%;"></p><p>可用多项式表示：<img src="https://img-blog.csdnimg.cn/20191221140215631.png" style="zoom:67%;"></p><pre><code>拟合的点在测区内应分布均匀。</code></pre></li></ol></li></ol><h2 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h2><h4 id="2-GPS功能"><a href="#2-GPS功能" class="headerlink" title="2. GPS功能"></a>2. GPS功能</h4><p>定位，导航，授时</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第一章&quot;&gt;&lt;a href=&quot;#第一章&quot; class=&quot;headerlink&quot; title=&quot;第一章&quot;&gt;&lt;/a&gt;第一章&lt;/h2&gt;&lt;h4 id=&quot;1-北斗的优势及应用-（至少三点）&quot;&gt;&lt;a href=&quot;#1-北斗的优势及应用-（至少三点）&quot; class=&quot;header
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>github/码云操作---合并分支，推送</title>
    <link href="http://yoursite.com/2020/01/11/github%E7%A0%81%E4%BA%91%E6%93%8D%E4%BD%9C---%E5%90%88%E5%B9%B6%E5%88%86%E6%94%AF%EF%BC%8C%E6%8E%A8%E9%80%81/"/>
    <id>http://yoursite.com/2020/01/11/github码云操作---合并分支，推送/</id>
    <published>2020-01-11T06:45:57.948Z</published>
    <updated>2020-01-11T12:23:29.237Z</updated>
    
    <content type="html"><![CDATA[<h3 id="将login分支中的代码提交到本地仓库，合并到master分支推送到远端"><a href="#将login分支中的代码提交到本地仓库，合并到master分支推送到远端" class="headerlink" title="将login分支中的代码提交到本地仓库，合并到master分支推送到远端"></a>将login分支中的代码提交到本地仓库，合并到master分支推送到远端</h3><ol><li><code>git status</code>:查看当前项目中源代码的状态</li><li><code>git add .</code>:将修改后文件和新增文件添加到暂存区</li><li><code>git commit -m &quot;提交的文本说明信息&quot;</code>:提交暂存区代码到本地仓库</li><li><code>git branch</code>:查看分支</li><li><code>git checkout -b login</code>:新建一个<code>user</code>分支，并切换到这个分支，执行后，当前处于该分支，当前所有的修改也切换到了这个分支中</li><li><code>git push -u origin lohin</code>:将本地的login分支推动到云端origin仓储里的login分支（远端没有此分支，该分支的第一次推送）</li><li><code>git checkout master</code>:切换分支到master</li><li><code>git merge login</code>:合并分支</li><li><code>git push</code>:推送</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;将login分支中的代码提交到本地仓库，合并到master分支推送到远端&quot;&gt;&lt;a href=&quot;#将login分支中的代码提交到本地仓库，合并到master分支推送到远端&quot; class=&quot;headerlink&quot; title=&quot;将login分支中的代码提交到本地仓库，
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>IDEA连接Mysql数据库没有jar包报错</title>
    <link href="http://yoursite.com/2020/01/11/IDEA%E8%BF%9E%E6%8E%A5Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%B2%A1%E6%9C%89jar%E5%8C%85%EF%BC%8C%E6%8A%A5%E9%94%99/"/>
    <id>http://yoursite.com/2020/01/11/IDEA连接Mysql数据库没有jar包，报错/</id>
    <published>2020-01-11T06:44:57.955Z</published>
    <updated>2020-01-11T07:01:53.274Z</updated>
    
    <content type="html"><![CDATA[<p> IDEA连接Mysql数据库没有jar包，报错java.lang.ClassNotFoundException: com.mysql.jdbc.Driver</p><h2 id="问题1：IDEA连接Mysql数据库没有jar包"><a href="#问题1：IDEA连接Mysql数据库没有jar包" class="headerlink" title="问题1：IDEA连接Mysql数据库没有jar包"></a>问题1：IDEA连接Mysql数据库没有jar包</h2><p><img src="https://img-blog.csdnimg.cn/20191219161132869.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20191219161212890.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70" alt></p><p><img src="https://img-blog.csdnimg.cn/20191219161226180.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191219161421818.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20191219161518136.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191219161525239.png" alt="在这里插入图片描述"></p><h5 id="这两个地方都有了，搞定！"><a href="#这两个地方都有了，搞定！" class="headerlink" title="这两个地方都有了，搞定！"></a>这两个地方都有了，搞定！</h5><h2 id="问题2：报错java-lang-ClassNotFoundException-com-mysql-jdbc-Driver"><a href="#问题2：报错java-lang-ClassNotFoundException-com-mysql-jdbc-Driver" class="headerlink" title="问题2：报错java.lang.ClassNotFoundException: com.mysql.jdbc.Driver"></a>问题2：报错java.lang.ClassNotFoundException: com.mysql.jdbc.Driver</h2><p><img src="https://img-blog.csdnimg.cn/2019121916164333.png" alt="在这里插入图片描述"></p><h5 id="按层次修改存放的路径，搞定！！！"><a href="#按层次修改存放的路径，搞定！！！" class="headerlink" title="按层次修改存放的路径，搞定！！！"></a>按层次修改存放的路径，搞定！！！</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; IDEA连接Mysql数据库没有jar包，报错java.lang.ClassNotFoundException: com.mysql.jdbc.Driver&lt;/p&gt;
&lt;h2 id=&quot;问题1：IDEA连接Mysql数据库没有jar包&quot;&gt;&lt;a href=&quot;#问题1：IDEA连
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Vue工程化</title>
    <link href="http://yoursite.com/2019/12/07/Vue%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%8E%AF%E5%A2%83(%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%84%E8%8C%83%E3%80%81webpack%E3%80%81%E5%8D%95%E6%96%87%E4%BB%B6%E7%BB%84%E4%BB%B6%E3%80%81%E8%84%9A%E6%89%8B%E6%9E%B6%E3%80%81Element-UI)/"/>
    <id>http://yoursite.com/2019/12/07/Vue工程化环境(模块化规范、webpack、单文件组件、脚手架、Element-UI)/</id>
    <published>2019-12-07T13:24:24.461Z</published>
    <updated>2020-01-11T06:50:30.404Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1，模块化相关规范"><a href="#1，模块化相关规范" class="headerlink" title="1，模块化相关规范"></a>1，模块化相关规范</h2><h3 id="1-浏览器端模块化规范"><a href="#1-浏览器端模块化规范" class="headerlink" title="1. 浏览器端模块化规范"></a>1. 浏览器端模块化规范</h3><h4 id="1-1-AMD"><a href="#1-1-AMD" class="headerlink" title="1.1 AMD"></a><strong>1.1 <code>AMD</code></strong></h4><p>Require.js (<a href="http://www.requirejs.cn/" target="_blank" rel="noopener">http://www.requirejs.cn/</a>)</p><h4 id="1-2-CMD"><a href="#1-2-CMD" class="headerlink" title="1.2 CMD"></a><strong>1.2 <code>CMD</code></strong></h4><p>Sea.js (<a href="https://seajs.github.io/seajs/docs/" target="_blank" rel="noopener">https://seajs.github.io/seajs/docs/</a>)</p><h3 id="2-服务器端模块化规范"><a href="#2-服务器端模块化规范" class="headerlink" title="2. 服务器端模块化规范"></a>2. 服务器端模块化规范</h3><h4 id="2-1-CommonJS"><a href="#2-1-CommonJS" class="headerlink" title="2.1 CommonJS"></a>2.1 <strong><code>CommonJS</code></strong></h4><ol><li>分为 单文件模块、包 </li><li>导出：<code>module.exports</code>和<code>exports</code></li><li>导入：<code>require(&#39;标识符&#39;)</code></li></ol><h3 id="3-ES6模块化"><a href="#3-ES6模块化" class="headerlink" title="3. ES6模块化"></a><strong>3. <code>ES6</code>模块化</strong></h3><ol><li>每个 js 文件都是一个独立的模块</li><li>导入使用<code>import</code>关键字</li><li>暴露使用 <code>export</code> 关键字</li><li>每个模块中，只允许使用唯一的一次 <code>export default</code>，可以多次使用<code>export</code></li></ol><p><code>ES6</code>中的导入、暴露等高级语法，浏览器不能识别，需要讲<code>ES6</code>语法转为浏览器能够识别的<code>ES5</code>语法，可以通过babel，webpack等</p><h4 id="4-babel"><a href="#4-babel" class="headerlink" title="4.  babel"></a>4.  <strong><code>babel</code></strong></h4><ol><li><p><code>npm install --save-dev @babel/core @babel/cli @babel/preset-env @babel/node</code></p></li><li><p><code>npm install --save @babel/polyfill</code></p></li><li><p>项目跟目录创建文件 <code>babel.config</code></p></li><li><p>在 <code>babel.config</code>中添加下面代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> presets = [</span><br><span class="line">    [<span class="string">"@babel/env"</span>, &#123;</span><br><span class="line">         targets: &#123;</span><br><span class="line">             edge: <span class="string">"17"</span>,</span><br><span class="line">             firefox: <span class="string">"60"</span>,</span><br><span class="line">             chrome: <span class="string">"67"</span>,</span><br><span class="line">             safari: <span class="string">"11.1"</span></span><br><span class="line">         &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">];</span><br><span class="line"><span class="built_in">module</span>.exports = &#123; presets &#125;;</span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li>通过 <code>npx babel-node index.js</code> 执行代码</li></ol><h2 id="2，webpack"><a href="#2，webpack" class="headerlink" title="2，webpack"></a>2，webpack</h2><h4 id="1-安装配置"><a href="#1-安装配置" class="headerlink" title="1. 安装配置"></a>1. 安装配置</h4><ol><li><p>运行 <code>npm install webpack webpack-cli –D</code> 命令，安装 <code>webpack</code> 相关的包</p></li><li><p>项目根目录中，创建名为<code>webpack.config.js</code></p></li><li><p>在 <code>webpack.config.js</code>中添加代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">mode: <span class="string">'development'</span> <span class="comment">// mode 用来指定构建模式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 <code>package.json</code> 配置文件中的 <code>scripts</code> 节点下，新增 <code>dev</code> 脚本：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line"><span class="string">"dev"</span>: <span class="string">"webpack"</span> <span class="comment">// script 节点下的脚本，可以通过 npm run 执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li>运行 <code>npm run dev</code> 命令，启动 <code>webpack</code> 进行项目打包。</li></ol><h4 id="2-基本使用"><a href="#2-基本使用" class="headerlink" title="2. 基本使用"></a>2. 基本使用</h4><h5 id="2-1-配置打包"><a href="#2-1-配置打包" class="headerlink" title="2.1 配置打包"></a>2.1 配置打包</h5><ol><li><p>入口文件 <code>src -&gt; index.js</code></p></li><li><p>输出文件  <code>dist -&gt; main.js</code></p></li><li><p>修改，以在 <code>webpack.config.js</code> 中新增配置信息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>) <span class="comment">// 导入 node.js 中专门操作路径的模块</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"> entry: path.join(__dirname, <span class="string">'./src/index.js'</span>), <span class="comment">// 打包入口文件的路径</span></span><br><span class="line"> output: &#123;</span><br><span class="line"> path: path.join(__dirname, <span class="string">'./dist'</span>), <span class="comment">// 输出文件的存放路径</span></span><br><span class="line"> filename: <span class="string">'bundle.js'</span> <span class="comment">// 输出文件的名称</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="2-2-自动打包"><a href="#2-2-自动打包" class="headerlink" title="2.2 自动打包"></a>2.2 自动打包</h5><ol><li><p>运行 <code>npm install webpack-dev-server –D</code> 命令，安装支持项目自动打包的工具</p></li><li><p>修改 <code>package.json -&gt; scripts</code> 中的 <code>dev</code> 命令：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line"> <span class="string">"dev"</span>: <span class="string">"webpack-dev-server"</span> <span class="comment">// script 节点下的脚本，可以通过 npm run 执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>将 <code>src -&gt; index.html</code> 中，<code>script</code> 脚本的引用路径，修改为 <code>&quot;/buldle.js“</code></p></li><li><p>运行 <code>npm run dev</code> 命令，重新进行打包</p></li><li><p>在浏览器中访问 <code>http://localhost:8080</code> 地址，查看自动打包效果</p></li><li><p><code>webpack-dev-server</code> 会启动一个实时打包的 <code>http</code> 服务器</p></li><li><p><code>webpack-dev-server</code> 打包生成的输出文件，默认放到了项目根目录中，而且是虚拟的、看不见的</p></li><li><p>相关参数，设置端口</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package.json中的配置</span></span><br><span class="line"><span class="comment">// --open 打包完成后自动打开浏览器页面</span></span><br><span class="line"><span class="comment">// --host 配置 IP 地址</span></span><br><span class="line"><span class="comment">// --port 配置端口</span></span><br><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line"><span class="string">"dev"</span>: <span class="string">"webpack-dev-server --open --host 127.0.0.1 --port 8888"</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li></ol><h5 id="2-2-预览页面"><a href="#2-2-预览页面" class="headerlink" title="2.2 预览页面"></a>2.2 <strong>预览页面</strong></h5><ol><li><p>运行 npm install html-webpack-plugin –D 命令，安装生成预览页面的插件</p></li><li><p>修改 webpack.config.js 文件头部区域，添加配置信息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入生成预览页面的插件，得到一个构造函数</span></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> htmlPlugin = <span class="keyword">new</span> HtmlWebpackPlugin(&#123; <span class="comment">// 创建插件的实例对象</span></span><br><span class="line"> template: <span class="string">'./src/index.html'</span>, <span class="comment">// 指定要用到的模板文件</span></span><br><span class="line"> filename: <span class="string">'index.html'</span> <span class="comment">// 指定生成的文件的名称，该文件存在于内存中，在目录中不显示</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>修改 webpack.config.js 文件中向外暴露的配置对象，新增配置节点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"> plugins: [ htmlPlugin ] <span class="comment">// plugins 数组是 webpack 打包期间会用到的一些插件列表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="3-加载器"><a href="#3-加载器" class="headerlink" title="3. 加载器"></a>3. 加载器</h4><h5 id="1-css-文件"><a href="#1-css-文件" class="headerlink" title="1.  css 文件"></a>1.  css 文件</h5><ol><li><p>运行 <code>npm i style-loader css-loader -D</code> 命令，安装处理 <code>css</code> 文件的 `loader</p></li><li><p>在 <code>webpack.config.js 的 module -&gt; rules</code> 数组中，添加 <code>loader</code> 规则：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有第三方文件模块的匹配规则</span></span><br><span class="line"> <span class="built_in">module</span>: &#123;</span><br><span class="line">     rules: [</span><br><span class="line">     &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">use</span>: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>] &#125;</span><br><span class="line">     ]</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p><code>test</code> 表示匹配的文件类型， <code>use</code> 表示对应要调用的 <code>loader</code></p></li><li><p><code>use</code> 数组中指定的 <code>loader</code> 顺序是固定的</p></li><li><p>多个 <code>loader</code> 的调用顺序是：从后往前调用</p></li></ol><h5 id="2-less文件"><a href="#2-less文件" class="headerlink" title="2. less文件"></a>2. less文件</h5><ol><li><p>运行 <code>npm i less-loader less -D</code></p></li><li><p>在 <code>webpack.config.js 的 module -&gt; rules</code> 数组中，添加 <code>loader</code> 规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 所有第三方文件模块的匹配规则</span><br><span class="line"> module: &#123;</span><br><span class="line">     rules: [</span><br><span class="line">     &#123; test: /\.less$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;less-loader&apos;] &#125;</span><br><span class="line">     ]</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="3-scss文件"><a href="#3-scss文件" class="headerlink" title="3. scss文件"></a>3. scss文件</h5><ol><li><p>运行 npm i sass-loader node-sass -D 命令</p></li><li><p>在 webpack.config.js 的 module -&gt; rules 数组中，添加 loader 规则</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有第三方文件模块的匹配规则</span></span><br><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">    &#123; <span class="attr">test</span>: <span class="regexp">/\.scss$/</span>, <span class="attr">use</span>: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'sass-loader'</span>] &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="4-配置-postCSS-自动添加-css-的兼容前缀"><a href="#4-配置-postCSS-自动添加-css-的兼容前缀" class="headerlink" title="4. 配置 postCSS 自动添加 css 的兼容前缀"></a>4. 配置 postCSS 自动添加 css 的兼容前缀</h5><ol><li><p>运行 <code>npm i postcss-loader autoprefixer -D</code> 命令</p></li><li><p>在项目根目录中创建 <code>postcss</code> 的配置文件 <code>postcss.config.js</code>，并初始化如下配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> autoprefixer = <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>) <span class="comment">// 导入自动添加前缀的插件</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">plugins: [ autoprefixer ] <span class="comment">// 挂载插件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>在 <code>webpack.config.js</code> 的 <code>module -&gt; rules</code> 数组中，修改 <code>css</code> 的 <code>loader</code> 规则：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">     rules: [</span><br><span class="line">        &#123; <span class="attr">test</span>:<span class="regexp">/\.css$/</span>, <span class="attr">use</span>: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'postcss-loader'</span>] &#125;</span><br><span class="line">     ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="5-打包样式表中的图片和字体文件"><a href="#5-打包样式表中的图片和字体文件" class="headerlink" title="5. 打包样式表中的图片和字体文件"></a>5. 打包样式表中的图片和字体文件</h5><ol><li><p>运行 <code>npm i url-loader file-loader -D</code> 命令</p></li><li><p>在 <code>webpack.config.js</code> 的 <code>module -&gt; rules</code> 数组中，添加 <code>loader</code> 规则如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line"> rules: [</span><br><span class="line">     &#123; </span><br><span class="line">         test: <span class="regexp">/\.jpg|png|gif|bmp|ttf|eot|svg|woff|woff2$/</span>, </span><br><span class="line">         use: <span class="string">'url-loader?limit=16940'</span></span><br><span class="line">     &#125;</span><br><span class="line"> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>其中 <code>?</code>之后的是 <code>loader</code> 的参数项。</p></li><li><p><code>limit</code> 用来指定图片的大小，单位是字节<code>(byte)</code>,只有小于 <code>limit</code> 大小的图片，才会被转为 <code>base64</code> 图片</p></li></ol><h5 id="5-打包处理-js-文件中的高级语法-类等"><a href="#5-打包处理-js-文件中的高级语法-类等" class="headerlink" title="5. 打包处理 js 文件中的高级语法(类等)"></a>5. 打包处理 js 文件中的高级语法(类等)</h5><ol><li><p>安装<code>babel</code>转换器相关的包：<code>npm i babel-loader @babel/core @babel/runtime -D</code> </p></li><li><p>安装<code>babel</code>语法插件相关的包：<code>npm i @babel/preset-env @babel/plugin-transformruntime @babel/plugin-proposal-class-properties –D</code></p></li><li><p>在项目根目录中，创建 <code>babel</code>配置文件 <code>babel.config.js</code> 并初始化基本配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"> presets: [ <span class="string">'@babel/preset-env'</span> ],</span><br><span class="line"> plugins: [ <span class="string">'@babel/plugin-transform-runtime'</span>, <span class="string">'@babel/plugin-proposalclass-properties’ ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>在 <code>webpack.config.js</code> 的 <code>module -&gt; rules</code> 数组中，添加 <code>loader</code> 规则：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// exclude 为排除项，表示 babel-loader 不需要处理 node_modules 中的 js 文件</span></span><br><span class="line"> &#123; <span class="attr">test</span>: <span class="regexp">/\.js$/</span>, <span class="attr">use</span>: <span class="string">'babel-loader'</span>, <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span> &#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="3，Vue-单文件组件"><a href="#3，Vue-单文件组件" class="headerlink" title="3，Vue 单文件组件"></a>3，<code>Vue</code> 单文件组件</h2><h4 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1 .  基本使用"></a>1 .  基本使用</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line"> &lt;!-- 这里用于定义Vue组件的模板内容 --&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp"> /</span><span class="regexp">/ 这里用于定义Vue组件的业务逻辑</span></span><br><span class="line"><span class="regexp"> export default &#123;</span></span><br><span class="line"><span class="regexp"> data: () &#123; return &#123;&#125; &#125;, /</span><span class="regexp">/ 私有数据</span></span><br><span class="line"><span class="regexp"> methods: &#123;&#125; /</span><span class="regexp">/ 处理函数</span></span><br><span class="line"><span class="regexp"> /</span><span class="regexp">/ ... 其它业务逻辑</span></span><br><span class="line"><span class="regexp"> &#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line"> <span class="comment">/* 这里用于定义组件的样式 */</span></span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-ebpack-中配置-vue-组件的加载器"><a href="#2-ebpack-中配置-vue-组件的加载器" class="headerlink" title="2. ebpack 中配置 vue 组件的加载器"></a>2. <code>ebpack</code> 中配置 <code>vue</code> 组件的加载器</h4><ol><li><p>运行 <code>npm i vue-loader vue-template-compiler -D</code> 命令</p></li><li><p>在 <code>webpack.config.js</code> 配置文件中，添加 <code>vue-loader</code> 配置项：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> VueLoaderPlugin = <span class="built_in">require</span>(<span class="string">'vue-loader/lib/plugin'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"> <span class="built_in">module</span>: &#123;</span><br><span class="line"> rules: [</span><br><span class="line"> <span class="comment">// ... 其它规则</span></span><br><span class="line"> &#123; <span class="attr">test</span>: <span class="regexp">/\.vue$/</span>, <span class="attr">loader</span>: <span class="string">'vue-loader'</span> &#125;</span><br><span class="line"> ]</span><br><span class="line"> &#125;,</span><br><span class="line"> plugins: [</span><br><span class="line"> <span class="comment">// ... 其它插件</span></span><br><span class="line"> <span class="keyword">new</span> VueLoaderPlugin() <span class="comment">// 请确保引入这个插件！</span></span><br><span class="line"> ] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="3-在-webpack-项目中使用-vue"><a href="#3-在-webpack-项目中使用-vue" class="headerlink" title="3. 在 webpack 项目中使用 vue"></a>3. 在 <code>webpack</code> 项目中使用 <code>vue</code></h4><ol><li><p>运行 <code>npm i vue –S</code> 安装<code>vue</code></p></li><li><p>在 <code>src -&gt; index.js</code> 入口文件中，通过 <code>import Vue from &#39;vue&#39;</code> 来导入 <code>vue</code> 构造函数</p></li><li><p>创建 <code>vue</code> 的实例对象，并指定要控制的 <code>el</code> 区域</p></li><li><p>通过 <code>render</code> 函数渲染 <code>App</code> 根组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 导入 Vue 构造函数</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="comment">// 2. 导入 App 根组件</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./components/App.vue'</span></span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line"> <span class="comment">// 3. 指定 vm 实例要控制的页面区域</span></span><br><span class="line"> el: <span class="string">'#app'</span>,</span><br><span class="line"> <span class="comment">// 4. 通过 render 函数，把指定的组件渲染到 el 区域中</span></span><br><span class="line"> render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h4 id="4-webpack-打包发布"><a href="#4-webpack-打包发布" class="headerlink" title="4.  webpack 打包发布"></a>4.  webpack 打包发布</h4><p>通过 <code>package.json</code> 文件配置打包命令</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在package.json文件中配置 webpack 打包命令</span></span><br><span class="line"><span class="comment">// 该命令默认加载项目根目录中的 webpack.config.js 配置文件</span></span><br><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="comment">// 用于打包的命令</span></span><br><span class="line">    <span class="string">"build"</span>: <span class="string">"webpack -p"</span>,</span><br><span class="line">    <span class="comment">// 用于开发调试的命令</span></span><br><span class="line">    <span class="string">"dev"</span>: <span class="string">"webpack-dev-server --open --host 127.0.0.1 --port 3000"</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="4，Vue-脚手架"><a href="#4，Vue-脚手架" class="headerlink" title="4，Vue 脚手架"></a>4，Vue 脚手架</h2><h4 id="1-安装、基本用法、项目结构"><a href="#1-安装、基本用法、项目结构" class="headerlink" title="1. 安装、基本用法、项目结构"></a>1. 安装、基本用法、项目结构</h4><ol><li><p>安装3.x版本的Vue脚手架</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @vue/cli</span><br></pre></td></tr></table></figure></li><li><p>使用</p><ul><li>交互式命令行 <code>vue create my-project</code></li><li>图形化界面<code>vue ui</code></li></ul></li><li><p>项目结构</p><ul><li><code>public</code>静态资源目录</li><li><code>src</code>组件源码目录</li><li><code>babel.config.js</code>Babel配置文件</li></ul></li></ol><h4 id="2-自定义配置"><a href="#2-自定义配置" class="headerlink" title="2. 自定义配置"></a>2. 自定义配置</h4><ol><li><p>单独的配置文件 <code>vue.config.js</code>,能够覆盖默认配置，结果必须是Json格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// vue.config.js</span><br><span class="line"> module.exports = &#123;</span><br><span class="line">     devServer: &#123;</span><br><span class="line">     port: 8888</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="5，Element-UI-的基本使用"><a href="#5，Element-UI-的基本使用" class="headerlink" title="5，Element-UI 的基本使用"></a>5，Element-UI 的基本使用</h2><p>官网地址为： <a href="http://element-cn.eleme.io/#/zh-CN" target="_blank" rel="noopener">http://element-cn.eleme.io/#/zh-CN</a></p><h4 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h4><ol><li><p>终端安装依赖包 <code>npm i element-ui –S</code> </p></li><li><p>图形化界面安装<code>vue ui -&gt; Vue项目管理器 -&gt; 插件 -&gt; 添加插件 -&gt; 搜索’vue-cli-plugin-element’安装</code></p></li><li><p>导入 <code>Element-UI</code> 相关资源</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入组件库</span></span><br><span class="line"><span class="keyword">import</span> ElementUI <span class="keyword">from</span> <span class="string">'element-ui'</span>;</span><br><span class="line"><span class="comment">// 导入组件相关样式</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'element-ui/lib/theme-chalk/index.css'</span>;</span><br><span class="line"><span class="comment">// 配置 Vue 插件</span></span><br><span class="line">Vue.use(ElementUI);</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1，模块化相关规范&quot;&gt;&lt;a href=&quot;#1，模块化相关规范&quot; class=&quot;headerlink&quot; title=&quot;1，模块化相关规范&quot;&gt;&lt;/a&gt;1，模块化相关规范&lt;/h2&gt;&lt;h3 id=&quot;1-浏览器端模块化规范&quot;&gt;&lt;a href=&quot;#1-浏览器端模块化规范&quot; c
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>完美解决nodejs报错 Cannot find module &#39;./application&#39;</title>
    <link href="http://yoursite.com/2019/12/03/%E8%A7%A3%E5%86%B3nodejs%E6%8A%A5%E9%94%99%20Cannot%20find%20module/"/>
    <id>http://yoursite.com/2019/12/03/解决nodejs报错 Cannot find module/</id>
    <published>2019-12-03T11:10:30.287Z</published>
    <updated>2019-12-03T11:10:30.289Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>删掉<code>node_module</code>文件夹和<code>package-lock.json</code></p></li><li><p>打开终端，键入<code>npm clean cache</code>，清除缓存</p></li><li><p>键入<code>npm i</code>，安装依赖</p></li><li><p>键入<code>npm run start</code></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;删掉&lt;code&gt;node_module&lt;/code&gt;文件夹和&lt;code&gt;package-lock.json&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;打开终端，键入&lt;code&gt;npm clean cache&lt;/code&gt;，清除缓存&lt;/p&gt;
&lt;/li&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>AE - 04.专题图绘制及打印功能实现</title>
    <link href="http://yoursite.com/2019/11/25/AE%20-%2004.%E4%B8%93%E9%A2%98%E5%9B%BE%E7%BB%98%E5%88%B6%E5%8F%8A%E6%89%93%E5%8D%B0%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2019/11/25/AE - 04.专题图绘制及打印功能实现/</id>
    <published>2019-11-25T13:01:49.741Z</published>
    <updated>2019-11-25T13:10:41.555Z</updated>
    
    <content type="html"><![CDATA[<h2 id="04-专题图绘制及打印功能实现"><a href="#04-专题图绘制及打印功能实现" class="headerlink" title="04.专题图绘制及打印功能实现"></a>04.专题图绘制及打印功能实现</h2><h5 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h5><p><img src="https://img-blog.csdnimg.cn/20191125204050379.png" alt></p><h5 id="引用类库及接口描述"><a href="#引用类库及接口描述" class="headerlink" title="引用类库及接口描述"></a>引用类库及接口描述</h5><ul><li><p>引用类库：</p><ol><li><code>ESRI.ArcGIS.Carto</code>：包括一些数据显示的接口和类，如ILegend,IMap,ILayer</li><li><code>ESRI.ArcGIS.Geodatabase</code>：提供操作地理数据库的接口，如IWorkspace,IDataset,IFeature</li><li><code>ESRI.ArcGIS.DataSourcesFile</code>：提供打开矢量数据的接口，如ICoverage,ICadTransformation</li><li><code>ESRI.ArcGIS.DataSourcesRaster</code>：提供打开一些栅格数据及转换数据的接口</li><li><code>ESRI.ArcGIS.Display</code>：包括ISymbol,IColor,一些用来在地图上显示或绘制的接口和类</li><li><code>ESRI.ArcGIS.Geometry</code>：包括点线面，路径，环等几何对象3D，地理坐标，投影坐标</li><li><code>ESRI.ArcGIS.Controls</code>：MapControl,TOC,Toolbar,Licence,PageLayout等核心可视化组件</li><li><code>ESRI.ArcGIS.SystemUI</code>：包括ICommand,ITool,等一些用户界面的接口和类</li><li><code>ESRI.ArcGIS.esriSystem</code>：包括IArray,ISet,IFile,等一些基础底层接口和类</li><li><code>ESRI.ArcGIS.OutPut</code>：提供一些打印、转换输出接口，如IBmpExporter</li></ol></li><li><p>接口：</p><ol><li><code>IEnvelope</code>：指地物的外接矩形，用来表示地物图形的大体位置和形状</li><li><code>IGraphicsContainer</code>：提供对管理的图形元素的访问</li><li><code>IMapFrame</code>：提供了访问控制地图元素对象的成员</li><li><code>IMapSurroundFrame</code>：是MapSurroundFrame对象的默认接口。获取或更新存储在帧中的环绕对象（指北针、比例尺条或图例）</li><li><code>IElement</code>：所有图形元素和框架元素都实现的接口，它可以确定元素的Geometry属性</li><li><code>ITrackCancel</code>：中断处理</li><li><code>IActiveView</code>：定义了Map对象的数据显示功能。使用该接口可以改变视图的范围，刷新视图。</li></ol></li></ul><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><blockquote><p>步骤1： 在winform页面中添加整饰操作按钮。</p><p>步骤2： 给按钮添加点击事件</p><p>步骤3： 创建元素操作文件（pagelayout_element.cs）</p><p>步骤4： 实现添加比例尺，比例文本，图例，指北针，元素</p><p>步骤5： 将添加的元素方法进一步封装</p><p>步骤6： 实现添加文本，为地图添加标题，添加格网，拉框选择</p><p>步骤7： 实现打印结果</p><p>步骤8： 运行 – &gt; 添加矢量 – &gt; 符号化 – &gt; 渲染 – &gt; 数据视图、布局视图查看 – &gt; 添加比例尺，比例文本，图例，指北针，标题 – &gt; 打印输出</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20191125204327698.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70" alt></p><p><img src="https://img-blog.csdnimg.cn/20191125204335626.png" alt><br><img src="https://img-blog.csdnimg.cn/20191125204343508.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70" alt></p><p><img src="https://img-blog.csdnimg.cn/20191125204349198.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70" alt></p><p><img src="https://img-blog.csdnimg.cn/20191125204356457.png" alt></p><p><img src="https://img-blog.csdnimg.cn/2019112520440175.png" alt></p><p><img src="https://img-blog.csdnimg.cn/20191125204406713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70" alt></p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><p><a href="https://github.com/DanBo3110/ArcEngine/tree/master/" target="_blank" rel="noopener">Code Download in GitHUb</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;04-专题图绘制及打印功能实现&quot;&gt;&lt;a href=&quot;#04-专题图绘制及打印功能实现&quot; class=&quot;headerlink&quot; title=&quot;04.专题图绘制及打印功能实现&quot;&gt;&lt;/a&gt;04.专题图绘制及打印功能实现&lt;/h2&gt;&lt;h5 id=&quot;流程图&quot;&gt;&lt;a href=
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>AE - 01.空间书签的创建及调用</title>
    <link href="http://yoursite.com/2019/11/25/AE%20-%2001.%E7%A9%BA%E9%97%B4%E4%B9%A6%E7%AD%BE%E7%9A%84%E5%88%9B%E5%BB%BA%E5%8F%8A%E8%B0%83%E7%94%A8/"/>
    <id>http://yoursite.com/2019/11/25/AE - 01.空间书签的创建及调用/</id>
    <published>2019-11-25T12:59:02.083Z</published>
    <updated>2019-11-25T12:38:20.655Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AE-01-空间书签的创建及调用"><a href="#AE-01-空间书签的创建及调用" class="headerlink" title="AE - 01.空间书签的创建及调用"></a>AE - 01.空间书签的创建及调用</h2><h5 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h5><p><img src="https://img-blog.csdnimg.cn/20191030163103298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70" alt></p><h5 id="引用类库及接口描述"><a href="#引用类库及接口描述" class="headerlink" title="引用类库及接口描述"></a>引用类库及接口描述</h5><ul><li>引用类库：</li></ul><pre><code>using ESRI.ArcGIS.Carto;</code></pre><ul><li>接口：</li></ul><pre><code>1. IMapBookmarks接口：Bookmarks属性可以得到地图文档中已经存在的所有书签对象，通过该接口的AddBookmark和RemoveBookmark方法可以对书签进行添加和删除。2. ISpatialBookmark接口：定义所有空间书签的共同功能，特别是书签的Name属性和ZoomTo方法。Name属性定义了书签的名字，通过ZoomTo方法可跳转到书签位置点。3. IAOIBookmark接口：继承自ISpatialBookmark接口，新增了Location属性，存储地图中感兴趣范围。</code></pre><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><blockquote><p>步骤1： 添加控件</p><p>步骤2： 给控件添加事件，设置删除Button的可见性</p><p>步骤3： 封装功能</p><p>步骤4： 运行实现</p></blockquote><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><p>七、代码</p><ol><li><p>创建书签</p><pre><code>/// &lt;summary&gt;/// 创建书签/// &lt;/summary&gt;public Boolean CreatBookmark(string sBookmarkName){    Console.WriteLine(sBookmarkName);    IAOIBookmark aoiBookmark = new AOIBookmark();    if (aoiBookmark != null)    {        aoiBookmark.Location = mapControl.ActiveView.Extent;        aoiBookmark.Name = sBookmarkName;    }    IMapBookmarks bookmarks = mapControl.Map as IMapBookmarks;    if (bookmarks != null)    {        bookmarks.AddBookmark(aoiBookmark);        cmb_Bookmark.Items.Add(aoiBookmark.Name);        return true;    }    return false;   }</code></pre></li><li><p>监听结束书签列表</p><pre><code>/// &lt;summary&gt;/// 监听结束书签列表/// &lt;/summary&gt;public Boolean oneBookmark(string name){    IMapBookmarks bookmarks = mapControl.Map as IMapBookmarks;    IEnumSpatialBookmark enumSpatialBookmark = bookmarks.Bookmarks;    enumSpatialBookmark.Reset();    ISpatialBookmark spatialBookmark = enumSpatialBookmark.Next();    while (spatialBookmark != null)    {        if (name == spatialBookmark.Name)        {            return false;        }        spatialBookmark = enumSpatialBookmark.Next();    }    return true;  }</code></pre></li><li><p>选中书签列表item</p><p> private void cmb_Bookmark_SelectedIndexChanged(object sender, EventArgs e)<br> {</p><pre><code>IMapBookmarks bookmarks = mapControl.Map as IMapBookmarks;IEnumSpatialBookmark enumSpatialBookmark = bookmarks.Bookmarks;enumSpatialBookmark.Reset();ISpatialBookmark spatialBookmark = enumSpatialBookmark.Next();while (spatialBookmark != null){    string index = cmb_Bookmark.SelectedIndex.ToString();    string bm_name = cmb_Bookmark.Items[Convert.ToInt32(index)].ToString();    //Console.WriteLine(bm_name + &quot; &quot;+ spatialBookmark.Name);    if (bm_name == spatialBookmark.Name)    {        spatialBookmark.ZoomTo((IMap)mapControl.ActiveView);        mapControl.ActiveView.Refresh();        break;    }    spatialBookmark = enumSpatialBookmark.Next();}btn_bmDEL.Visible = true;but_addbm.Visible = false;</code></pre><p>   }</p></li><li><p>添加书签</p><pre><code>private void but_addbm_Click(object sender, EventArgs e){        addBookmark add = new addBookmark(this);        add.Show();  }</code></pre></li><li><p>删除书签</p><pre><code>private void btn_bmDEL_Click(object sender, EventArgs e){        cmb_Bookmark.Items.Remove(cmb_Bookmark.SelectedItem);        cmb_Bookmark.Text = &quot;&quot;;        if (cmb_Bookmark.Items.Count == 0)            cmb_Bookmark.Text = &quot;无书签&quot;;        btn_bmDEL.Visible = false;        but_addbm.Visible = true;   }</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;AE-01-空间书签的创建及调用&quot;&gt;&lt;a href=&quot;#AE-01-空间书签的创建及调用&quot; class=&quot;headerlink&quot; title=&quot;AE - 01.空间书签的创建及调用&quot;&gt;&lt;/a&gt;AE - 01.空间书签的创建及调用&lt;/h2&gt;&lt;h5 id=&quot;流程图&quot;&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>AE学习笔记</title>
    <link href="http://yoursite.com/2019/11/25/AE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/11/25/AE学习笔记/</id>
    <published>2019-11-25T12:59:02.081Z</published>
    <updated>2019-11-25T13:10:32.854Z</updated>
    
    <content type="html"><![CDATA[<ol><li><a href="https://danbo3110.github.io/2019/10/30/AE%20-%2001.%E7%A9%BA%E9%97%B4%E4%B9%A6%E7%AD%BE%E7%9A%84%E5%88%9B%E5%BB%BA%E5%8F%8A%E8%B0%83%E7%94%A8/" target="_blank" rel="noopener">空间书签的创建及调用</a></li><li><a href="https://danbo3110.github.io/2019/10/30/AE%20-%2002.%E7%9F%A2%E9%87%8F%E3%80%81%E6%A0%85%E6%A0%BC%E3%80%81Mxd%E7%9A%84%E5%8A%A0%E8%BD%BD/" target="_blank" rel="noopener">矢量、栅格、Mxd的加载</a></li><li><a href="https://danbo3110.github.io/2019/11/25/AE%20-%2003.%E7%AC%A6%E5%8F%B7%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">符号库设计与实现</a></li><li><a href="https://danbo3110.github.io/2019/11/25/AE%20-%2004.%E4%B8%93%E9%A2%98%E5%9B%BE%E7%BB%98%E5%88%B6%E5%8F%8A%E6%89%93%E5%8D%B0%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">专题图绘制及打印功能实现</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://danbo3110.github.io/2019/10/30/AE%20-%2001.%E7%A9%BA%E9%97%B4%E4%B9%A6%E7%AD%BE%E7%9A%84%E5%88%9B%E5%BB%BA%E5%8F%8
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>AE - 03.符号库设计与实现</title>
    <link href="http://yoursite.com/2019/11/25/AE%20-%2003.%E7%AC%A6%E5%8F%B7%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2019/11/25/AE - 03.符号库设计与实现/</id>
    <published>2019-11-25T12:59:02.078Z</published>
    <updated>2019-11-25T13:00:07.151Z</updated>
    
    <content type="html"><![CDATA[<h2 id="03-符号库设计与实现"><a href="#03-符号库设计与实现" class="headerlink" title="03.符号库设计与实现"></a>03.符号库设计与实现</h2><h5 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h5><p><img src="https://img-blog.csdnimg.cn/20191125200848184.png" alt></p><p>#####引用类库及接口描述</p><ul><li>引用类库：<ol><li><code>ESRI.ArcGIS.Carto</code>：包括一些数据显示的接口和类，如ILegend,IMap,ILayer</li><li><code>ESRI.ArcGIS.Geodatabase</code>：提供操作地理数据库的接口，如IWorkspace,IDataset,IFeature</li><li><code>ESRI.ArcGIS.DataSourcesFile</code>：提供打开矢量数据的接口，如ICoverage,ICadTransformation</li><li><code>ESRI.ArcGIS.DataSourcesRaster</code>：提供打开一些栅格数据及转换数据的接口</li><li><code>ESRI.ArcGIS.Display</code>：包括ISymbol,IColor,一些用来在地图上显示或绘制的接口和类</li><li><code>ESRI.ArcGIS.Geometry</code>：包括点线面，路径，环等几何对象3D，地理坐标，投影坐标</li><li><code>ESRI.ArcGIS.Controls</code>：MapControl,TOC,Toolbar,Licence,PageLayout等核心可视化组件</li><li><code>ESRI.ArcGIS.SystemUI</code>：包括ICommand,ITool,等一些用户界面的接口和类<ol start="9"><li><code>ESRI.ArcGIS.esriSystem</code>：包括IArray,ISet,IFile,等一些基础底层接口和类</li></ol></li></ol></li></ul><ul><li><p>接口：</p><ol><li><code>IRgbColor</code>：使用RGB（红色，绿色，蓝色）颜色模型维护有关颜色的信息</li><li><code>IColor</code>：IRgbColor的父类接口。符号颜色向Symbol赋值需要接口转换为IColor</li><li><code>ISimpleFillSymbol</code>：用于创建简单面状符号</li><li><code>ISimpleLineSymbol</code>：用于创建简单线状符号</li><li><code>ISimpleMarkerSymbol</code>：用于创建简单点状符号</li><li><code>ISymbol</code>：符号接口，所有的符号类都实现了这个接口，符号向渲染器赋值需转换为ISymbol</li><li><code>IGeoFeatureLayer</code>：对基于矢量地理数据的图层的符号化和标签属性的访问</li><li><code>IFeatureLayer</code>：访问要素图层常见内容，访问基于矢量图形数据图层的属性和方法</li><li><code>IFeatureRenderer</code>：提供对控制渲染器共有功能的成员的访问。要素渲染器都实现此接口。</li></ol></li></ul><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><blockquote><p>步骤1： 在winform页面中添加渲染按钮。</p><p>步骤2： 创建符号化，渲染窗口程序。</p><p>步骤3： 为渲染窗口的开始按钮添加事件，获取参数值。</p><p>步骤4： 创建符号化渲染操作类(C_S_R)</p><p>步骤5： 实现获取颜色，宽度，符号化，渲染方法。</p><p>步骤6： 运行 – &gt; 添加矢量 – &gt; 主页面触发渲染 – &gt; 设置参数 – &gt;符号化 – &gt; 渲染 – &gt; 数据视图、布局视图查看</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20191125201225499.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70" alt></p><p><img src="https://img-blog.csdnimg.cn/20191125201241877.png" alt></p><p><img src="https://img-blog.csdnimg.cn/20191125201301152.png" alt></p><p><img src="https://img-blog.csdnimg.cn/20191125201301284.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70" alt></p><p><img src="https://img-blog.csdnimg.cn/20191125201310421.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70" alt></p><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><p><a href="https://github.com/DanBo3110/ArcEngine/tree/master/" target="_blank" rel="noopener">Code Download in GitHUb</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;03-符号库设计与实现&quot;&gt;&lt;a href=&quot;#03-符号库设计与实现&quot; class=&quot;headerlink&quot; title=&quot;03.符号库设计与实现&quot;&gt;&lt;/a&gt;03.符号库设计与实现&lt;/h2&gt;&lt;h5 id=&quot;流程图&quot;&gt;&lt;a href=&quot;#流程图&quot; class=&quot;he
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>AE - 02.矢量、栅格、Mxd的加载</title>
    <link href="http://yoursite.com/2019/11/25/AE%20-%2002.%E7%9F%A2%E9%87%8F%E3%80%81%E6%A0%85%E6%A0%BC%E3%80%81Mxd%E7%9A%84%E5%8A%A0%E8%BD%BD/"/>
    <id>http://yoursite.com/2019/11/25/AE - 02.矢量、栅格、Mxd的加载/</id>
    <published>2019-11-25T12:59:02.076Z</published>
    <updated>2019-10-30T08:46:34.271Z</updated>
    
    <content type="html"><![CDATA[<h2 id="02-矢量、栅格、Mxd的加载"><a href="#02-矢量、栅格、Mxd的加载" class="headerlink" title="02.矢量、栅格、Mxd的加载"></a>02.矢量、栅格、Mxd的加载</h2><h5 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h5><p><img src="https://img-blog.csdnimg.cn/20191030163613363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70" alt></p><p>#####引用类库及接口描述</p><ul><li>引用类库：</li></ul><pre><code>using ESRI.ArcGIS.Carto;using ESRI.ArcGIS.Geometry;using ESRI.ArcGIS.Geodatabase;using ESRI.ArcGIS.DataSourcesFile;using ESRI.ArcGIS.DataSourcesRaster;</code></pre><ul><li>接口：</li></ul><pre><code>1. OpenFileDialog 接口：用于打开文件对话框2. IWorkspaceFactory 接口：工作空间工厂，工作空间的发布者，允许客户连接通过一组连接属性定义的工作空间。普通类。3. IWorkspace 接口：提供访问工作空间的通用属性和方法，如它的连接属性，以及包含的数据集的方法。4. IFeatureWorkspace 接口：用于访问和管理地理数据库中的要素的重要成分—数据集。5. IRasterWorkspace 接口：用于打开和建立基于文件的RasterDataset。6. IFeatureClass 接口：获取和设置要素类属性的主要接口。7. IFeatureLayer 接口：继承自ILayer,提供了访问基于矢量数据图层的属性和方法。、8. ILayer 接口：Layer 是图层对象，是数据的外壳，必须建立在数据的基础上才有意义。9. IMap 接口：许多图层的集合，由多个ILayer构成。</code></pre><h5 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h5><ul><li>矢量<ol><li>获取shp文件的路径和文件名称</li><li>由工作空间工厂创建Shp工作空间工厂类，打开工作空间</li><li>转换工作空间为要素工作空间，打开要素类</li><li>创建要素图层，设置要素图层的FeatureClass为上面打开的要素类</li><li>转换IFeatureLayer为ILayer，添加到mapcontorl中。</li><li>刷新</li></ol></li><li>栅格<ol><li>获取shp文件的路径和文件名称</li><li>由工作空间工厂创建Raster工作空间工厂类，打开工作空间</li><li>转换工作空间为栅格工作空间，打开栅格数据集</li><li>影像金字塔的判断和创建</li><li>新建栅格图层，添加到mapcontorl中。</li><li>刷新</li></ol></li></ul><h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><p>七、代码</p><ol><li><p>打开按钮的点击事件</p><pre><code>private void menu_open_Click(object sender, EventArgs e){    addMapFile();}</code></pre></li><li><p>打开文件</p><pre><code>private void addMapFile(){    OpenFileDialog pOpenfileDialog = new OpenFileDialog();    pOpenfileDialog.Filter = &quot;全部文件|*.*&quot; +        &quot;|Shape 文件|*.shp&quot; +        &quot;|Mxd 文件|*.mxd&quot; +        &quot;|栅格 文件|*.tif;*.tiff;*.jpep;*.jpg;*.png;*.bmp&quot;;    if (pOpenfileDialog.ShowDialog() == DialogResult.OK)    {        string path = pOpenfileDialog.FileName;        bool shp = path.EndsWith(&quot;.shp&quot;);        bool mxd = path.EndsWith(&quot;.mxd&quot;);        bool tif = path.EndsWith(&quot;.tif&quot;) || path.EndsWith(&quot;.tiff&quot;) || path.EndsWith(&quot;.jpep&quot;)             || path.EndsWith(&quot;.jpg&quot;) || path.EndsWith(&quot;.png&quot;) || path.EndsWith(&quot;.bmp&quot;);        if (shp)            openShpFile(path);        else if (mxd)            openShpFile(path);        else if (tif)            openShanGe(path);    }}</code></pre></li><li><p>打开shp</p><pre><code>/// &lt;summary&gt;/// 打开shp数据/// &lt;/summary&gt;private void openShpFile(string file){    int index = 0;    index = file.LastIndexOf(&quot;\\&quot;);    string filePath = file.Substring(0, index);    string fileName = file.Substring(index + 1, file.Length - (index + 1));    IWorkspaceFactory pWorkspaceFactory = new ShapefileWorkspaceFactory();    IWorkspace pWorkspace = pWorkspaceFactory.OpenFromFile(filePath, 0);    IFeatureWorkspace pFeatureWokkspace = pWorkspace as IFeatureWorkspace;    IFeatureClass pFC = pFeatureWokkspace.OpenFeatureClass(fileName);    IFeatureLayer pFLayer = new FeatureLayer();    pFLayer.FeatureClass = pFC;    pFLayer.Name = pFC.AliasName;    ILayer pLayer = pFLayer as ILayer;    IMap pMap = mapControl.Map;    pMap.AddLayer(pLayer);    mapControl.ActiveView.Refresh();}</code></pre></li><li><p>打开栅格</p><pre><code>/// &lt;summary&gt;/// 打开栅格数据/// &lt;/summary&gt;private void openShanGe(string Path){    string RasterPath = System.IO.Path.GetDirectoryName(Path);    string RasterName = System.IO.Path.GetFileName(Path);    IWorkspaceFactory pRasterWsF = new RasterWorkspaceFactory();    IWorkspace pWs = pRasterWsF.OpenFromFile(RasterPath, 0);    IRasterWorkspace pRasterWs = pWs as IRasterWorkspace;    IRasterDataset pRasterDS = pRasterWs.OpenRasterDataset(RasterName);    IRasterPyramid pRasterPyramid = pRasterDS as IRasterPyramid;    if ((pRasterPyramid != null)&amp;&amp;(!pRasterPyramid.Present))    {        if (MessageBox.Show(&quot;是否开始创建金字塔？&quot;, &quot;提示&quot;, MessageBoxButtons.OKCancel, MessageBoxIcon.Question, MessageBoxDefaultButton.Button1) == System.Windows.Forms.DialogResult.OK)        {            Stopwatch sw = new Stopwatch();            sw.Start();               pRasterPyramid.Create();            sw.Stop();            MessageBox.Show(&quot;创建完成，Time：&quot;+ sw.ElapsedMilliseconds.ToString()+&quot;ms&quot;);        }        else                MessageBox.Show(&quot;放弃创建金字塔&quot;);    }    IRasterLayer pRasterLayer = new RasterLayer();    pRasterLayer.CreateFromRaster(pRasterDS.CreateDefaultRaster());    IMap pmap = mapControl.Map;    pmap.AddLayer(pRasterLayer);    mapControl.ActiveView.Refresh();    OpenStatus();}</code></pre></li><li><p>打开mxd</p><pre><code>/// &lt;summary&gt;/// 打开mxd数据/// &lt;/summary&gt;private void openMXD(string path){    mapControl.MousePointer = esriControlsMousePointer.esriPointerHourglass;    mapControl.LoadMxFile(path, 0, Type.Missing);    mapControl.MousePointer = esriControlsMousePointer.esriPointerDefault;    OpenStatus();}</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;02-矢量、栅格、Mxd的加载&quot;&gt;&lt;a href=&quot;#02-矢量、栅格、Mxd的加载&quot; class=&quot;headerlink&quot; title=&quot;02.矢量、栅格、Mxd的加载&quot;&gt;&lt;/a&gt;02.矢量、栅格、Mxd的加载&lt;/h2&gt;&lt;h5 id=&quot;流程图&quot;&gt;&lt;a href=
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Express+multer+Ajax 上传图片并加载</title>
    <link href="http://yoursite.com/2019/11/23/Express+multer+Ajax%20%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E5%B9%B6%E5%8A%A0%E8%BD%BD/"/>
    <id>http://yoursite.com/2019/11/23/Express+multer+Ajax 上传图片并加载/</id>
    <published>2019-11-23T10:34:41.534Z</published>
    <updated>2019-11-23T10:34:41.535Z</updated>
    
    <content type="html"><![CDATA[<h4 id="html"><a href="#html" class="headerlink" title="html"></a>html</h4><pre><code>&lt;input id=&quot;files&quot; type=&quot;file&quot; name=&quot;file&quot; multiple/&gt; &lt;input type=&quot;submit&quot; id=&quot;shangchuan&quot; value=&quot;上传&quot;/&gt;&lt;ul&gt;    &lt;li&gt;&lt;img src=&quot;images/f.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt;&lt;/ul&gt;</code></pre><blockquote><p>需要注意的是里面的name属性，需要和js中的代码一一对应</p></blockquote><h5 id="js"><a href="#js" class="headerlink" title="js"></a>js</h5><pre><code>$(function () {    $(&quot;#shangchuan&quot;).click(function () {        var file = document.getElementById(&quot;files&quot;).files[0];        var formdata=new FormData();        formdata.append(&quot;file&quot;,file);        $.ajax({            type: &apos;POST&apos;,            url: &apos;/upload&apos;,            processData:false,//对data参数进行序列化处理            contentType:false,//内容编码类型            cache:false,//不使用缓存            data: formdata,            success: function(data) {                var $li = $(&quot;&lt;li&gt;&lt;img src=\&quot;images/&quot;+ file.name +&quot;\&quot; alt=\&quot;\&quot;&gt;&lt;/li&gt;&quot;);                $(&quot;ul&quot;).append($li);            }        });    });});</code></pre><blockquote><p><code>formdata.append(&quot;file&quot;,file);</code>最终的提交还是以from表单的形式，在给表单中添加需要上传的文件时，类似键值对。这里的键名对应的时<code>name</code>属性而不是<code>id</code></p><p>其中的：<code>processData，contentType:false，cache</code>的添加是必须的，对于上传文件来说</p><p>应为Ajax请求时异步得，所以将添加放置在<code>success</code>的回调函数中，创建的节点很容易出错，需要十分注意转义符号的使用，做好打印看看</p></blockquote><h5 id="nodejs"><a href="#nodejs" class="headerlink" title="nodejs"></a>nodejs</h5><pre><code>app.post(&apos;/upload&apos;, multer({dest: &apos;./public/upload_tmp/&apos;}).array(&apos;file&apos;, 10), function (req, res, next) {  //这里10表示最大支持的文件上传数目    let files = req.files;    console.log(files);    if (files.length === 0) {        res.render(&quot;error&quot;, {message: &quot;上传文件不能为空！&quot;});        return    } else {        let fileInfos = [];        for (var i in files) {            let file = files[i];            let fileInfo = {};            fs.renameSync(&apos;./public/upload_tmp/&apos; + file.filename, &apos;./public/images/&apos; + file.originalname);//这里修改文件名字，比较随意。            //获取文件基本信息            fileInfo.mimetype = file.mimetype;            fileInfo.originalname = file.originalname;            fileInfo.size = file.size;            fileInfo.path = file.path;            fileInfos.push(fileInfo);        }        // 设置响应类型及编码        res.set({            &apos;content-type&apos;: &apos;application/json; charset=utf-8&apos;        });        res.json({&quot;result&quot;:{message:&quot;success&quot;}});        res.end(&quot;success!&quot;);    }});</code></pre><blockquote><p><code>.array(&#39;file&#39;, 10)</code>中的<code>file</code>对应，表单对象中存储文件的键名</p><p><code>res.json({&quot;result&quot;:{message:&quot;success&quot;}});</code>这里的这个似乎没有用，但是经过测试，没有这个的时候不能返回<code>success</code>状态</p><p>如果要返回，那么设置相应类型及编码最好写上，自测出现了BUG，添加之后通过。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;html&quot;&gt;&lt;a href=&quot;#html&quot; class=&quot;headerlink&quot; title=&quot;html&quot;&gt;&lt;/a&gt;html&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;input id=&amp;quot;files&amp;quot; type=&amp;quot;file&amp;quot; n
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>封装Cookie.js+使用</title>
    <link href="http://yoursite.com/2019/11/17/%E5%B0%81%E8%A3%85Cookie.js+%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/11/17/封装Cookie.js+使用/</id>
    <published>2019-11-17T13:28:16.120Z</published>
    <updated>2019-11-17T13:28:16.120Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><hr><h3 id="1-添加"><a href="#1-添加" class="headerlink" title="1. 添加"></a>1. 添加</h3><pre><code>function addCookie(key, value, day, path, domain) {    // 1.处理默认保存的路径    var index = window.location.pathname.lastIndexOf(&quot;/&quot;)    var currentPath = window.location.pathname.slice(0, index);    path = path || currentPath;    // 2.处理默认保存的domain    domain = domain || document.domain;    // 3.处理默认的过期时间    if (!day) {        document.cookie = key + &quot;=&quot; + value + &quot;;path=&quot; + path + &quot;;domain=&quot; + domain + &quot;;&quot;;    } else {        var date = new Date();        date.setDate(date.getDate() + day);        document.cookie = key + &quot;=&quot; + value + &quot;;expires=&quot; + date.toGMTString() + &quot;;path=&quot; + path + &quot;;domain=&quot; + domain + &quot;;&quot;;    }}</code></pre><p>虽然参数有很多，实际使用的时候并不需要这么麻烦。</p><p>最简单：<code>addCookie(&quot;city&quot;,&quot;北京&quot;,);</code> 这样就创建了一个Cookie，它的名字为<code>city</code>，值为<code>北京</code></p><p>参数依此为：键名，键值，生存周期，有效路径，域名白名单</p><ul><li>键名：名称，不可修改</li><li>键值：值，Unicode字符，需要字符编码。二进制数据，需要BASE64编码</li><li>生存周期：失效时间，单位为秒，默认为关闭浏览器失效</li><li>有效路径：可以访问该Cookie的路径，默认和创建路径相同，设置为<code>&quot;/&quot;</code>代表本域名之下所有文件都可以访问，类似与全局变量</li><li>域名白名单：可以访问这条Cookie的域名</li></ul><h3 id="2-获取"><a href="#2-获取" class="headerlink" title="2. 获取"></a>2. 获取</h3><pre><code>function getCookie(key) {        // console.log(document.cookie);        var res = document.cookie.split(&quot;;&quot;);        // console.log(res);        for(var i = 0; i &lt; res.length; i++){            // console.log(res[i]);            var temp = res[i].split(&quot;=&quot;);            // console.log(temp);            if(temp[0].trim() === key){                return temp[1];            }        }    }</code></pre><ul><li><code>getCookie(key)</code>参数为键名</li></ul><h3 id="3-删除"><a href="#3-删除" class="headerlink" title="3. 删除"></a>3. 删除</h3><ul><li>只要生存时间过期了，这条Cookie就没有了</li><li>默认情况下只能删除默认路径中保存的cookie,。</li><li>如果想删除指定路径保存的cookie, 那么必须在删除的时候指定路径才可以</li></ul><pre><code>function delCookie(key, path) {        addCookie(key, getCookie(key), -1, path);    }</code></pre><ul><li><code>path</code>参数可不写</li><li><code>delCookie(&quot;city&quot;)</code>即可删除创建的那条Cookie</li></ul><hr><p>创建固定生存周期，删除，按需修改即可</p><h2 id="怎么查看呢？"><a href="#怎么查看呢？" class="headerlink" title="怎么查看呢？"></a>怎么查看呢？</h2><h5 id="F12-gt-Application-gt-Cookies-gt-（域名）-gt-result"><a href="#F12-gt-Application-gt-Cookies-gt-（域名）-gt-result" class="headerlink" title="F12 --&gt; Application --&gt; Cookies --&gt; （域名）--&gt; result"></a><code>F12 --&gt; Application --&gt; Cookies --&gt; （域名）--&gt; result</code></h5><p><img src="https://img-blog.csdnimg.cn/20191117212325306.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70" alt></p><h3 id="封装好了，可别忘记引入哦"><a href="#封装好了，可别忘记引入哦" class="headerlink" title="封装好了，可别忘记引入哦"></a>封装好了，可别忘记引入哦</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Cookie&quot;&gt;&lt;a href=&quot;#Cookie&quot; class=&quot;headerlink&quot; title=&quot;Cookie&quot;&gt;&lt;/a&gt;Cookie&lt;/h2&gt;&lt;hr&gt;
&lt;h3 id=&quot;1-添加&quot;&gt;&lt;a href=&quot;#1-添加&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Nodejs自动重启工具配置 [ nodemon ]</title>
    <link href="http://yoursite.com/2019/11/13/Nodejs%E8%87%AA%E5%8A%A8%E9%87%8D%E5%90%AF%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE%20%5B%20nodemon%20%5D/"/>
    <id>http://yoursite.com/2019/11/13/Nodejs自动重启工具配置 [ nodemon ]/</id>
    <published>2019-11-13T06:13:41.980Z</published>
    <updated>2019-11-23T10:08:33.331Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-安装依赖包"><a href="#1-安装依赖包" class="headerlink" title="1. 安装依赖包"></a>1. 安装依赖包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i nodemon --save</span><br></pre></td></tr></table></figure><h2 id="2-修改package-json文件"><a href="#2-修改package-json文件" class="headerlink" title="2.修改package.json文件"></a>2.修改package.json文件</h2><h6 id="找到scripts"><a href="#找到scripts" class="headerlink" title="找到scripts"></a>找到<code>scripts</code></h6><pre><code>&quot;scripts&quot;: {    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;  },</code></pre><h6 id="在scripts下面添加start"><a href="#在scripts下面添加start" class="headerlink" title="在scripts下面添加start"></a>在<code>scripts</code>下面添加start</h6><pre><code>&quot;scripts&quot;: {    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,    &quot;start&quot;: &quot;nodemon app.js&quot;  },</code></pre><h2 id="3-app-js根目录下打开终端，键入npm-run-start"><a href="#3-app-js根目录下打开终端，键入npm-run-start" class="headerlink" title="3. app.js根目录下打开终端，键入npm run start"></a>3. app.js根目录下打开终端，键入<code>npm run start</code></h2><h2 id="4-修改后，ctrl-s保存之后，项目变化重新启动。"><a href="#4-修改后，ctrl-s保存之后，项目变化重新启动。" class="headerlink" title="4. 修改后，ctrl+s保存之后，项目变化重新启动。"></a>4. 修改后，<code>ctrl+s</code>保存之后，项目变化重新启动。</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-安装依赖包&quot;&gt;&lt;a href=&quot;#1-安装依赖包&quot; class=&quot;headerlink&quot; title=&quot;1. 安装依赖包&quot;&gt;&lt;/a&gt;1. 安装依赖包&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td clas
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Express+multer 上传图片（单文件，多文件）</title>
    <link href="http://yoursite.com/2019/11/11/Express+multer%20%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%EF%BC%88%E5%8D%95%E6%96%87%E4%BB%B6%EF%BC%8C%E5%A4%9A%E6%96%87%E4%BB%B6%EF%BC%89/"/>
    <id>http://yoursite.com/2019/11/11/Express+multer 上传图片（单文件，多文件）/</id>
    <published>2019-11-11T13:24:37.645Z</published>
    <updated>2019-11-11T13:25:21.731Z</updated>
    
    <content type="html"><![CDATA[<h2 id="fs模块异步上传"><a href="#fs模块异步上传" class="headerlink" title="fs模块异步上传"></a><code>fs</code>模块异步上传</h2><hr><pre><code>app.post(&apos;/upload&apos;, upload.any(), function(req, res, next) {    //req.files[0]// 上传的文件信息    //需要Express托管静态文件public文件夹    var des_file = &quot;./public/images/&quot; + req.files[0].originalname;    fs.readFile( req.files[0].path, function (err, data) {        fs.writeFile(des_file, data, function (err) {            if( err ){                console.log( err );            }else{                console.log( req.files[0].originalname );            }        });    });});</code></pre><h2 id="multer模块引入"><a href="#multer模块引入" class="headerlink" title="multer模块引入"></a><code>multer</code>模块引入</h2><p><code>npm i multer --save</code></p><h2 id="multer单文件上传"><a href="#multer单文件上传" class="headerlink" title="multer单文件上传"></a><code>multer</code>单文件上传</h2><hr><pre><code>//dest设置上传原始文件的路径，single要与file的name保持一致app.post(&apos;/upload&apos;, multer({dest: &apos;./public/upload_tmp/&apos;})    .single(&apos;file&apos;), function (req, res, next) {    if (req.file.length === 0) {        res.render(&quot;error&quot;, {message: &quot;上传文件不能为空！&quot;});        return    }     else {        let file = req.file;        //存储上传对象信息        let fileInfo = {};        //修改名字，第一个参数为旧路径，第二个参数为新路径（注意：旧路径要和上面的dest保持一致）        fs.renameSync(&apos;./public/upload_tmp/&apos; + file.filename, &apos;./public/images/&apos; + file.originalname);        // 获取文件信息        fileInfo.mimetype = file.mimetype;        fileInfo.originalname = file.originalname;        fileInfo.size = file.size;        fileInfo.path = file.path;        //设置响应类型、编码        res.set({            &apos;content-type&apos;: &apos;application/json; charset=utf-8&apos;        });        res.end(&quot;成功&quot;);    }});</code></pre><h2 id="multer多文件上传"><a href="#multer多文件上传" class="headerlink" title="multer多文件上传"></a><code>multer</code>多文件上传</h2><hr><pre><code>//与单文件相比唯一的不同就是不再使用.single//改为.array(&apos;file&apos;, 10)，其中的file和.single的参数一样，10为上传数目的最大限制app.post(&apos;/upload&apos;, multer({dest: &apos;./public/upload_tmp/&apos;}).array(&apos;file&apos;, 10), function (req, res, next) {    let files = req.files;    if (files.length === 0) {        res.render(&quot;error&quot;, {message: &quot;上传文件不能为空！&quot;});        return    } else {        let fileInfos = [];        for (var i in files) {            let file = files[i];            let fileInfo = {};            fs.renameSync(&apos;./public/upload_tmp/&apos; + file.filename, &apos;./public/images/&apos; + file.originalname);            //获取文件基本信息            fileInfo.mimetype = file.mimetype;            fileInfo.originalname = file.originalname;            fileInfo.size = file.size;            fileInfo.path = file.path;            fileInfos.push(fileInfo);        }        // 设置响应类型、编码        res.set({            &apos;content-type&apos;: &apos;application/json; charset=utf-8&apos;        });        res.end(&quot;成功&quot;);    }});</code></pre><h2 id="html"><a href="#html" class="headerlink" title="html"></a>html</h2><hr><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;/upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;    &lt;!-- multiple允许多文件上传，单文件可忽略--&gt;    &lt;input id=&quot;files&quot; type=&quot;file&quot; name=&quot;file&quot; multiple/&gt;    &lt;input type=&quot;submit&quot; value=&quot;上传&quot;/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;fs模块异步上传&quot;&gt;&lt;a href=&quot;#fs模块异步上传&quot; class=&quot;headerlink&quot; title=&quot;fs模块异步上传&quot;&gt;&lt;/a&gt;&lt;code&gt;fs&lt;/code&gt;模块异步上传&lt;/h2&gt;&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;app.post(&amp;apos;/uplo
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>18 - 对联广告，弹窗广告练习</title>
    <link href="http://yoursite.com/2019/10/23/18%20-%20%E5%AF%B9%E8%81%94%E5%B9%BF%E5%91%8A%EF%BC%8C%E5%BC%B9%E7%AA%97%E5%B9%BF%E5%91%8A%E7%BB%83%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/10/23/18 - 对联广告，弹窗广告练习/</id>
    <published>2019-10-23T08:17:29.508Z</published>
    <updated>2019-10-16T06:13:08.740Z</updated>
    
    <content type="html"><![CDATA[<h4 id="对联广告"><a href="#对联广告" class="headerlink" title="对联广告"></a>对联广告</h4><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;40-对联广告&lt;/title&gt;    &lt;style&gt;        *{            margin: 0;            padding: 0;        }        .left{            float: left;            position: fixed;            left: 0;            top: 200px;        }        .right{            float: right;            position: fixed;            right: 0;            top: 200px;        }        img{            display: none;        }    &lt;/style&gt;    &lt;script src=&quot;js/jquery-1.12.4.js&quot;&gt;&lt;/script&gt;    &lt;script&gt;        $(function () {            // 1.监听网页的滚动            $(window).scroll(function () {                // 1.1获取网页滚动的偏移位                var offset = $(&quot;html,body&quot;).scrollTop();                // 1.2判断网页是否滚动到了指定的位置                if(offset &gt;= 500){                    // 1.3显示广告                    $(&quot;img&quot;).show(1000);                }else{                    // 1.4隐藏广告                    $(&quot;img&quot;).hide(1000);                }            });        });    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;img src=&quot;images/left_ad.png&quot; class=&quot;left&quot;&gt;&lt;img src=&quot;images/right_ad.png&quot; class=&quot;right&quot;&gt;&lt;br&gt;&lt;br&gt;。。。（此处省略五百个&lt;br&gt;）。。。&lt;br&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h4 id="弹窗广告"><a href="#弹窗广告" class="headerlink" title="弹窗广告"></a>弹窗广告</h4><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;46-弹窗广告&lt;/title&gt;    &lt;style&gt;        *{            margin: 0;            padding: 0;        }        .ad{            position: fixed;            right: 0;            bottom: 0;            display: none;        }        .ad&gt;span{            display: inline-block;            width: 30px;            height: 30px;            position: absolute;            top: 0;            right: 0;        }    &lt;/style&gt;    &lt;script src=&quot;js/jquery-1.12.4.js&quot;&gt;&lt;/script&gt;    &lt;script&gt;        $(function () {            // 1.监听span的点击事件            $(&quot;span&quot;).click(function () {                $(&quot;.ad&quot;).remove();            });            // 2.执行广告动画            /*            $(&quot;.ad&quot;).slideDown(1000, function () {                $(&quot;.ad&quot;).fadeOut(1000, function () {                    $(&quot;.ad&quot;).fadeIn(1000);                });            });            */            $(&quot;.ad&quot;).stop().slideDown(1000).fadeOut(1000).fadeIn(1000);        });    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;ad&quot;&gt;    &lt;img src=&quot;images/ad-pic.png&quot; alt=&quot;&quot;&gt;    &lt;span&gt;&lt;/span&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;对联广告&quot;&gt;&lt;a href=&quot;#对联广告&quot; class=&quot;headerlink&quot; title=&quot;对联广告&quot;&gt;&lt;/a&gt;对联广告&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>17 - 折叠菜单练习，下拉菜单练习</title>
    <link href="http://yoursite.com/2019/10/23/17%20-%20%E6%8A%98%E5%8F%A0%E8%8F%9C%E5%8D%95%E7%BB%83%E4%B9%A0%EF%BC%8C%E4%B8%8B%E6%8B%89%E8%8F%9C%E5%8D%95%E7%BB%83%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/10/23/17 - 折叠菜单练习，下拉菜单练习/</id>
    <published>2019-10-23T08:17:29.506Z</published>
    <updated>2019-10-16T06:16:01.808Z</updated>
    
    <content type="html"><![CDATA[<h4 id="折叠菜单"><a href="#折叠菜单" class="headerlink" title="折叠菜单"></a>折叠菜单</h4><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;43-折叠菜单下&lt;/title&gt;    &lt;style&gt;        *{            margin: 0;            padding: 0;        }        .nav{            list-style: none;            width: 300px;            margin: 100px auto;            /*border: 1px solid #000;*/        }        .nav&gt;li{            border: 1px solid #000;            line-height: 35px;            border-bottom: none;            text-indent: 2em;            position: relative;        }        .nav&gt;li:last-child{            border-bottom: 1px solid #000;            border-bottom-right-radius: 10px;            border-bottom-left-radius: 10px;        }        .nav&gt;li:first-child{            border-top-right-radius: 10px;            border-top-left-radius: 10px;        }        .nav&gt;li&gt;span{            background: url(&quot;images/arrow_right.png&quot;) no-repeat center center;            display: inline-block;            width: 32px;            height: 32px;            position: absolute;            right: 10px;            top: 5px;        }        .sub{            display: none;        }        .sub&gt;li{            list-style: none;            background: mediumpurple;            border-bottom: 1px solid white;        }        .sub&gt;li:hover{            background: red;        }        .nav&gt;.current&gt;span{            transform: rotate(90deg);        }    &lt;/style&gt;    &lt;script src=&quot;js/jquery-1.12.4.js&quot;&gt;&lt;/script&gt;    &lt;script&gt;        $(function () {            // 1.监听一级菜单的点击事件            $(&quot;.nav&gt;li&quot;).click(function () {                // 1.1拿到二级菜单                var $sub = $(this).children(&quot;.sub&quot;);                // 1.2让二级菜单展开                $sub.slideDown(1000);                // 1.3拿到所有非当前的二级菜单                var otherSub = $(this).siblings().children(&quot;.sub&quot;);                // 1.4让所有非当前的二级菜单收起                otherSub.slideUp(1000);                // 1.5让被点击的一级菜单箭头旋转                $(this).addClass(&quot;current&quot;);                // 1.6让所有非被点击的一级菜单箭头还原                $(this).siblings().removeClass(&quot;current&quot;);            });        });    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;ul class=&quot;nav&quot;&gt;    &lt;li&gt;一级菜单&lt;span&gt;&lt;/span&gt;        &lt;ul class=&quot;sub&quot;&gt;            &lt;li&gt;二级菜单&lt;/li&gt;            &lt;li&gt;二级菜单&lt;/li&gt;            &lt;li&gt;二级菜单&lt;/li&gt;            &lt;li&gt;二级菜单&lt;/li&gt;            &lt;li&gt;二级菜单&lt;/li&gt;        &lt;/ul&gt;    &lt;/li&gt;    &lt;li&gt;一级菜单&lt;span&gt;&lt;/span&gt;        &lt;ul class=&quot;sub&quot;&gt;            &lt;li&gt;二级菜单&lt;/li&gt;            &lt;li&gt;二级菜单&lt;/li&gt;            &lt;li&gt;二级菜单&lt;/li&gt;            &lt;li&gt;二级菜单&lt;/li&gt;            &lt;li&gt;二级菜单&lt;/li&gt;        &lt;/ul&gt;    &lt;/li&gt;    &lt;li&gt;一级菜单&lt;span&gt;&lt;/span&gt;        &lt;ul class=&quot;sub&quot;&gt;            &lt;li&gt;二级菜单&lt;/li&gt;            &lt;li&gt;二级菜单&lt;/li&gt;            &lt;li&gt;二级菜单&lt;/li&gt;            &lt;li&gt;二级菜单&lt;/li&gt;            &lt;li&gt;二级菜单&lt;/li&gt;        &lt;/ul&gt;    &lt;/li&gt;    &lt;li&gt;一级菜单&lt;span&gt;&lt;/span&gt;        &lt;ul class=&quot;sub&quot;&gt;            &lt;li&gt;二级菜单&lt;/li&gt;            &lt;li&gt;二级菜单&lt;/li&gt;            &lt;li&gt;二级菜单&lt;/li&gt;            &lt;li&gt;二级菜单&lt;/li&gt;            &lt;li&gt;二级菜单&lt;/li&gt;        &lt;/ul&gt;    &lt;/li&gt;    &lt;li&gt;一级菜单&lt;span&gt;&lt;/span&gt;        &lt;ul class=&quot;sub&quot;&gt;            &lt;li&gt;二级菜单&lt;/li&gt;            &lt;li&gt;二级菜单&lt;/li&gt;            &lt;li&gt;二级菜单&lt;/li&gt;            &lt;li&gt;二级菜单&lt;/li&gt;            &lt;li&gt;二级菜单&lt;/li&gt;        &lt;/ul&gt;    &lt;/li&gt;    &lt;li&gt;一级菜单&lt;span&gt;&lt;/span&gt;        &lt;ul class=&quot;sub&quot;&gt;            &lt;li&gt;二级菜单&lt;/li&gt;            &lt;li&gt;二级菜单&lt;/li&gt;            &lt;li&gt;二级菜单&lt;/li&gt;            &lt;li&gt;二级菜单&lt;/li&gt;            &lt;li&gt;二级菜单&lt;/li&gt;        &lt;/ul&gt;    &lt;/li&gt;    &lt;li&gt;一级菜单&lt;span&gt;&lt;/span&gt;        &lt;ul class=&quot;sub&quot;&gt;            &lt;li&gt;二级菜单&lt;/li&gt;            &lt;li&gt;二级菜单&lt;/li&gt;            &lt;li&gt;二级菜单&lt;/li&gt;            &lt;li&gt;二级菜单&lt;/li&gt;            &lt;li&gt;二级菜单&lt;/li&gt;        &lt;/ul&gt;    &lt;/li&gt;    &lt;li&gt;一级菜单&lt;span&gt;&lt;/span&gt;        &lt;ul class=&quot;sub&quot;&gt;            &lt;li&gt;二级菜单&lt;/li&gt;            &lt;li&gt;二级菜单&lt;/li&gt;            &lt;li&gt;二级菜单&lt;/li&gt;            &lt;li&gt;二级菜单&lt;/li&gt;            &lt;li&gt;二级菜单&lt;/li&gt;        &lt;/ul&gt;    &lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h4 id="下拉菜单"><a href="#下拉菜单" class="headerlink" title="下拉菜单"></a>下拉菜单</h4><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;44-下拉菜单&lt;/title&gt;    &lt;style&gt;        *{            margin: 0;            padding: 0;        }        .nav{            list-style: none;            width: 300px;            height: 50px;            background: red;            margin: 100px auto;        }        .nav&gt;li{            width: 100px;            height: 50px;            line-height: 50px;            text-align: center;            float: left;        }        .sub{            list-style: none;            background: mediumpurple;            display: none;        }    &lt;/style&gt;    &lt;script src=&quot;js/jquery-1.12.4.js&quot;&gt;&lt;/script&gt;    &lt;script&gt;        $(function () {            /*            在jQuery中如果需要执行动画, 建议在执行动画之前先调用stop方法,然后再执行动画            */            // 1.监听一级菜单的移入事件            $(&quot;.nav&gt;li&quot;).mouseenter(function () {                // 1.1拿到二级菜单                var $sub = $(this).children(&quot;.sub&quot;);                // 停止当前正在运行的动画：                $sub.stop();                // 1.2让二级菜单展开                $sub.slideDown(1000);            });            // 2.监听一级菜单的移出事件            $(&quot;.nav&gt;li&quot;).mouseleave(function () {                // 1.1拿到二级菜单                var $sub = $(this).children(&quot;.sub&quot;);                // 停止当前正在运行的动画：                $sub.stop();                // 1.2让二级菜单收起                $sub.slideUp(1000);            });        });    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;ul class=&quot;nav&quot;&gt;    &lt;li&gt;一级菜单        &lt;ul class=&quot;sub&quot;&gt;            &lt;li&gt;二级菜单&lt;/li&gt;            &lt;li&gt;二级菜单&lt;/li&gt;            &lt;li&gt;二级菜单&lt;/li&gt;            &lt;li&gt;二级菜单&lt;/li&gt;            &lt;li&gt;二级菜单&lt;/li&gt;            &lt;li&gt;二级菜单&lt;/li&gt;            &lt;li&gt;二级菜单&lt;/li&gt;        &lt;/ul&gt;    &lt;/li&gt;    &lt;li&gt;一级菜单&lt;/li&gt;    &lt;li&gt;一级菜单&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;折叠菜单&quot;&gt;&lt;a href=&quot;#折叠菜单&quot; class=&quot;headerlink&quot; title=&quot;折叠菜单&quot;&gt;&lt;/a&gt;折叠菜单&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
