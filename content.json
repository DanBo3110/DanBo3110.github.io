[{"title":"WebGIS应用分析 [Ⅰ]","date":"2020-02-18T11:09:22.126Z","path":"2020/02/18/WebGIS应用分析 [Ⅰ]/","text":"智能交通管理指挥调度系统 主题：智能交通管理系统 C/S模式的管理系统： 功能单一 冗余大 缺少集成 效率低 局限性强（局域网） B/S系统（WebGIS）旨在解决C/S中存在的已知问题。 B/S模式的管理系统： 访问范围广泛 平台独立 平衡高效的计算负载 良好的可扩展性 系统功能 地图管理及交通状况监视功能。 对地图图层的管理 基本的地图操作 道路交通流状况显示与分析 检测并报警 视频监视功能 查看交通实时监控 自动弹出与报警地点相关的视频图像 指挥调度时，实时点击视频标记查看实时视频图像 信息诱导功能 诱导屏分组管理 发布诱导信息 评价诱导信息 诱导信息屏群组优化及信息发布 动/静态交通组织及预案管理 对活动或灾害等的预案生成、修改、实施及辅助决策 预案管理及评价 指挥调整 通过GPS系统实时调度警力配置 实时调整监控 发布实时诱导信息及调整信号控制 其他 系统管理 日志管理 WebGIS功能设计 显示层（用户层） 向Web服务器发送查询等请求 接收服务器返回的HTML Web服务层 Web服务器（IIS、Apache、tomcat）内置系统有关交通管理的专业组件（路况评价，交通流仿真等） 接收显示层的请求，并封装请求为命令发送给WebGIS服务器 接受返回的信息在组件中进行处理，将结果返回给显示层 WebGIS服务层 接收上层命令，与数据库交互。 返回为用户地理信息GIS服务，实现用户与服务器的动态交互 负载平衡、服务管理 数据资源层 通过网络连接并集成异构分布的计算资源、数据服务器、文件系统等 XML进行数据交换（目前使用Geojson合适） Oracle9i实现数据存储与管理 ArcGIS作为GIS开发工具 ArcSDE实现对空间数据的管理 ArcIMS实现WebGIS功能 开发环境为.NET 开发语言为C#","tags":[]},{"title":"计算机地图制图 知识总结","date":"2020-01-11T06:57:12.345Z","path":"2020/01/11/计算机地图制图 知识总结/","text":"第一章1. 计算机制图的概念 P1 数字地图，电子地图的概念（PPT），区分，名词解释 计算机地图制图（数字地图制图）：以传统的地图制图原理为基础，以计算机为工具，采用数据库技术和图形数据处理方法，实现地图信息的采集、存储、处理、显示和绘图的应用科学。实质: 从图形（连续）转换为数字（离散），经过一定处理，再由数字转换为图形的过程。 数字地图：一定坐标系内，空间数据 + 属性标志的离散数据，以数字形式存储的数据 。 电子地图：利用计算机技术，以数字方式存储和查阅的地图，数字地图在屏幕上显示的地图。 模拟地图（传统地图）：电子地图在一定比例尺下出图，打印成纸质地图。 2. 计算机制图的优点 P2 易于编辑更新，交互性强：固定成型，按需修改 提高绘图速度和精度：计算机制图，无主观偏差 易于存储，容量大，降低了成本：计算机存储，不变形，减少工作强度，降低印刷费用 丰富了地图品种：坡度图，晕渲图 便于信息共享：复制传播 动态调整载负量：太小信息量不足，无极缩放 3. 计算机制图的构成 P6 硬件 - 各种设备-物质基础 输入设备：键盘、鼠标、数字化仪（跟踪式、扫描式）扫描仪 输出设备：图形显示终端、打印机、绘图仪 设 备 图形输出方式 精度 特 点 矢量绘图机 矢量线划 高 绘制线划图；进行刻图等 喷墨打印机 网格点阵 高 彩色地图和影像地图 高分辨率彩显 屏幕像元点阵 一般 实时显示GIS的各种图形、图像产品 行式打印机 字符点阵 差 以打印字符输出各类地图。 胶片拷贝机 光栅 较高 将屏幕图形复制至胶片，用于制作幻灯片和正胶片。 软件 - 支持数据采集、存储、加工、回答用户问题的计算机程序系统 计算机系统软件 计算机制图数据库软件 计算机地图制图应用软件 制图数据 - 系统分析与处理的对象、构成系统的应用基础 地理要素空间数据 地理要素属性数据 地理要素空间关系 地图符号库 地图注记 元数据 制图人员 - GIS服务的对象，分为一般用户和从事建立、维护、管理和更新的高级用户 4. 计算机制图的基本过程 P13 数据获取 二 –》1 数据处理 预处理 投影变换 图形处理 制图综合 符号化 数据输出 普通地图 专题地图 统计图表 5. 计算机制图与地理信息系统（CAD）之间的区别联系 P18 与GIS 都是基于空间数据库的空间信息的表达、显示和处理。 计算机地图制图是地理信息系统的一部分； GIS是计算机地图制图之上的超结构。 名称 制图 GIS 模型 位置＋符号 位置＋符号＋属性 数据管理 地图数据库 空间数据库、关系数据库 应用 输出地图 输出地图，提供空间对象供用户使用，查询检索和分析决策 CAD CAD和GIS都有坐标参考系统，CAD的是相对坐标，没有空间意义，不能空间分析。地图制图是对空间数据的处理，是有坐标的。 计算机辅助制图多为规则的几何图形或组合，图形及其关系更复杂，空间数据和属性数据的相互操作频繁，空间数据的处理和符号化功能较强，属性功能相对较弱； CAD是平面设计软件，建筑行业频繁使用的软件。 第二章 数据采集1. 数字地图的数据源有哪些？怎么获取？地图数据 ，遥感数据， 文本数据，统计数据 实测数据，多媒体数据，已有地图数据库… 几何数据采集： 已有数字数据：转换后输入数据库 外野测量获取的几何数据：预处理（平板测量、全野外数字测图、空间定位测量）后导入地图数据库 遥感影像数据：预处理（几何纠正、图像变换、影响分类、特征提取） 纸质地图：地图数字化（手扶跟踪数字化、扫描矢量化） 摄影测量方法：摄影测量包括航空摄影测量和地面摄影测量 属性数据采集： 键盘，人机对话 程序批量输入 2. GIS里面矢量、栅格数据矢量数据结构和栅格数据结构是两种地图空间数据结构。 矢量数据结构：通过记录坐标的方式尽可能精确地理实体，坐标空间设为连续，允许任意位置、长度和面积的精确定义。特点：定位明显，属性隐含 栅格数据结构：将地表划分成为紧密相邻的网格阵列。每个网格的位置由行列号定义，并包含一个代码，以表示该网格的属性。特点：属性明显，定位隐含 如何选择？ 栅格结构：利于叠加分析。大范围小比例尺的自然资源、环境、农林业等区域问题的研究。 矢量结构：表达事物比较精细。城市分区或详细规划、土地管理、公用事业管理等方面的应用。 3. 数据质量数据的质量包括五个方面： 位置（几何）精度：如数学基础、平面精度、高程精度等，用以描述几何数据的误差。 属性精度：如要素分类的正确性、属性编码的正确性、注记的正确性等，用以反映属性数据的质量。 完备性：如数据分类的完备性、实体类型的完备性、属性数据的完备性、注记的完整性，数据层完整性，检验完整性等。 现势性：如数据的采集时间、数据的更新时间等。 逻辑一致性：如多边形的闭合精度、结点匹配精度、拓扑关系的正确性等，由几何或属性误差也会引起逻辑误差。 质量的控制： 误差带法：该方法适用于任何类型的GIS数据，关键是如何给出合理的ε值。 对比法：把数字化后的数据，用绘图机绘出，与原图叠合，选择明显地物点进行量测，以确定误差。 相关法：依据地图要素自身的相关性来分析数据的质量。如河流与等高线的套合程度。 第五章 P1031. 数据预处理坐标变换，数据压缩，数据匹配 坐标变换 几何纠正 投影变换 数据压缩 主要对象：现状要素中心轴线和面状要素边界数据 间隔取点法 垂距法 偏角法 道格拉斯普克法 光栏法 数据匹配：实现误差纠正。 顶点匹配 数字接边 2. 几何纠正P105 性质，什么情况使用哪个，有多少个未知数，道理是啥。 高次变换（多项式拟合法、非线性形变）：12个未知数，需要6对以上控制点坐标 二次变换（多项式拟合法、非线性形变）：10个未知数，需要5对以上控制点坐标。适用于原图有非线性变形 一次变换：6个未知数，需要不在一条直线上的3对以上控制点坐标。由于误差，需要多观测一组。一共需要四对控制点坐标 同素变换：复杂的变换方式 特点： 直线变换后仍为直线 平行线变换后为直线束 同一线束中任一割线的交叉比保持不变 同一割线上相应个点的线束的交叉比保持不变 仿射变换：只考虑x方向和y方向上的变形。（经过对坐标的缩放，旋转，平移后原坐标在新坐标域中的值） 特点： 直线变换后仍为直线 平行线变换后仍为平行线，长度比不变 不同方向上的长度比发生变化 3. 投影变换（转换的思想） 解析变换：找出两投影间坐标变换的解析计算公式 正解变换：将具有经纬度的地理坐标转换为直角坐标系下的坐标 反解变换：将具有直角坐标系下的坐标转换为经纬度 数值变换：在不易求出两投影坐标之间的直接关系，采用多项式逼近建立公式。20个未知数，10个控制点坐标 数值解析变换：已知新的投影公式，但不知道原投影公式，可选择通过数值变化求出原投影点的地理坐标，然后代入新投影公式中，求出新投影点的坐标。 4. 数据压缩压缩条件： 保持曲线的形状特征 保持密度对比 保持转折点的精度 保持空间关系正确 道格拉斯普克法：（画图，思路）对给定曲线的首末点虚连一条直线，求中间所有点与直线间的距离，并找出最大距离dmax，用dmax与限差 L比较。dmax ≥L，保留对应点，以该点为界将曲线分为两段，对每一段重复使用该方法。dmax&lt;L，舍去所有中间点。 光栏法：（画图，思路，简单说）定义一个扇形区域，通过判断曲线上的点在扇形外还是在扇形内，确定保留还是舍去。 5. 图形编辑P110 地图开窗：按照用户指定的空间范围，进行图形子集的选取。这个指定的范围被称为窗口 正开窗：选取整个图形数据在窗口内的子集合 负开窗：选取整个图形数据在窗口外的子集合 点的选取：计算C和P之间的距离是否小于限差 线的选取：通过计算光标点C到该线的每条线段的距离d，与搜索半径D比较。如果d&lt;D，则认为找到；反之则未成功。 面的选取：铅垂线法：从待判别点引铅垂线，由该铅垂线（注意：是一条射线）与多边形交点个数的奇偶性来判断点是否在多边形内。 步骤： 第一步，计算多边形最小投影矩形，若点在最小投影矩形外，则点一定在多边形外，算法结束；否则执行第二步。 第二步，设置记录交点个数的计数器Num=0。 第三步，从待判断的点作铅垂线，顺次判断该铅垂线与多边形各边是否相交，若相交，求出交点并记录下来。每有一次相交，把Num数值增加1。 第四步，若Num为偶数，则该点在多边形外；否则，该点在多边形内。算法结束。 异常情况： 交点位于多边形顶点：若在同侧，Num不变，否则Num加1。 铅垂线与多边形的一条边重合：若在同侧，Num不变，否则Num加1。 6. 几何变换 P114 二维变换矩阵 平移变化：只改变图形的位置，不改变图形的大小和形状 比例变换： 以坐标原点为放缩参照点。 当Sx=Sy=1时：恒等比例变换。 当Sx=Sy&gt;1时：沿x,y方向等比例放大。 当Sx=Sy&lt;1时：沿x,y方向等比例缩小。 当SxSy时：沿x,y方向作非均匀的比例变换，图形变形。 当Sx=1，Sy=－1，关于X轴的对称变换。 当Sx=－1，Sy=1时，为关于Y轴的对称变换。 当Sx=Sy=－1，为关于坐标原点的对称变换。 对称变换： 当d=b=0,a=-1,e=1时，(x* y* 1)=(-x y 1)：与y轴对称的反射变换。 当d=b=0,a=1,e=-1时，(x* y* 1)=( x -y 1)：与x轴对称的反射变换。 当d=b=0,a=e=-1时，(x* y* 1)=(-x -y 1)：与原点对称的反射变换。 当d=b=1,a=e=0时，(x* y* 1)=(y x 1)：与y=x对称的反射变换。 当d=b=-1,a=e=0时，(x* y* 1)=(-y -x 1)：与y=-x对称的反射变换 旋转变换： 错切变换：错切变换引起图形角度关系的改变，甚至导致图形发生变形 当b=0时， (x* y* 1)=(x+by y 1)：图形的y坐标不变； 当d&gt;0：图形沿+x方向作错切位移。ABCD→A1B1C1D1 当d&lt;0：图形沿-x方向作错切位移。ABCD→ A2B2C2D2 复合变换：指在XY平面内，对一个已定义的图形，按一定顺序进行多次变换而得到新的图形，也即对图形做一次以上的几何变换。注意：任何一个线性变换都可以分解为上述几类变换。 ​ 7. 矢量数据向栅格数据转换 P123（简答）矢量转栅格：栅格数据分辨率和栅格数的确定 点的栅格化：实质上是将点的矢量坐标转换成栅格数据中行列值i和j，从而得到点所在栅格元素的位置。 线的栅格化：当折线上取点足够多时，所画的折线在视觉上成为曲线。实质上是完成相邻两点之间直线的转换。若已知一直线AB其两端点坐标分别为A(x1，y1)和B(x2，y2)，则其转换过程不仅包括坐标点A，B分别从点矢量数据转换成栅格数据，还包括求出直线AB所经过的中间栅格数据。八方向栅格化、分带法、恒密度栅格化 面的栅格化：使矢量表示的多边形内部所有栅格用多边形的属性填充，形成栅格数据集合。内部点扩散法、射线算法、扫描算法边界代数算法 第六章 栅格数据的处理1. 栅格图像平移 P128平移、算术运算、逻辑运算、宏运算 看懂 灰度级变换：对每一像素的灰度级进行变换，扩大图像灰度的范围，达到图像增强的目的。 平移：原始的栅格影像按照一定的方向平移确定的像元数目。 算术组合：两个栅格图像相互叠置，对应的像元灰度值相加、相减、相乘等 逻辑组合：对应的像元灰度进行逻辑运算，或，与，非，异或 宏运算 扩张：向指定的方向和给定的像元数据进行扩张，平移同时做或运算 例：向右平移一个像元 侵蚀：向侵蚀方向移动确定的像元格 加粗：分为四方向和八方向 减细：加粗的逆运算 填充 逐步蔓延加粗法：让单个像元作为填充胚，在给定的区域范围内，通过某种方法进行蔓延，最终填充满整个多边形区域。四邻法、八邻法 逐行填充法：对种子所在的行进行填充，在每次填充一行后，应搜索该行的上下两侧以确定新的种子，对于相互连通的一侧，只需一个种子，并将其放入栈中。 2. 栅格数据向矢量数据转换的算法 P139栅格转矢量：注意：1.拓扑转换 2.转换正确的外形 点的矢量化： 线的矢量化：实质：将具有相同属性值的连续的单元格搜索出来，最后得到细化的一条线。具体实施：先将具有一定粗细的栅格数据先进行细化，使其最后成为单像素的线段，然后进行矢量化。两种算法思想：细化矢量化和非细化矢量化 多边形的矢量化：实质：将具有同一属性的单元归为一类，再检测两类不同属性的边界作为多边形的边，提取以栅格集合表示的区域边界和边界的拓扑关系。 一般过程：栅格数据的二值化、多边形边界提取和细化、多边界跟踪、去除多余及曲线光滑、矢量数据转换的过程 二值化。栅格数据是按0～255的不同灰度值表达的。为了简化追踪算法，将256个灰阶压缩为2个灰阶，即0和1两级。 边界提取和细化。使每一条线只保留代表其轴线或周围轮廓线（对多边形而言）位置的单个栅格的宽度。 边界跟踪。把细化后的栅格数据整理为从结点出发的线段或闭合的线条，并以矢量形式加以存储。 曲线化简及光滑 。直接提取的边界线节点密集、有明显的抖动锯齿感，需进行化简及光滑处理。 生成拓扑关系，建立节点、弧段及多边形间的连接关系。 第七章 地图符号1. 地图符号和地图符号化的概念地图符号：地图的主要表达形式，它是地图区别于其他表示地理环境方法的一个重要特征。地图符号不仅能反映地图要素的存在、类别及其数量和质量特征，而且通过他们的组合，还能反映出地理要素的空间分布、结构、联系以及变化等。 地图符号化：地图数据的符号化，两层含义： 在地图设计工作中，指利用符号将地图数据进行分类、分级、概括、抽象的过程； 在数字地图转换为模拟地图的过程中，指将已处理好的矢量地图数据恢复成可见的图形，并附之以不同符号表示的过程。 编程法 信息法 直接信息法：直接表示符号图形的各个细部，在信息块中直接存储符号图形的矢量数据或栅格数据 间接信息法：信息块中不直接存储符号图形数据，而只存储符号图形的几何参数 2. 符号绘制 P2143. 地图符号库采用的算法矢量符号库：信息块法，程序块法，综合法 栅格符号库：信息块法 信息块法：用人工或程序将要绘制的符号里的坐标信息，用统一的结构和方法进行描述，这些描述信息存放在数据文件中形成符号库。 程序块法：对每一类地图符号编写一个绘图子程序，由这些子程序组成符号库。绘图时按照符号的编号调用库中相应的程序，输入相应参数，由程序根据参数及已知数据计算矢量，从而完成地图符号的绘制。 综合法：其实质是把信息块法和程序法结合在一起，绘制组合式符号。 4. 点符号的生成算法 P215 点状符号信息块法 程序块法 任何圆都可以用正多边形来逼近，边数越多，圆越光滑。 以圆弧的起始点坐标，圆弧的起始角、圆弧的终止角、圆弧的起始点半径和终止点半径为参数设计绘圆程序，这个程序就既能绘制圆也能绘制圆弧和螺线。 以椭圆的起始点坐标、长半轴、短半轴、长半轴与 x 轴的夹角、起始点和终止点到中心点连线分别于x轴的夹角为参数来设计绘制椭圆的程序，这个程序就能绘制椭圆，也能绘制椭圆弧并调整椭圆长轴的方向。 5. 线符号的生成算法，线状符号信息块法、土堤符号绘制原理 P219 信息块法：把各类线状符号看作是由符号单元沿线状要素中轴线重复串接而成。 程序块法： 解决两个问题： 确定每一条短横线的位置，确定横短线与中轴线的交点坐标 确定横短线两端点的坐标 6. 面符号信息块法 信息块法：存储的是填充符号的单元信息，结构类似线状符号中线—线信息块，但需要增加三种信息：行距、行向倾角（晕线与x轴夹角）、排列方式（“井”型、交错和散列）。 程序法： 填充点状符号算法 填充线状符号算法 算法总体思路:计算所填绘的每条线符与多边形的交点，然后调绘线符绘制程序在两交点间绘制出所要求的线符即可。 第八章 数字表面模型1. DEM和数字地面模型（DTM）的区别数字正射影像(DOM) 数字地面模型(DTM)，是要素的平面坐标(x，y)和其他性质的数据集合。如果此属性是高程z，则此数字地面模型又称为数字高程模型(DEM)。 DEM是建立DTM的基础数据。 实际上DTM不仅包含高程属性，还包含其它的地表形态属性，如坡度、坡向等。 DEM和DTM主要用于描述地面起伏状况，可以用于提取各种地形参数，如坡度、坡向、粗糙度等，并进行通视分析、流域结构生成等应用分析。 DEM可以有多种表达方法，包括网格、等高线、三角网等。 2. Delaunay三角网、泰森多边形的概念，关系。 定义： 不规则三角网（TIN）：由一系列相连的但不重叠的三角形的集合, 而且这些三角形的外接圆不包含这个面域的其他任何点。存储表达：对于每一个三角形、边和节点都对应一个记录。 Delaunay三角网：表示数字高程模型的方法，它既减少规则格网方法带来的数据冗余，同时在计算（如坡度）效率方面又优于纯粹基于等高线的方法。 泰森多边形—冯洛诺伊图（Voronoi diagram）：指用不规则的小面块来逼近和模拟自然界不规则地理单元的一种方法。对Delaunay三角网的各个边做中垂线，中垂线上的顶点相连就构成了泰森多边形。 关系：Voronoi图（泰森多边形） 和 Delaunay三角形 互为对偶图 3. 三角网的特点，性质。 Delaunay三角网特性：1）其Delaunay三角网是唯一的；2）三角网的外边界构成了点集P的凸多边形“外壳”；3）没有任何点在三角形的外接圆内部，反之，如果一个三角网满足此条件，那么它就是Delaunay三角网。4）如果将三角网中的每个三角形的最小角进行升序排列，则Delaunay三角网的排列得到的数值最大，从这个意义上讲，Delaunay三角网是“最接近于规则化”的三角网。 Delaunay三角形性质（基本准则）：1) 外接圆准则：任何一个Delaunay三角形的外接圆的内部不能包含其它任何点。2) 最大化最小角原则：每两个相邻的三角形构成的凸四边形的对角线，在相互交换后，六个内角的最小角不再增大。3) 局部优化准则：先求出包含新插入点p的外接圆的三角形，这种三角形称为影响三角形。删除影响三角形的公共边，将p与全部影响三角形的顶点连接，完成p点在原Delaunay三角形中的插入。 4. 泰森的应用范围，应用场景，多边形特征 泰森多边形应用范围： 泰森多边形可用于定性分析、统计分析、邻近分析等。 例如，可以用离散点的性质来描述泰森多边形区域的性质；可用离散点的数据来计算泰森多边形区域的数据；判断一个离散点与其它哪些离散点相邻时，可根据泰森多边形直接得出，且若泰森多边形是n边形，则就与n个离散点相邻；当某一数据点落入某一泰森多边形中时，它与相应的离散点最邻近，无需计算距离。 泰森多边形特点 多边形的边总垂直平分两个邻接采样点的连线 多边形内任何位置总是离该多边形内样点的距离最近，离相邻多边形内样点最远 每个多边形内只有一个点 泰森多边形内部的顶点必有3条边同它连接，这些边相邻的3个三多边形的两两拼接的公共边 泰森多边形内部的顶点周围有3个离散数据点，将其连成三角形后，该三角形的外接圆心即为该顶点 3. 如何用点集生成TIN不规则点集生成TIN 凸包生成 min(x-y)、min(x+y)、max(x-y)、max(x+y)的四个点构成的多边形作为初始凸包。 对于每个凸包上的点I，设它的后续点为J，计算矢量线段IJ右侧的所有点到IJ的距离，求出距离最大的点K。 将K插入I、J之间，并将K赋给J。 当凸包中任意相邻两点连线的右侧不存在离散点时，结束点集凸包求取过程。 环切边界法凸包三角剖分 在凸包链表中每次寻找由相邻两条凸包边组成的三角形 该三角形的内部和边界上都不包含凸包上的任何其它点。 将这个点去掉后得到新的凸包链表。 重复这个过程，直到凸包链表中只剩三个离散点为止。 将凸包链表中的最后三个离散点构成一个三角形，结束凸包三角剖分过程。 完成将凸包中的点构成了若干Delaunay三角形。 离散点内插(局部优化准则) 三角剖分之后，不在凸包上的其余离散点，可采用逐点内插的方法进行剖分。 找出外接圆包含待插入点的所有三角形，构成插入区域。 删除插入区域内的三角形公共边，形成由影响三角形顶点构成的多边形。 将插入点与多边形所有顶点相连，构成新的Delaunay三角形。 重复1、2、3，直到所有非凸壳离散点都插入完为止。 完成了Delaunay三角网的构建。 4. 蒂洛尼三角网–空壳 (PPT)点集P的空集的交集 第三、四章 地图的设计和制作1. 色彩 P83 设色的要求P87 地图的色彩应与地图的性质、用途相协调 地图的色彩应层次分明突出重点内容 充分利用色彩的感觉和象征性 地图色彩应系统协调突出特色 色彩在地图的应用和设计 P88-P102 色彩三要素 色相（色别、色种） 明度（亮度） 纯度（饱和度、彩度、鲜艳度） 地图色彩的类别 点状色彩 线状色彩 面状色彩（质别底色、区域底色、色级底色、衬托底色） 注记色彩 地图设计中的色彩设计 点状符号的色彩设计 线状符号的色彩设计 面状符号的色彩设计 根据性质选用色值 同类元素应在同一色系中选色 面状色之间协调选色 面状色应选用柔和的色值 应用： 行政区划图的色彩设计 总体用同一色系，分区用多色相，避免用原色 分层设色法的色彩设计 运用色彩视觉心理特性 色彩过渡自然 注意等值线的色彩 色彩对比的应用 色彩明度对比的应用：清晰感、层次感、节奏感、空间感、多样统一美 色相对比的应用 纯度对比的应用 应用： 地图层次设计中色彩对比手法的综合运用： 冷暖对比 纯度对比 明度对比 地图色彩在地图制作中如何运用和设计的？ 分区用多色相，避免用原色 运用色彩视觉心理特性 色彩过渡自然 注意等值线的色彩 色彩的作用 色彩的运用简化了图形符号系统 丰富了地图内容，提高了地图传递空间信息的容量 提高地图内容表现的科学性 改善地图语言的视觉效果 提高地图的审美价值 色彩的设计使用色彩可提高地图的表现力及清晰度，还可增强地图的艺术性。首先确定图幅或图组的主色调，然后再进入局部的色彩设计，地图色彩设计具有不确定性和多义性。特别忌讳孤立地对待某一种色彩，而不顾及周围的色彩对它的影响。设计时必须从整体出发来选用色彩、确定色彩构成的协调关系。 点符号点状符号设计的特点： 表示呈点状分布的专题要素 表示顺序分级、间隔分级和数值表示的呈线状和呈面状分布的专题要素 表示专题要素的定性特征、分类特征 表示出专题要素的数量特征、分级特征。 设计的规律和方法： 不同的色相表示现象的类别即质量特征。 尽量与实物的固有色或心理印象色相似，便于读者引起联想。 线符号在地图中起骨架作用，是地图信息的主要载体。由于线状符号十分狭窄细长，只有通过色彩的加重表示，才能将线状符号凸显出来。 设色： 主要界线色彩要“鲜、浓、深、粗”，如大红、黑色等，次要界线色彩要“灰、淡、浅、细”，如浅绿、浅褐等。 对于交通线、河流、海岸线等线状符号，若属专题要素则按主要界线色彩处理，若属底图要素则依次要界线色彩处理。 面符号区分层次，选用不同的色值。 设色： 对于分级统计图，分级数≤4时，用单色系列，即用一个色相的不同浓淡逐渐过渡； 分级数≥5时，可用多色系列，即色阶中包含2个或更多的色相。 数量等级高的用饱和度高的颜色，数量等级低的用饱和度低的颜色。 应用： 分层设色主要考虑色彩的象征意义，例如地势图中用橙色到紫色的过渡表示山地的起伏。 范围法设色，若反映质量差别以对比色为主，反映不同时期范围的以类比色为主，兼顾现象的象征意义。如易涝区用冷色表示，易旱区用暖色表示 区域底色设色应浅淡。 衬托底色设色应选择不饱和的原色，突出其他专题要素，不给读者刺目的感觉。 色彩配合原则 先选定面积色的主调，再选符号色； 面积色与符号色的色相最好属对比色关系，也可以是邻近色关系； 底图线划用色一般用中度复色。当符号表示结构或多项组合指标时，其选色要注意冷暖相间和明暗相间。 符号的设计使用主要表现为类别和层次两方面点状： 不同类型的地图要素符号系统之间的形态要有差异(横向对比设计)。 利用尺寸、结构、虚实、明度表示层级差异(纵向对比设计)。 线状： 不同类型的地图要素符号系统之间的形态要有差异(横向对比设计)。 利用宽度、明度、虚实度等反映层次，重要、等级高的线用实线、粗线表示；次要、等级低的线用虚线、细线表示(纵向对比设计)。 对于道路，河流，境界有其特殊的规范。 面状： 利用几何网纹设计出相对多的纹样，纹样越简单越好，网纹的种类不易过多(横向对比设计)。 利用网纹密度和明度的对比反映不同的层次(纵向对比设计)。 网纹线条的宽度不宜超过边界线，要注意网纹密度和网纹明度的对比。 注记的设计使用字体的不同主要用于区分不同事物的类别。图名、区域名称要求最明显突出；斜体多用于海洋、河流和湖泊。 字色可以加强分类概念，如水体用蓝色，地貌用棕色。 字号反映对象的重要性和数量等级，等级高、数量大的对象的注记应该大而明显。 字隔在某种程度上隐含了对象的分布特征(点、线、面)，最小字隔为0.2mm，最大不应超过字大的5~6倍。点状物用小字隔标记；线状物用较大字隔沿线状物注出；面状物根据其面积大小更改字隔，图形较大时应重复注记。 字位明确显示对象，注记不能离对象太远，也不能互相覆盖。 布置表示对象的走向等信息。","tags":[]},{"title":"GIS程序设计 知识总结","date":"2020-01-11T06:54:49.225Z","path":"2020/01/11/GIS程序设计 知识总结/","text":"简答1. 开发模式，开发软件的特点，概念 独立开发： 定义：不依赖于任何GIS工具软件，从空间数据的采集、编辑到数据的处理分析及结果输出，所有的算法都由开发者独立设计，然后选用某种程序设计语言，如VC++、VB、Delphi、C++ Builder等，在一定的操作系统平台上编程实现。 特点： 无需依赖任何商业GIS工具软件，减少了开发成本 综合程度和操作效率最高 单纯二次开发： 定义：在宏语言中调用DLL库，定义GIS系统工具不提供或不支持的功能， 特点： 功能弱，程序不美观，开发收到限制 增加学习负担 集成二次开发： 定义：利用专业GIS工具软件或其提供的组件来实现GIS的基本功能，采用可视化开发工具，进行集成开发。集成二次开发目前主要有OLE／DDE方式和组件式方式两种。 特点： GIS工具软件能够提供成熟的功能。例如：空间数据库存储、空间分析等 高效，便捷，不需要从底层学习具体的实现原理，易上手。 1. 基于arcengine或者arcobject 2. 基于com（原理） 2. 接口及类：特，用，概，接口应用 接口的特点： 1. 接口的多态性：许多不同的类可以支持相同的接口 2. 接口的继承性：所有的子类都继承了父类的接口 面向接口编程： 接口定义了能做什么，类定义了该怎么做。类实现了接口中的方法。 接口描述了一系列外部可见操作 接口具有类内置的一组属性和方法 Com类代码： 接口模块：定义方法和属性 类模块：实现方法和属性 COM 对象的接口是抽象的，接口与类不同。因为接口没有 任何的实现，所以不能通过自身实例化。因为接口没有任何的实现，所以不能通过自身实例化。接口由具体的类来实现由具体的类来实现，功能用接口抽象地模拟，并且用类去真正实现。 地图接口 ILayer接口:所有图层类都可以实现该接口，定义了所有图层公共的方法和属性。 Name属性:返回图层名称； MaximumScale属性:显示或设置图层可以出现的最大比例尺； MinmumScale属性:显示或设置图层可以出现的最小比例尺； ShowTips属性：指示当鼠标放在图层中某个要素上时，是否出现Tips; SpatialReference属性：设置图层的空间参考。 IFeatureLayer接口:主要用于设置要素图层的数据源（FeatureClass） DataSourceType属性：返回图层的数据源类型； Search方法：通过2个参数，过滤器（IQueryFilter类型的对象）和布尔值（用于返回要素游标是否循环，返回一个Icursor对象） IFeatureLayer接口继承自Ilayer接口，IFeatureClass接口继承自Iclass接口。 FeatureLayer可以创建自己的对象，FeatureClass不行 类 Version类库：ArcEngine 10.0新出的类库，包含里将独立应用程序绑定到特定的ArcGIS系列产品的函数和方法。 System：ystem库是ArcGIS框架中最底层的一个库，它包含了一些被其他库使用的一些基础组件。 SystemUI：SystemUI库定义了一些在ArcGIS中被用户界面组件使用的类型。象ICommand和ITool这样的接口就在这里定义。 Geometry：几何库包含了核心的几何对象，比如点，面，线等。在几何库中还定义和实现了空间参考的对象，包括投影坐标系和几何坐标系。 Display：显示库包含了支持在输出设备上显示图形的组件，屏幕显示、符号、颜色、显示交互（Feedback)等都在这个库中定义。 Server：提供了连接、管理ArcGIS Server的核心类，如IServerObjectManager、IServerObject等，其他类库的对象可以通过ArcGIS Server的IServerContext进行远程创建。 Output：提供了将MapControl和PagelayoutControl中的地图输出到打印机以及其他设备文件中。 3. 对象模型图：类和关系，分别有什么特点 类 抽象类：不能用于创建对象，对子类例程进行了规定（通过类型继承）。 普通类：不能直接创建对象，但可以作为另一个类的属性或者通过另一个类的实例化来创建对象。 组件类：可以直接创建对象。 关系 关联关系：表示类之间的关系。关联的两端都定义了多样性。 组成关系：是一种“整体类”对象控制着“部分类”对象的生命期关系。 类型继承关系：定义共享父类的属性和方法，同时又具有了自己独特的属性和方法的特定对象类。 实例化关系：表示某个类的对象具有创建另一个类的对象的方法。 N元关系：表示两个以上的类相互关联。在各个关联分支的交叉点上放置一个菱形。 多样性关系：是对能于另一个对象关联的对象数目的一种限制。关联和组成关系的两端都定义了多样性。 抽象类(AbstractClass)： 不能创建或实例化 抽象类永远不能有实例 为子类定义了泛化（general） 子类集成了抽象类的接口 抽象类的OMD 符号: 2维灰色矩形 普通类/可实例化类 (Class) 不能创建或实例化 抽象类永远不能有实例 为子类定义了泛化（general） 子类集成了抽象类的接口 IRow pNewRow； ITable pTable;pNewRow = pTable.CreateRow(); IRow row = table.CreateRow(); 实例化类的OMD符号： 3维白色的矩形 组件类/可创建的类(CoClass) 可以创建:使用 New关键字 1IMap pmap = new Map(); 实例化: 从其它对象获得 12Imap pMap;pMap = m_MapDocument.get_Map(i); 可创建类的OMD符号：3维灰色矩形 AE控件有哪些，分类特点 制图控件: MapControl 和PageLayoutControl 框架控件: TOCControl（内容表控件） 和ToolbarControl(工具条控件)–（buddy控件捆绑） 许可控件：LicenseControl（启动时执行License初始化） 符号控件:SymbologyControl Reader Control: ReaderControl和ReaderControl 三维控件：GlobeControl和SceneControl 矢量数据集相关类的关系 矢量数据数据的加载，分析，查询 接口： 1. **IWorkspaceFactory**：创建工作工厂 2. **IWorkspace**：工作化工作空间 3. **IFeatureWorkspace**：接口转换为要素工作空间 4. **IFeatureClass**：创建featureClass 5. **IFeatureLayer**：创建要素图层 6. **IMap**：接收AxMapControl中的地图对象类： ShapefileWorkspaceFactory：作为子类创建工作空间 FeatureLayer：创建要素图层用于接收打开的shpfile文件的featureClass，作为图层，只是表现形式，真正的数据在FeatureClass中。 FeatureClass是从Dataset继承过来的,FeatureClass是有空间数据字段的数据集。 程序流程（简答）1. 数据访问，添加矢量矢量加载： 获取文件路径和文件名称 创建地理空间工厂WorkspaceFactory（怎么创建） 实例化地理空间Workspace（怎么实例化） 获取FeatureClass 创建要素图层FeatureLayer 为要素图层定义数据集FeatureClass 添加至地图控件 刷新地图视图 2. 空间数据显示—图层渲染1. 抽象类：Symbol，MarkerSymbol，LineSymbol，FillSymbol 2. 组件类： 1. RgbColor：颜色 2. SimpleMarkerSymbol，SimplelineSymbol，SimplefillSymbol：简单点线面符号 3. SimpleRenderer：简单渲染 实例化ISimpleMarkerSymbol，提供简单点符号 实例化ISimpleRenderer，提供简单渲染器 获取渲染图层赋值给IGeoFeatureLayer，提供要素图层对成员控制地理特征渲染的入口,获取渲染图层 调用pGeoFeatureLayer.Renderer属性赋值渲染器 刷新地图视图 3. 元素添加至地图 获取pagelayerout对象、活动视图pActiveView、图形容器pGraphicsContainer、地图窗口MapFrame 创建UID对象，设置value 通过MapFrame的CreateSurroundFrame(uid,null)方法创建mapSurroundFrame 实例化一个区域几何envelope（包裹元素的盒子）。通过PutCoords(xmin, ymin, xmax, ymax)方法设置地图上的位置 通过mapSurroundFrame获取Element，设置框架的几何体属性Geometry为区域几何对象envelope 通过图形容器pGraphicsContainer的AddElement(Element，ZOrder)方法把地图要素添加地图布局。 刷新视图。 接口： IGraphicsContainer：管理map上的Element对象，获取图形容器 IMapFrame：访问控制地图元素对象的成员 IMapSurroundFrame：获取或更新存储在帧中的环绕对象（指北针、比例尺条或图例） IEnvelope：地物的外接矩形，用来放置元素。 IElement：通过这一属性设置该元素的外接矩形在地图上的位置。所有图形元素和框架元素都实现的接口，可以确定元素的Geometry属性。 类： UID用来设置元素类型的编码 MapFrame： 用于显示地图的图形元素。 MapSurroundFrame：用于显示地图包围的图形元素。 Envelope：包络线，是每个几何形体的最小外接矩形。每个Geometry都拥有一个Envelope Element：抽象类 12345678910111213141516171819202122232425public void add(string value,double xmin,double ymin, double xmax, double ymax)&#123; //获取图形容器 IGraphicsContainer graphicsContainer = pageLayoutControl.PageLayout as IGraphicsContainer; //根据MapSurround的uid，创建相应的MapSurroundFrame和MapSurround UID uid = new UID(); uid.Value = value; IMapFrame mapFrame = pageLayoutControl.PageLayout as IMapFrame; IMapSurroundFrame mapSurroundFrame = mapFrame.CreateSurroundFrame(uid, null); //为要素实例化一个区域几何。元素的外接矩形 envelope = new Envelope() as IEnvelope; envelope.PutCoords(xmin, ymin, xmax, ymax); //获取Element，用来设置框架的几何体属性 IElement eement = mapSurroundFrame as IElement; //geometry属性控制区域几何在地图上的位置 element.Geometry = envelope; graphicsContainer.AddElement(element, 0); activeView.Refresh(); pagelayoutcontrol.Refresh();&#125; 4. 属性查询步骤： 获取数据源FeatureClass 循环给每一列写字段名 获取查询返回的游标，null代表没有查询条件，返回整个表 用IFeature接收指针指向的数据 将指针指向第一个要素属性行 如果pFeature不为空则循环7，8，9步 获取表中的新行，并将引用赋值给DataRow 为每一个属性单元格赋值 游标指向下一行要素并重新赋值给pFeature 将DataTable赋值给dataGridView的数据源 类： QueryFilter：过滤数据通过属性值或者属性之间的关系 QueryDef：代表了数据库中基于一个或多个表、要素类的进行的属性查询，通过这个对象，用户可以在多个表间建立连接，并且保证在这个连接基础上的查询可以实现。 FeatureCursor：普通类，通过pFeatureClass.Search(filter, false);实例化 接口： IFeatureClass：数据源 IQueryFilter：用于属性查询 IFeatureCursor：查询返回的游标 IFeature：要素，返回游标中要素集单位 5. 空间查询步骤： 获取pFeatureLayer 实例化过滤器pSpatialFilter 创建geometry，用来装载框选范围 将框选几何geometry赋给pSpatialFilter 设置空间范围的查询条件（从空间查询窗体获得） 实例化查询接口pfeatureSelection 调用查询方法SelectFeatures(过滤器, esriSelectionResultEnum.esriSelectionResultNew, false);实现高亮 刷新图层 接口： IFeatureLayer：当前的要素图层，用于接口转换 ISpatialFilter：过滤器，用来设置空间范围的查询条件 IGeometry：几何类型，获取框选范围 IFeatureSelection：查询接口，用于查询，没有返回值，实现高亮 类： FeatureLayer：组件类，要素图层 SpatialFilter：组件类，过滤器 Geometry：普通类，通过mapControl.TrackRectangle();实例化，几何类型 程序设计题1. 面向接口的编程及接口转换2. 接口的继承3. 图层的显示及渲染123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109/////Shp///OpenFileDialog pOpenfileDialog = new OpenFileDialog();if (pOpenfileDialog.ShowDialog() == DialogResult.OK)&#123; string path = pOpenfileDialog.FileName; bool shp = path.EndsWith(\".shp\"); if (shp) openShpFile(path);&#125;private void openShpFile(string file)&#123; int index = 0; //获取最后一个“\\\\”时的索引位置 index = file.LastIndexOf(\"\\\\\"); //获得shp文件的路径 string filePath = file.Substring(0, index); //获得shp文件名 string fileName = file.Substring(index + 1, file.Length - (index + 1)); //由工作空间工厂创建shp工作空间工厂类 IWorkspaceFactory pWorkspaceFactory = new ShapefileWorkspaceFactory(); //打开工作空间 IWorkspace pWorkspace = pWorkspaceFactory.OpenFromFile(filePath, 0); //转换工作空间为要素工作空间 IFeatureWorkspace pFeatureWorkspace = pWorkspace as IFeatureWorkspace; //打开要素类 IFeatureClass pFC = pFeatureWorkspace.OpenFeatureClass(fileName); //创建要素图层 IFeatureLayer pFLayer = new FeatureLayer(); //设置图层的featureclass为上面打开的文件 pFLayer.FeatureClass = pFC; //设置图层的名称 pFLayer.Name = pFC.AliasName; //转换featurelayer为layer ILayer pLayer = pFLayer as ILayer; IMap pMap = mapControl.Map; //添加图层 pMap.AddLayer(pLayer); //刷新 mapControl.ActiveView.Refresh();&#125;/////渲染/////简单渲染，点符号public static void easy_point(string filename, IRgbColor point_rgb, int width)&#123; //实例化ISimpleFillSysmbol变量, 提供简单的填充符号类型 ISimpleMarkerSymbol pSimplemarkerSymbol = new SimpleMarkerSymbol(); pSimplemarkerSymbol.Color = point_rgb; pSimplemarkerSymbol.OutlineSize = width; //实例化简单渲染变量 ISimpleRenderer pSimpleRender = new SimpleRenderer(); //设置pSimpleRender的符号样式 pSimpleRender.Symbol = pSimplemarkerSymbol as ISymbol; Render_tool(pSimpleRender, filename);&#125;private static void Render_tool(ISimpleRenderer pSimpleRenderer, string filename)&#123; //提供要素图层对成员控制地理特征渲染的入口,获取渲染图层 IGeoFeatureLayer pGeoFeatureLayer = getGeoLayer(filename); if (pGeoFeatureLayer != null) //调用Renderer属性, 具体说明如何通过图层要素渲染器渲染图层 pGeoFeatureLayer.Renderer = pSimpleRenderer as IFeatureRenderer; mapControl.ActiveView.Refresh();&#125;public static IGeoFeatureLayer getGeoLayer(string layerName)&#123; ILayer pLayer; //定义图层 IGeoFeatureLayer pGeoFeatureLayer; //定义要素图层 for (int i = 0; i &lt; CSR_mapControl.LayerCount; i++) &#123; pLayer = CSR_mapControl.get_Layer(i); //若当前图层不为空且与与layerName的值相同 if (pLayer != null &amp;&amp; pLayer.Name == layerName) &#123; pGeoFeatureLayer = pLayer as IGeoFeatureLayer; return pGeoFeatureLayer; &#125; &#125; return null;&#125;/////Tiff/////工作空间实例化IWorkspaceFactory pRasterWsF = new RasterWorkspaceFactory();IWorkspace pWs = pRasterWsF.OpenFromFile(RasterPath, 0);IRasterWorkspace pRasterWs = pWs as IRasterWorkspace;IRasterDataset pRasterDS = pRasterWs.OpenRasterDataset(RasterName);//影像金字塔的判断和创建IRasterPyramid pRasterPyramid = pRasterDS as IRasterPyramid;if ((pRasterPyramid != null) &amp;&amp; (!pRasterPyramid.Present))&#123; pRasterPyramid.Create();&#125;//新建栅格图层IRasterLayer pRasterLayer = new RasterLayer();pRasterLayer.CreateFromRaster(pRasterDS.CreateDefaultRaster());IMap pmap = mapControl.Map;//加载显示pmap.AddLayer(pRasterLayer);mapControl.ActiveView.Refresh(); 4. 属性查询12345678910111213141516171819202122232425262728293031public static DataTable getFeatureLayerTable(IFeatureLayer pFeatureLayer)&#123; //获取数据源FeatureClass IFeatureClass pFeatureClass = pFeatureLayer.FeatureClass; DataTable dt = new DataTable(); for (int i = 0; i &lt; pFeatureClass.Fields.FieldCount; i++) &#123; //循环给每一列写字段名 dt.Columns.Add(pFeatureClass.Fields.get_Field(i).Name); &#125; //获取查询返回的游标，null代表没有查询条件，返回整个表 IFeatureCursor pFeatureCursor = pFeatureClass.Search(null, false); //将指针指向第一个要素属性行 IFeature pFeature = pFeatureCursor.NextFeature(); while (pFeature != null) &#123; //获取表中的新行，并将引用赋值给DataRow DataRow dataR = dt.Rows.Add(); for (int j = 0; j &lt; pFeatureClass.Fields.FieldCount; j++) &#123; //为每一个属性单元格赋值 if (pFeature.get_Value(j) == null) dataR[j] = pFeatureClass.ShapeType.ToString(); else dataR[j] = pFeature.get_Value(j); &#125; //游标指向下一行要素 pFeature = pFeatureCursor.NextFeature(); &#125; return dt;&#125; 5. 空间查询1234567891011121314IFeatureLayer pFeatureLayer = pLayer as IFeatureLayer;//实例化一个过滤器，用来设置空间范围的查询条件ISpatialFilter pSpatialFilter = new SpatialFilter();IGeometry geometry = mapControl.TrackRectangle();//将几何范围赋值给pSpatialFilterpSpatialFilter.Geometry = geometry;//设置空间范围的查询条件pSpatialFilter.SpatialRel = esriSpatialRelEnum.esriSpatialRelIntersects;//实例化查询接口IFeatureSelection pfeatureSelection = pFeatureLayer as IFeatureSelection;//实现高亮pfeatureSelection.SelectFeatures(pSpatialFilter, esriSelectionResultEnum.esriSelectionResultNew, false);mapControl.Refresh();//地图刷新 分值 填空：1*15 选择：2*10 简答：基本概念、总结及功能流程 4*5 程序阅读：改错、对象模型图 5*3 程序设计：2*15","tags":[]},{"title":"空间数据库总结","date":"2020-01-11T06:54:21.990Z","path":"2020/01/11/空间数据库总结/","text":"第一章1. 数据的特点：数据与其语义不可分割2. 数据库的特点： 数据共享 数据独立（程序和数据结构之间相互独立） 减少数据冗余 避免数据不一致和加强了数据保护 3. 数据库管理系统DBMS的功能： 数据定义功能：提供数据定义语言(DDL)，对数据库、表、索引的定义 数据操作功能：提供数据操纵语言(DML)，实现对数据库的基本操作 (查询、插入、删除和修改) 数据库运行控制功能：并发控制、安全性检查、完整性约束条件的检查和执行、索引的自动建立 数据库的建立和维护功能：初始数据的输入、转换，数据的存储组织，数据库的转储恢复，性能监视、分析功能等 4. 数据库系统DBS的构成 数据库 数据库管理系统 数据库管理员、用户 应用程序 5. 数据库系统DBS特点 数据结构化 数据的共享性高，冗余度低，易扩充 数据独立性高 数据由DBMS统一管理和控制 6. 数据管理技术 人工管理阶段(20世纪40年代中–50年代中) 文件系统阶段(20世纪50年代末–60年代中) 数据库系统阶段(20世纪60年代末–现在) 7. 内部结构：三级模式，两级映像，逻辑独立性和物理独立性 三级模式：对数据的三个抽象级别 模式 外模式（子模式或用户模式）：介于模式与应用之间。同一个模式可以有任意多个外模式。模式与外模式的关系：一对多，外模式与应用的关系：一对多 内模式（也称存储模式）：数据物理结构和存储方式的描述。一个数据库只有一个内模式 两级映像：在DBMS内部实现这三个抽象层次的联系和转换 外模式／模式映像：每一个外模式，数据库系统都有一个外模式／模式映象，定义外模式与模式之间的对应关系，保证数据的逻辑独立性 模式／内模式映像 ：定义了数据全局逻辑结构与存储结构之间的对应关系。模式／内模式映象是唯一的。保证数据的物理独立性 8. 数据模型 概念模型：实体－联系法(E-R图法) 逻辑模型 物理模型 三要素： 数据结构 数据操作 完整性约束条件 9. 常用模型 层次（树形结构） 网状（图） 关系（二维表) 10. 关系的完整性约束条件 实体完整性 参照完整性 用户定义的完整性 第二章1. 空间数据及特征： 空间数据： 对空间事物的描述 以地球表面空间位置为参照，用来描述空间实体的位置、形状、大小及其分布特征诸多方面信息的数据 一种带有空间坐标的数据 空间数据获取方式包括人工统计、仪器测量等必然产生误差 特征： 时空特征（空间特征、属性特征、时态特征） 多维特征（空间三维与时间维，多维属性信息） 多尺度特征（空间多尺度、时间多尺度，空间坐标和空间关系变长结构，非结构化特征） 海量数据特征 空间数据类型（P9） 地图数据 影像数据 地形数据 属性数据 2. 空间数据库SDB的概念和构成概念：描述与特定空间位置相关的真实世界对象的数据集合 构成 空间数据库 空间数据管理系统 空间数据库应用程序 用户 3.五种空间数据的管理模式 文件管理方式 二元化空间数据库管理系统 全关系型空间数据库管理系统 对象－关系空间数据库管理系统 面向对象空间数据库管理系统 4. 空间信息（概念）模型 数据模型：表示空间参考对象也即要将空间实体抽象为数据模型。 场模型：连续对象的描述（二维，三维），不能够对单独对象进行描述 对象模型：强调单个对象，把空间对象当做空间要素来表达（点线面体） 网络模型：网络状对象的描述 场的组成部分 空间框架：构建了场的定义域 连续平面：坐标定位 离散网格：编码定位 场函数：属性域 例子中的森林单一场：空间框架f(x,y)→属性域（冷杉，橡树，松树） 场操作 局部操作 聚焦操作 区域操作 5. 拓扑操作（几何不变性）、九交矩阵描述 第三章 + 第四章1. 关系模型的三要素 1.8 集合运算：并、交、差、笛卡尔积 专门的关系运算：选择、投影、连接、除 五种基本：并、差、笛卡尔积、选择、投影 2. 关系的性质（了解） 列是同质的：同一属性名下的诸属性是同类型数据，且必须来自同一个域 不同列属性必须有不同属性名 列、行的次序无所谓、可以任意交换 任意两个元组不能完全相同 不允许“表中套表”，即分量必须取原子值，每一个分量必须是不可分的数据项 3. 关系代数的写法 &lt;!-- 写关系代数 --&gt; 4. SQL语句的写法 &lt;!-- SQL语句 --&gt; 5. SQL的特点：非过程化（了解） 一体化特点。 高度非过程化。 语言简洁，易学易用。 统一的语法结构对待不同的工作方式。 面向集合的操作方式。 SQL语言可以对两种基本数据结构进行操作，一种是“表”，另一种是“视图(View)”。 6. 数据定义的命令 表 create Alter ( add, drop, modify修改 ) drop 视图 create ( update, delete, Insert ) drop 索引 create drop × 第五章1. E-R图 ，带象形图的E-R图：将对象插在方框内的微缩图 2. 扩展SQL，SQL3和SQL99版本，有了用户自定义类型对象关系数据库 关键特性就是支持SQL3/SQL99。 SQL3中支持用户自定义数据类型。 空间数据库就是要研究SQL3/SQL99，对标准SQL语言进行扩展，从而操纵和获取空间数据。 3. OGIS联盟 标准操作：8种 P74-75 拓朴/集合运算： Equal 如果两个几何体完全相同返回真 Disjoint 两个几何体内部和边界都不相交返回真 Intersect 两几何体相交则返回真 Touch 两几何体边界相交则返回真 Cross 如果线和面的内部相交则返回真 Within 给定几何内部不和另一几何的外部相交返回真 Contains 判断给定几何体是否包含另一几何体 Overlap 如果两几何体内部有非空交集返回真 4. 创建空间表 1234567&gt; CREATE TABLE Country(&gt; Name varchar(35) Primary key, &gt; Pop Integer, &gt; GDP double&gt; Life FLOAT,&gt; Shape Polygon)&gt; 5. 空间查询 P76 第五章PPT P52 第六章1. 物理、空间模型：实现逻辑模型2. 存储架构 主存（提升性能）——速度很快（纳秒级），但关电源后存储内容丢失 二级存储设备（存储数据）——速度慢（微秒级），但存储内容不受电源的影响 三级存储设备（存储备份）——速度更慢，存储内容不受电源影响，往往存储容量非常大。 3. 磁盘物理结构： 盘片：物理圆形磁片 磁道：盘片上的同心圆，磁道密度决定容量 柱面：所有盘片上的直径相同的磁道 扇区：组成页面（存储）的最小单位，有扇区号 页面：磁盘和主存间的最小传输单位，一般为扇区的整数倍 4. 存取时间和构成：ts、tt、tl 寻道时间：移动磁头到相应磁道上的时间ts 延迟时间：要读取页面旋转到磁头下的时间tl 传输时间：磁头读或写相应数据的时间tt ts&gt;tl&gt;tt tt一般在初始时固定，但ts和tl可能通过优化策略缩短。 5. 主存上缓冲区管理器及缓冲策略 DBMS模块：先进先出 缓冲区管理器 DBMS的一个软件模块 负责缓冲区空间分配调度的子系统 缓冲区替换策略 最近使用（LRU） 替换出最长时间没有读或写过的块 先进先出（FIFO） 替换出被同一个块占用时间最长的缓冲块 “时钟”算法 LRU的一个常见的、有效的近似 系统控制 查询优化器或者其它的DBMS部件可以给缓冲区管理器提供建议来避免象LRU，FIFO，或者时钟这样的严格的策略可能引起的问题 6. 根据存储容量从小到大采用什么存储策略 从小到大 同一扇区 相邻扇区 = 同一个磁道 同一柱面 减少存到时间 相邻柱面 7. 文件结构 PPT P33 无序（堆）文件 顺序文件 散列文件 聚类文件（用于空间数据存储） 8. 空间填充曲线（过程） &lt;!-- 画图 --&gt; Z曲线 hilbert 9. 空间数据的组织 横向分幅（标准分幅或区域分幅等） 标准经纬度分块 矩形分块 任意区域多边形分块 &lt;!--小比例尺按经纬线分幅，大比例尺地图按矩形分幅。--&gt; 纵向分层 专题分层 每个图层对应一个专题，包含某一种或某一类数据。如地貌层、水系层、道路层、居民地层等。 时间序列分层 把不同时间或不同时期的数据作为多个数据层。 地面垂直高度分层 把不同垂直高度的数据作为一个数据层。 分层分块索引 金字塔含义和性质（分辨率变、范围不变、每块不同） 核心：对遥感影像进行分层、分块 分层就是把原始影像数据按照不同分辨率进行管理，具体就是把分辨率高的影像层依次通过重采样算法生成其上层的影像数据。 分块是对分层之后的影像数据按照设定好的影像块进行分割存储。分块之后只需要将需要显示和处理的若干个影像块数据读入内存，而并非未分块前的一整幅影像。 最后对每层的影像块（分块大小相等）统一组织存储。 性质： 从底层到顶层，分辨率越来越低，但表示的空间范围不变。 一般采用固定大小（通常取2的幂次方）的分块方法。目前建立影像数据库多采用数据块大小为 128×128或 256×256。 &lt;!--影像的尺寸越来越小，但描述的空间范围是不变的，最终分辨率降低。--&gt; 10. B-数和B+数 –》R树 B-树是一种平衡的多路查找树，m阶树 根结点或者是叶子，或者至少有两棵子树，至多有m棵子树 除根结点外，所有非终端结点至少有m/2棵子树，至多有m棵子树； 所有叶子结点都在树的同一层上； 每个结点应包含如下信息：(n，A0，K1，A1，K2，A2，… ，Kn，An)其中Ki(1≤i≤n)是关键字，且Ki&lt;Ki+1 (1≤i≤n-1)；Ai(i=0，1，… ，n)为指向孩子结点的指针，且Ai-1所指向的子树中所有结点的关键字都小于Ki ，Ai所指向的子树中所有结点的关键字都大于Ki ；n是结点中关键字的个数，且（m/2)-1≤n≤m-1，n+1为子树的棵数。 B- 树 3阶 4阶 5阶 根结点子树 2-3 2-4 2-5 根/非终端结点子树 2-3 2-4 3-5 根/结点中关键字 1-2 1-3 2-4 根结点中关键字 1-2 1-3 1-4 B+树 从最小关键字顺序查找 从根结点开始随机查找 每个结点至多有m个子结点； 除根结点和叶结点外，其它每个结点至少有m/2 个子结点； 若根结点不是叶子结点，则至少有两个子结点； 所有的叶结点在同一层； B+ 树 3阶 4阶 5阶 根结点子树 2-3 2-4 2-5 根/非终端结点子树 2-3 2-4 3-5 根/结点中关键字 2-3 2-4 3-5 根结点中关键字 1-3 1-4 1-5 11. 什么是空间索引？ 空间索引：依据空间对象的位置和形状或空间对象之间的空间关系，按一定的顺序排列的一种数据结构。 基本思想：近似体的使用 常见的空间索引： 对象范围索引（两级过滤） 初次过滤根据空间要素外包矩形来过滤掉大部分不在查询范围的空间要素； 第二级过滤则用查询空间范围直接和初次过滤结果集中空间要素的二进制边界坐标比较，从而得到查询的准确结果 &lt;!-- 没有真正的空间索引文件，而是为空间对象添加外接矩形，依靠空间计算能力判别 --&gt; &lt;!-- 查询时仍需要对整个空间对象进行检索，某些对象可以通过矩形范围直接判别 --&gt; &lt;!-- 该方法仍需要花费大量时间进行空间检索，计算机处理速度加快，弥补了效率的要求 --&gt; 格网索引（固定网格结构，固定网格结构是固定的，它的目录稀疏而巨大） &lt;!-- 将研究区域用横竖线条划分大小相等或不等的格网，记录每一个格网所包含的空间实体 --&gt; &lt;!-- 空间查询时，首先计算出用户查询对象所在格网，然后在该网格中快速查询所选空间实体 --&gt; 第一阶段（RDBMS完成）： 接收SQL语句，获取空间过滤器的封装边界 检测空间过滤器的封装边界跨越的网格 到空间索引表中检索出封装边界所在网格内的要素 第二阶段：几何过滤器的封装边界与第一阶段检索出的要素的边界相比较，找出具有重叠关系的要素 第三阶段：几何过滤器的坐标与第二阶段检索出的要素的边界比较，找出边界在几何过滤器内的要素 第四阶段：几何过滤器的坐标与第三阶段检索出的要素的坐标比较，找出最终在几何过滤器内的要素类 格网索引（网格文件） 四叉树索引 在建立四叉树索引时，根据所有空间对象覆盖的范围，进行四叉树分割，使每个子块中包含单个实体，然后根据包含每个实体的子块层数或子块大小，建立相应的索引。 R树索引 根结点到每一个叶结点的深度相等 。 树中每个非叶结点有n到M个子结点，M 对特定的树是固定的(阶数)。2=&lt; n&lt;= M/2 12.对象范围索引中有一个检索关系式空间对象被检索 Xmax ≥ XW and Xmin≤XE AND Ymax ≥ YS and Ymin≤YN 空间对象不被检索Xmax ≤ XW OR Xmin ≥ XE OR Ymax ≤ YS OR Ymin ≥YN 13. 网格文件索引 &lt;!-- 画图 --&gt; 根据空间维度划分k维空间。 将平面索引空间划分为相等或不等的一些小方格网。 与每个格网相关联的空间目标存储到同一磁盘页面（桶）或多个磁盘页面（溢出桶）。 页面的访问地址通过格网的线性标量（数组下标）求得。 线性标量是空间目标实际坐标按照线型比例生成的索引。 14. R树特征(10-12条) 每个叶结点包含m至M条索引记录(其中m&lt;=M/2 ) 一个叶结点上的每条索引记录了最小外包矩形。 每个非叶结点都有m至M个子结点。 对于非叶结点中的每个条目包含其子结点中矩形的最小外包矩形。 根结点至少有两子结点。 所有叶结点出现在同一层。 所有MBR的边与一个全局坐标系的轴平行。 R树允许结点相互覆盖,这种交叠可以使R树保持较高的空间利用率和保持树的平衡。 过多交叠可能会造成查询效率的降低,最坏的情况下对某一对象的查询可能造成对整个树的搜索。 R树搜索的性能取决于两个参数：覆盖和交叠。 树的某一层覆盖是指这一层所有节点的MBR所覆盖的全部区域。 若想要得到一个高效的R树，覆盖和交叠都应该很小。 15. 最优R树画法 &lt;!-- 画图 --&gt; 第七章1. 策略 选择运算尽可能先做 投影运算和选择运算同时进行 把投影运算同其前后的双目运算结合执行 执行连接运算前，进行适当的预处理 选择运算和笛卡尔积运算结合成连接运算 找出公共子表达式，避免重复运算 2. 空间操作的两步处理：过滤步骤、精炼步骤练习题 数据库系统的特点是数据共享、数据独立、减少数据冗余、避免数据不一致和加强了数据保护。 数据库管理系统（DBMS）是系统软件 数据库管理系统能实现对数据库中数据的查询、插入、修改和删除等操作．这种功能称为数据操纵功能 在数据库的三级模式结构中，描述数据库中全体数据的全局逻辑结构和特征的是模式 数据库系统的数据独立性是指不会因为数据的变化而影响应用程序 数据库类型是按照数据模型来划分的 一组具有相同数据类型的值的集合称为域 在数据库中存储的是数据以及数据之间的联系 按所使用的数据模型来分，数据库可分为层次、关系和网状三种模型 在数据库设计中用关系模型来表示实体和实体之间的联系。关系模型的结构是二维表结构 在关系模型中，实现”关系中不允许出现相同的元组”的约束是通过主键 关系模型由数据结构、关系操作集合和完整性约束三部分组成","tags":[]},{"title":"GPS测量原理及应用 知识总结","date":"2020-01-11T06:51:17.647Z","path":"2020/01/11/GPS测量原理及应用 知识总结/","text":"第一章1. 北斗的优势及应用 （至少三点） 优势 三频定位，卫星定位精度更高。 通过三个不同频率的信号可以有效消除定位的时候产生的误差，并且多个频率的信号可以在某一个频率信号出现问题的时候改用其他信号，提高定位系统的可靠性和抗干扰能力 短报互文功能 安全、方便 应用 气象应用： 北斗系统在卫星气象方面的应用，可以提升中国天气分析和数值天气预报、气候变化监测和预测的水平，也可以提高空间天气预警业务水平，提升中国气象防灾减灾能力。 铁路智能交通：北斗卫星导航系统将可提供高可靠、高精度的定位、测速、授时服务。 应急救援： 全海域出海渔船加装北斗系统装备，利用北斗特有的短报互文通信功能及时回传海上遇险搜救信息，成为海上渔民保障安全的重要工具。 居家智慧养老项目：利用“互联网+北斗定位+社区服务组织+医疗机构+居家养老智能服务终端”，构建智能化医、养、服务结合的居家养老实施体系， 北斗+纪检 ：实时查询目标车辆的精确位置和历史轨迹，对公车实行动态监管。 2. GPS系统的组成、地面监控、GPS接收机任务 系统组成 空间部分——GPS卫星星座 作用： ​ 1. 用两个无限载波向用户连续发送导航定位信号 2. 接收导航电文及其他信息，适时的发送给广大用户 3. 接收地面主控站通过注入站发送到卫星的调度命令，实时的改正运行偏差或启用备用时钟等。 地面控制部分——地面监控系统 一个主控站。 美国本土科罗拉多。收集、处理本站和监测站收到的全部资料 ，编算出每颗卫星的星历和GPS时间系统，将预测的卫星星历、钟差、状态数据以及大气传播改正编制成导航电文传送到注入站。 三个注入站 将主控站发来的导航电文注入到相应卫星的存储器。 五个监测站 为主控站提供卫星的观测数据 用户设备部分——GPS信号接收机 捕获按一定卫星高度截止角所选择的待测卫星的信号，并跟踪卫星运行 对所接收到的GPS信号进行变换、放大和处理 测量出信号传播的时间，解译出GPS卫星所发送的导航电文 实时计算出测站的三维信息，甚至三位速度和时间。 系统特点 定位精度高：50km以内可达10-6 观测时间短： 20km以内的相对静态定位，仅需15~20 分钟 测站间无需通视：只需测站上空开阔。 可提供三维坐标、时间、速度：经典大地测量将平面与高程分别施测，GPS可同时测定点的三维坐标。 操作简便 全天候作业：24小时行。 功能多、应用广 第二章1. 天球坐标系和地球坐标系是用来干什么的？ 天球坐标系:描述卫星的运行位置和状态。该坐标系与地球自转无关。 原点—地球质心M Z轴—指向天球北极Pn X轴—指向春分点 Y轴—垂直于XMZ平面，与X轴Z轴构成右手坐标系统。 地球坐标系:描述地面观测站的位置，该坐标系随同地球自转。通常采用空间直角坐标系进行坐标转换。 原点O：地球质心 Z轴：指向地球北极Pn X轴：指格林尼治子午面与地球赤道的交点E Y轴：垂直于XOZ平面，与X轴和Y轴构成右手坐标系。 为什么选用空间直角坐标系？ 任一点的空间位置可由该点在三个坐标面的投影（X，Y，Z）唯一地确定，通过坐标平移、旋转和尺度转换，可以将一个点的位置方便的从一个坐标系转换至另一个坐标系。 与某一空间直角坐标系所相应的大地坐标系（B，L，H），只是坐标表现形式不同，实质上是完全等价的，两者之间可相互转化。 2. 怎么定义坐标系？ 坐标原点的位置。 三个坐标轴的指向。 长度单位 3. 坐标系统之间的转换七参数 同一基准 空间直角坐标系与空间大地坐标系间的转换。 空间坐标系与平面直角坐标系间的转换。 不同基准 不同坐标系之间的转换实质上就是不同基准间的转换，常用布尔萨七参数转换方法。 布尔萨七参数：即3个平移参数，3个旋转参数，1个尺度参数。 GPS坐标与我国北京54（西安80）坐标的转换流程图： 4. 时间系统 判断 时间： 时刻：发生某一现象的瞬间. 时间段：发生某一现象所经历的过程，是这一过程始末的时刻之差。 时间基准 时间原点（时刻） 时间尺度（时间段） GPS定位对时间系统的要求全球统一的时间原点和高精度的时间尺度。 原因： 时间度量的精度就意味着空间位置的精度。 GPS定位是通过测定电磁波信号的传播时间来测定站星距离的。 第三章1. 卫星的无赦运动，确定开普勒轨道方程，要知道参数 无赦运动：地球质心引力（中心引力） 第一定律：卫星运动的轨道是一个椭圆，而该椭圆的一个焦点与地球质心重合。 第二定律：卫星到地心的距离在相等的时间内所扫过的面积相等。 第三定律：卫星运行周期的平方，与轨道椭圆长半径的立方之比为一常量。 理想轨道 中心引力 二体问题：将地球和卫星视为两个质点，仅考虑地球质心引力研究卫星运动规律 受摄运动：地球非对称性引力 日月引力； 大气阻力； 光辐射压力 摄动力 地球非中心引力Fm； 太阳引力Fs和月球引力Fn； 太阳光的直接与间接辐射压力Fr； 大气阻力Fa； 地球潮汐作用力； 磁力及其他作用力 开普勒运动 轨道六参数 卫星轨道面与赤道面的相对位置 升交点赤经Ω ：升交点和赤道面春分点的夹角 近地点角距 ：轨道平面近地点和升交点的夹角 轨道倾角 ：轨道面和赤道面的夹角 卫星过近地点时刻 卫星轨道的形状 卫星轨道长半轴 卫星轨道扁率 2. GPS卫星星历描述卫星某一时刻运动轨道的信息 预报星历（广播星历） 定义：通过卫星发射到用户接收机的含有轨道信息的导航电文信号 内容：共计17个星历参数。 特点： 每2个小时更新一次， 外推的时间间隔不超过1小时 预报星历的精度一般约为20-40m 注入站—-将卫星星历、卫星钟差等参数和各种控制命令发送到GPS卫星。 预报星历的编制和传送过程： 后处理星历（精密星历） 定义：根据地面跟踪站的精密观测资料计算而得到的，不包含外推误差的实测星历。 优点： 轨道参数非常准确，也称精密星历。 缺点：不能做到实时。 后处理星历的编制和传送过程： 第四章1. GPS卫星的导航电文​ 用户用来定位和导航的数据基础。 遥测码：位于各子帧的开头，表明卫星注入数据的状态。 转换码：位于每个子帧的第二个字码，提供帮助用户从所捕获C/A码转换到捕获P码的时间计数（Z）。 第一数据块：位于第一子帧的第3 ~10字码。 卫星时钟改正——以地面主控站的原子钟为基准 电离层时延改正 星期序号WN—— GPS周期数 数据龄期AODC 卫星的健康状况 第二数据块：包含第2和第3子帧，其内容表示GPS 卫星的星历。 第三数据块：包含第4和第5子帧，内容包括了所有GPS 卫星的历书数据。可帮助用户选择工作正常的定位卫星。 2. GPS信号图，信号怎么产生的，为什么要两个载波，消除有什么影响，C/A码，P码 GPS信号 运载工具（载波L1、L2） 测距码（C/A码、P码） 导航电文（数据码、D码） 信号图 两个载波 测量出或消除掉由于电离层效应而引起的延迟误差 消除有什么影响？ 粗码C/A码 码长：1023位 周期：1ms 测距误差：3~30m 特点： 由于C/A码的码长较短，易于捕获，而通过捕获C/A码所得到的信息，又可以方便的捕获到P码，称C/A码为捕获码。 C/A码的码元宽度较大，测距误差可达 3~30m。由于其精度较低，所以，称C/A码为粗捕获码。 由于C/A码单点定位精度较低，测量上采用非单点定位，即相对定位（差分定位）。 精码P码 码长：6.19*1012 bit 周期：七天 测距误差：0.3~3m 特点： 码元宽度较小，精度较高，专为军用。 目前，只有极少数接收机才能接收P码，且价格昂贵。 3. 接收机的基本工作原理 接收天线：将GPS信号的极危若的电磁波能转化为相应的电流 前置放大器：将GPS信号电流予以放大。为便于接收机对信号进行跟踪、处理和两侧。 接收机主机 变频器及中频放大器 经过GPS前置放大器的信号仍然很微弱，为了使接收机通道得到稳定的高增益，并使L频段的射频信号变为低频信号。采用变频器 信号通道 搜索卫星，牵引并跟踪卫星 对广播电文数据信号实行解扩，解调出广播电文 进行伪距测量、载波相位测量及多普勒频移测量 总结 当GPS卫星在用户世界升起时，接收机能够捕获到按一定卫星高度截止角所选择的待测卫星，并能够跟踪这些卫星的运行； 对所接收到的GPS信号，具有变换，放大和处理的功能， 以便测量出GPS信号从卫星到接收天线的传播时间， 解译出GPS卫星所发送的导航电文， 实时的计算出测站的三维位置，甚至三维速度和时间。 GPS信号接收机不仅需要功能较为强大的机内软件，而且需要一个多功能的GPS数据测后处理软件包。 接收机加处理软件包，才是完整的GPS信号用户设备。 第五章1. GPS卫星定位的基本原理，分类，四种 基本原理 运用空间距离前方交会的方法求出卫星的位置。 运用空间距离后方交会的方法求测站点的位置。 观测值：距离 用距离交会的方法求解P点的三维坐标（X，Y，Z）的观测方程： 实质：​ 由GPS接收机在某一时刻，同时接收四颗以上的GPS卫星信号，测量出GPS接收机到GPS卫星的距离，根据空间距离后方交会的方法求测站点的位置。 GPS定位方法及分类 按采用观测值 伪距定位 载波相位定位 按获取结果的时间 实时定位 事后定位 按测站的运动状态 静态定位 动态定位 按接收机的数量 绝对定位（单点定位） 相对定位（差分定位） 2. 什么是伪距测量？原理是什么，方程（详细）方程各部分的意义 定义 伪距法定位：由GPS接收机在某一时刻测出四颗以上的GPS卫星的伪距以及已知的卫星位置，采用空间距离后方交会的方法求定天线所在点的三维坐标。 伪距：由卫星发射的测距码信号到达GPS接收机的传播时间乘以光速所得出的量测距离。而不是卫星与GPS接收机的几何距离。 原理 时间 t 的测定： 卫星 — 测距码，经时间到达接收机。 接收机 — 复制码 时延器 — 延迟复制码，经延迟时间 使两码对齐，。 使实际上是不可能的，只能使，两种码不可能完全对齐，导致时间有误差。 伪距测量方程 为伪距测量值 为卫星至接收机几何距离 T为测距码的周期 为周长 为测距模糊度 如果已知待测距离小于测距码的波长，则n=0 伪距定位观测方程 优点：定位速度快，无多值性。 缺点：定位精度低，P码的测距精度0.3m，C/A码 的测距精度3m左右 。 3. 载波相位测量的原理，方程 原理 方程 4. 整周跳变原因，修复方法 定义 在载波相位测量中，若接收机保持对卫星信号的连续跟踪，则整周未知数保持不变，整周计数也保持连续. 但当接收机无法保持对卫星信号连续跟踪时，在卫星信号重新被锁定后，整周未知数将发生变化，整周计数也将不再与前面的值保持连续而发生部分丢失现象. 不足一周的的相位观测值仍是正确的 原因 信号被其它物体遮拦； 大功率电磁场干扰； 电源中断，或接收机故障（无法修复周跳，需重新观测） 修复方法 屏幕扫描法 多项式拟合法 在卫星间求差 双频观测值修复周跳 根据平差后的残差修复周跳 5. 绝对定位，相对定位 绝对定位 ​ 接收机天线处于静止状态下，确定观测站坐标的方法称为静态绝对定位。 这时，可以连续地在不同历元同步观测不同的卫星，测定卫星至观测站的伪距，获得充分的多余观测量。测后通过数据处理求得观测站的绝对坐标。 相对定位 至少用两台GPS接收机，同步观测相同的GPS卫星，确定两台接收机天线之间的相对位置（坐标差）。 特点 优点：定位精度高 缺点： 多台接收共同作业 数据处理复杂 不能直接获取绝对坐标 应用 高精度测量定位及导航 6. 一次两次三次差分定位 单差观测（一次差）——在接收机间求差 为什么要进行单差观测？ 不同接收机观测同一颗卫星，在不同接收机间求一次差，可消除信号传播的误差（对流层、电离层等的误差），采用单差观测的目的就是要减少误差的影响提高定位结果的精度。优点：①可消除卫星钟差的影响； ②削弱星历误差的影响； ③可削弱电离层和对流层的影响。 双差观测（二次差）——在卫星间求差 可以消除接收机间钟差的影响。 三次差—在星历间求差（两个历元的星历间求差）可消除的影响（过程中由于不准造成的影响） 差分定位 差分GPS定位技术是将一台GPS接收机安置在基准站上进行观测。根据基准站已知精密坐标，计算出基准站到卫星的距离改正数，并由基准站实时地将这一改正数发送出去。用户接收机在进行GPS观测的同时，也接收到基准站的改正数，并对其定位结果进行改正，从而提高定位精度。 差分GPS可分为: 单基准站差分 位置差分 伪距差分 载波相位差分 具有多个基准站的局部区域差分 广域差分 GPS定位中，存在着三部分误差： 一是多台接收机公有的误差，如：卫星钟误差、星历误差； 二是传播延迟误差，如：电离层误差、对流层误差； 三是接收机固有的误差，如：内部噪声、通道延迟、多路径效应。 采用差分定位，可完全消除第一部分误差，可大部分消除第二部分误差（视基准站至用户的距离）。 第七章1. GPS测量的误差来源及消除方法 GPS卫星: 对距离测量的影响：1.5 ~ 15m 星历误差：星历包含17个参数，参数本身存在误差。 ​ 消除: 建立自己的卫星跟踪网； 轨道松弛法——六个轨道参数的近似值作为已知值，将改正数作为参数进行平差处理。 同步观测求差——利用两个或多个观测站，对同一卫星的同步观测值求差。 钟误差：调制波以一定的频率形成信号，信号本身存在误差；利用调制码求时间，存在误差。 ​ 消除: 加钟差改正模型 同步观测求差——在接收机间求一次差，可消除卫星钟差和改正后的残余误差。 相对论效应：对震荡频率产生影响，会对时间、空间距离产生影响。​ 消除: 在制造卫星钟时预先把频率降低为 卫星信号的传播过程: 对距离测量的影响：1.5 ~ 15m 电离层：信号在传播时会发生折射。 ​ 消除: 利用电离层改正模型加以修正（模型法） 利用双频观测 同步观测求差。 对流层：信号在传播时会发生折射。 ​ 消除: 采用对流层模型加以改正； 引入待估参数； 同步观测求差。 多路径效应：测站周围的反射物所反射的信号进入接收机天 线，与直接来自卫星的信号产生干涉。 ​ 消除: 选择合适的站址； 对接收机天线的要求； 同步观测求差。 不论是对流层或电离层与高度角都有很大的关系， 正上方影响最小，地平方向最大。高度角越大越好。 地面接收设备: 对距离测量的影响：1.5 ~ 5m 接收机钟差：接收机钟与卫星钟不同步。 ​ 消除: 作为未知数，一并求解； 在卫星间求一次差； 加时钟改正模型。 位置误差：对中、整平、水准器校正不好等。 ​ 消除: 校正仪器、仔细安置仪器、强制归心。 天线相位中心：天线的几何中心与电磁场相位中心不重合，类似经纬仪度盘的偏心差。 ​ 消除: 同步观测求差。 所有天线安置时方向要一致，指向标均指向北方向。 其他影响 地球潮汐：海潮，固体潮 负荷潮：与地球的内部质量分布不均匀有关，与地球的引力有关。对距离测量的影响：1.0m 第八章1. GPS测量的设计依据，基准设计 设计依据 GPS测量规范：主要指国家、城市以及行业标准。 测量任务书：布网的设计既要符合有关标准又要满足任务要求。 基准设计 位置基准：由给定的起算点确定 方位基准：由给定边的起算方位角确定 尺度基准：测距仪测定的基线边、GPS基线边或两个起算点间的距离确定 2. GPS网构成的几个基本概念及网特征条件 基本概念 观测时段：测站上开始接收卫星信号到观测停止，连续工作的时间段。 同步观测：两台或两台以上接收机同时对同一组卫星进行的观测。 同步观测环：三台或三台以上接收机同步观测获得的基线向量所构成的闭合环。 独立观测环：由独立观测所获得的基线向量所构成的闭合环。 异步观测环：在构成多边形环路的所有基线向量中，只要有非同步观测基线向量，则该多边形环路叫异步观测环。 独立基线：对于N台GPS接收机构成的同步观测环，有J条同步观测基线，其中独立基线数为 N-1。 非独立基线：除独立基线外的其他基线，总基线数与独立基线数之差即为非独立基线数。 GPS网特征条件的计算 全网观测时段数 总基线数 必要基线数 独立基线数 多余基线数 3. GPS网特征条件的计算 4. GPS外野实施，怎么选点，观测，不能做什么 选点 点位应安置在视野开阔，易安装仪器的地方； 点位目标明显，视场周围15°以上没有障碍物的地方； 点位应远离大功率无线电用电器大于200m；远离高压电线，不小50m； 点位附近无大面积水域，无强烈信号干扰，以免造成信号衰减； 点位应选在交通便利、有利于其它观测手段扩展和联测； 地面基础稳定易于点的保存； 图形应有利于同步观测边、点联测； 利用旧点时应对旧点的稳定性、完好性和站标的安全性进行检查； 观测过程中不允许进行以下操作：​ a)接收机关闭又重新启动；​ b)进行自测试；​ c)改变卫星仰角；​ d)改变数据采样间隔；​ e)改变天线位置；​ f)按动关闭文件和删除文件等功能键。 5. RTK的测量原理，基准站，移动站什么时候发送数据 测量原理 在基准站上安置一台GPS接收机，对所有可见GPS卫星进行连续的观测，并将其观测数据，通过无线电传输设备，实时的发送给用户观测站。 在用户站上，GPS接收机在接收GPS卫星信号的同时，通过无线电接收设备，接收基准站传输的观测数据，然后根据相对定位的原理，实时的计算并显示用户站的三维坐标及其精度。 第九章1. GPS测量数据处理过程，原理，方法 过程 数据采集： GPS接收机至卫星的伪距、载波相位和卫星星历等数据。 GPS数据处理：从原始的观测值出发得到最终的测量定位成果。 基线解算： 原始观测数据的读入 外业输入数据的检查与修改 设置基线解算的控制参数 基线解算 基线解算质量的检核 结束 2. GPS高程：之间的差异 大地水准面和正高（正高系统）: 以大地水准面为基准面的高程系统。 似大地水准面和正常高（正常高系统）: 以似大地水准面为基准面的高程系统。 参考椭球面和大地高（大地高系统）: 以参考椭球面为基准面的高程系统 3. 高程计算方法：3个 绘等直线图法—— 几何内插法 测区内有m个点，大地高均已知； 选n个点进行水准测量，得其正常高； 计算n个点的高程异常： 依据各点的坐标按一定比例将点展绘在图纸上，并在n个点旁标注出其高程异常值。 选取高程异常等高距（1～5cm），绘等值线图。 利用内插法求出其余m-n个点的高程异常值。 注：n个点选取时要覆盖整个测区。 多项式曲线拟合法 在测线上有m个点，经GPS测量得其大地高； 在m个点中n个点，用水准测量方法测得其正常高。 计算n个点的高程异常： 找出与x（或y）的函数关系： 或 可用多项式表示：当工程为带状时利用绘等直线法就不是很方便了，拟合的好坏与点的个数和点的位置有关。 多项式曲面拟合法 在测区上有m个点，经GPS测量得其大地高； 在m个点中n个点，用水准测量方法测得其正常高。 计算n个点的高程异常： 找出 与点的坐标（ x，y）的函数关系： 可用多项式表示： 拟合的点在测区内应分布均匀。 Other2. GPS功能定位，导航，授时","tags":[]},{"title":"github/码云操作---合并分支，推送","date":"2020-01-11T06:45:57.948Z","path":"2020/01/11/github码云操作---合并分支，推送/","text":"将login分支中的代码提交到本地仓库，合并到master分支推送到远端 git status:查看当前项目中源代码的状态 git add .:将修改后文件和新增文件添加到暂存区 git commit -m &quot;提交的文本说明信息&quot;:提交暂存区代码到本地仓库 git branch:查看分支 git checkout -b login:新建一个user分支，并切换到这个分支，执行后，当前处于该分支，当前所有的修改也切换到了这个分支中 git push -u origin lohin:将本地的login分支推动到云端origin仓储里的login分支（远端没有此分支，该分支的第一次推送） git checkout master:切换分支到master git merge login:合并分支 git push:推送","tags":[]},{"title":"IDEA连接Mysql数据库没有jar包报错","date":"2020-01-11T06:44:57.955Z","path":"2020/01/11/IDEA连接Mysql数据库没有jar包，报错/","text":"IDEA连接Mysql数据库没有jar包，报错java.lang.ClassNotFoundException: com.mysql.jdbc.Driver 问题1：IDEA连接Mysql数据库没有jar包 这两个地方都有了，搞定！问题2：报错java.lang.ClassNotFoundException: com.mysql.jdbc.Driver 按层次修改存放的路径，搞定！！！","tags":[]},{"title":"Vue工程化","date":"2019-12-07T13:24:24.461Z","path":"2019/12/07/Vue工程化环境(模块化规范、webpack、单文件组件、脚手架、Element-UI)/","text":"1，模块化相关规范1. 浏览器端模块化规范1.1 AMDRequire.js (http://www.requirejs.cn/) 1.2 CMDSea.js (https://seajs.github.io/seajs/docs/) 2. 服务器端模块化规范2.1 CommonJS 分为 单文件模块、包 导出：module.exports和exports 导入：require(&#39;标识符&#39;) 3. ES6模块化 每个 js 文件都是一个独立的模块 导入使用import关键字 暴露使用 export 关键字 每个模块中，只允许使用唯一的一次 export default，可以多次使用export ES6中的导入、暴露等高级语法，浏览器不能识别，需要讲ES6语法转为浏览器能够识别的ES5语法，可以通过babel，webpack等 4. babel npm install --save-dev @babel/core @babel/cli @babel/preset-env @babel/node npm install --save @babel/polyfill 项目跟目录创建文件 babel.config 在 babel.config中添加下面代码 1234567891011const presets = [ [\"@babel/env\", &#123; targets: &#123; edge: \"17\", firefox: \"60\", chrome: \"67\", safari: \"11.1\" &#125; &#125;]];module.exports = &#123; presets &#125;; 通过 npx babel-node index.js 执行代码 2，webpack1. 安装配置 运行 npm install webpack webpack-cli –D 命令，安装 webpack 相关的包 项目根目录中，创建名为webpack.config.js 在 webpack.config.js中添加代码: 123module.exports = &#123; mode: 'development' // mode 用来指定构建模式&#125; 在 package.json 配置文件中的 scripts 节点下，新增 dev 脚本： 123\"scripts\": &#123; \"dev\": \"webpack\" // script 节点下的脚本，可以通过 npm run 执行&#125; 运行 npm run dev 命令，启动 webpack 进行项目打包。 2. 基本使用2.1 配置打包 入口文件 src -&gt; index.js 输出文件 dist -&gt; main.js 修改，以在 webpack.config.js 中新增配置信息： 12345678const path = require('path') // 导入 node.js 中专门操作路径的模块module.exports = &#123; entry: path.join(__dirname, './src/index.js'), // 打包入口文件的路径 output: &#123; path: path.join(__dirname, './dist'), // 输出文件的存放路径 filename: 'bundle.js' // 输出文件的名称 &#125;&#125; 2.2 自动打包 运行 npm install webpack-dev-server –D 命令，安装支持项目自动打包的工具 修改 package.json -&gt; scripts 中的 dev 命令： 123\"scripts\": &#123; \"dev\": \"webpack-dev-server\" // script 节点下的脚本，可以通过 npm run 执行&#125; 将 src -&gt; index.html 中，script 脚本的引用路径，修改为 &quot;/buldle.js“ 运行 npm run dev 命令，重新进行打包 在浏览器中访问 http://localhost:8080 地址，查看自动打包效果 webpack-dev-server 会启动一个实时打包的 http 服务器 webpack-dev-server 打包生成的输出文件，默认放到了项目根目录中，而且是虚拟的、看不见的 相关参数，设置端口 1234567// package.json中的配置// --open 打包完成后自动打开浏览器页面// --host 配置 IP 地址// --port 配置端口\"scripts\": &#123;\"dev\": \"webpack-dev-server --open --host 127.0.0.1 --port 8888\"&#125;, 2.2 预览页面 运行 npm install html-webpack-plugin –D 命令，安装生成预览页面的插件 修改 webpack.config.js 文件头部区域，添加配置信息： 123456// 导入生成预览页面的插件，得到一个构造函数const HtmlWebpackPlugin = require('html-webpack-plugin')const htmlPlugin = new HtmlWebpackPlugin(&#123; // 创建插件的实例对象 template: './src/index.html', // 指定要用到的模板文件 filename: 'index.html' // 指定生成的文件的名称，该文件存在于内存中，在目录中不显示&#125;) 修改 webpack.config.js 文件中向外暴露的配置对象，新增配置节点： 123module.exports = &#123; plugins: [ htmlPlugin ] // plugins 数组是 webpack 打包期间会用到的一些插件列表&#125; 3. 加载器1. css 文件 运行 npm i style-loader css-loader -D 命令，安装处理 css 文件的 `loader 在 webpack.config.js 的 module -&gt; rules 数组中，添加 loader 规则： 123456// 所有第三方文件模块的匹配规则 module: &#123; rules: [ &#123; test: /\\.css$/, use: ['style-loader', 'css-loader'] &#125; ] &#125; test 表示匹配的文件类型， use 表示对应要调用的 loader use 数组中指定的 loader 顺序是固定的 多个 loader 的调用顺序是：从后往前调用 2. less文件 运行 npm i less-loader less -D 在 webpack.config.js 的 module -&gt; rules 数组中，添加 loader 规则： 123456// 所有第三方文件模块的匹配规则 module: &#123; rules: [ &#123; test: /\\.less$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;less-loader&apos;] &#125; ] &#125; 3. scss文件 运行 npm i sass-loader node-sass -D 命令 在 webpack.config.js 的 module -&gt; rules 数组中，添加 loader 规则 123456// 所有第三方文件模块的匹配规则module: &#123; rules: [ &#123; test: /\\.scss$/, use: ['style-loader', 'css-loader', 'sass-loader'] &#125; ]&#125; 4. 配置 postCSS 自动添加 css 的兼容前缀 运行 npm i postcss-loader autoprefixer -D 命令 在项目根目录中创建 postcss 的配置文件 postcss.config.js，并初始化如下配置： 1234const autoprefixer = require('autoprefixer') // 导入自动添加前缀的插件module.exports = &#123; plugins: [ autoprefixer ] // 挂载插件&#125; 在 webpack.config.js 的 module -&gt; rules 数组中，修改 css 的 loader 规则： 12345module: &#123; rules: [ &#123; test:/\\.css$/, use: ['style-loader', 'css-loader', 'postcss-loader'] &#125; ]&#125; 5. 打包样式表中的图片和字体文件 运行 npm i url-loader file-loader -D 命令 在 webpack.config.js 的 module -&gt; rules 数组中，添加 loader 规则如下： 12345678module: &#123; rules: [ &#123; test: /\\.jpg|png|gif|bmp|ttf|eot|svg|woff|woff2$/, use: 'url-loader?limit=16940' &#125; ]&#125; 其中 ?之后的是 loader 的参数项。 limit 用来指定图片的大小，单位是字节(byte),只有小于 limit 大小的图片，才会被转为 base64 图片 5. 打包处理 js 文件中的高级语法(类等) 安装babel转换器相关的包：npm i babel-loader @babel/core @babel/runtime -D 安装babel语法插件相关的包：npm i @babel/preset-env @babel/plugin-transform\u0002runtime @babel/plugin-proposal-class-properties –D 在项目根目录中，创建 babel配置文件 babel.config.js 并初始化基本配置： 1234module.exports = &#123; presets: [ '@babel/preset-env' ], plugins: [ '@babel/plugin-transform-runtime', '@babel/plugin-proposal\u0002class-properties’ ]&#125; 在 webpack.config.js 的 module -&gt; rules 数组中，添加 loader 规则： 12// exclude 为排除项，表示 babel-loader 不需要处理 node_modules 中的 js 文件 &#123; test: /\\.js$/, use: 'babel-loader', exclude: /node_modules/ &#125; 3，Vue 单文件组件1 . 基本使用1234567891011121314&lt;template&gt; &lt;!-- 这里用于定义Vue组件的模板内容 --&gt;&lt;/template&gt;&lt;script&gt; // 这里用于定义Vue组件的业务逻辑 export default &#123; data: () &#123; return &#123;&#125; &#125;, // 私有数据 methods: &#123;&#125; // 处理函数 // ... 其它业务逻辑 &#125;&lt;/script&gt;&lt;style scoped&gt; /* 这里用于定义组件的样式 */&lt;/style&gt; 2. ebpack 中配置 vue 组件的加载器 运行 npm i vue-loader vue-template-compiler -D 命令 在 webpack.config.js 配置文件中，添加 vue-loader 配置项： 12345678910111213const VueLoaderPlugin = require('vue-loader/lib/plugin')module.exports = &#123; module: &#123; rules: [ // ... 其它规则 &#123; test: /\\.vue$/, loader: 'vue-loader' &#125; ] &#125;, plugins: [ // ... 其它插件 new VueLoaderPlugin() // 请确保引入这个插件！ ] &#125; 3. 在 webpack 项目中使用 vue 运行 npm i vue –S 安装vue 在 src -&gt; index.js 入口文件中，通过 import Vue from &#39;vue&#39; 来导入 vue 构造函数 创建 vue 的实例对象，并指定要控制的 el 区域 通过 render 函数渲染 App 根组件 12345678910// 1. 导入 Vue 构造函数import Vue from 'vue'// 2. 导入 App 根组件import App from './components/App.vue'const vm = new Vue(&#123; // 3. 指定 vm 实例要控制的页面区域 el: '#app', // 4. 通过 render 函数，把指定的组件渲染到 el 区域中 render: h =&gt; h(App)&#125;) 4. webpack 打包发布通过 package.json 文件配置打包命令 12345678// 在package.json文件中配置 webpack 打包命令// 该命令默认加载项目根目录中的 webpack.config.js 配置文件\"scripts\": &#123; // 用于打包的命令 \"build\": \"webpack -p\", // 用于开发调试的命令 \"dev\": \"webpack-dev-server --open --host 127.0.0.1 --port 3000\",&#125;, 4，Vue 脚手架1. 安装、基本用法、项目结构 安装3.x版本的Vue脚手架 1npm install -g @vue/cli 使用 交互式命令行 vue create my-project 图形化界面vue ui 项目结构 public静态资源目录 src组件源码目录 babel.config.jsBabel配置文件 2. 自定义配置 单独的配置文件 vue.config.js,能够覆盖默认配置，结果必须是Json格式 123456// vue.config.js module.exports = &#123; devServer: &#123; port: 8888 &#125; &#125; 5，Element-UI 的基本使用官网地址为： http://element-cn.eleme.io/#/zh-CN 1. 安装 终端安装依赖包 npm i element-ui –S 图形化界面安装vue ui -&gt; Vue项目管理器 -&gt; 插件 -&gt; 添加插件 -&gt; 搜索’vue-cli-plugin-element’安装 导入 Element-UI 相关资源 123456// 导入组件库import ElementUI from 'element-ui';// 导入组件相关样式import 'element-ui/lib/theme-chalk/index.css';// 配置 Vue 插件Vue.use(ElementUI);","tags":[]},{"title":"完美解决nodejs报错 Cannot find module './application'","date":"2019-12-03T11:10:30.287Z","path":"2019/12/03/解决nodejs报错 Cannot find module/","text":"删掉node_module文件夹和package-lock.json 打开终端，键入npm clean cache，清除缓存 键入npm i，安装依赖 键入npm run start","tags":[]},{"title":"AE - 04.专题图绘制及打印功能实现","date":"2019-11-25T13:01:49.741Z","path":"2019/11/25/AE - 04.专题图绘制及打印功能实现/","text":"04.专题图绘制及打印功能实现流程图 引用类库及接口描述 引用类库： ESRI.ArcGIS.Carto：包括一些数据显示的接口和类，如ILegend,IMap,ILayer ESRI.ArcGIS.Geodatabase：提供操作地理数据库的接口，如IWorkspace,IDataset,IFeature ESRI.ArcGIS.DataSourcesFile：提供打开矢量数据的接口，如ICoverage,ICadTransformation ESRI.ArcGIS.DataSourcesRaster：提供打开一些栅格数据及转换数据的接口 ESRI.ArcGIS.Display：包括ISymbol,IColor,一些用来在地图上显示或绘制的接口和类 ESRI.ArcGIS.Geometry：包括点线面，路径，环等几何对象3D，地理坐标，投影坐标 ESRI.ArcGIS.Controls：MapControl,TOC,Toolbar,Licence,PageLayout等核心可视化组件 ESRI.ArcGIS.SystemUI：包括ICommand,ITool,等一些用户界面的接口和类 ESRI.ArcGIS.esriSystem：包括IArray,ISet,IFile,等一些基础底层接口和类 ESRI.ArcGIS.OutPut：提供一些打印、转换输出接口，如IBmpExporter 接口： IEnvelope：指地物的外接矩形，用来表示地物图形的大体位置和形状 IGraphicsContainer：提供对管理的图形元素的访问 IMapFrame：提供了访问控制地图元素对象的成员 IMapSurroundFrame：是MapSurroundFrame对象的默认接口。获取或更新存储在帧中的环绕对象（指北针、比例尺条或图例） IElement：所有图形元素和框架元素都实现的接口，它可以确定元素的Geometry属性 ITrackCancel：中断处理 IActiveView：定义了Map对象的数据显示功能。使用该接口可以改变视图的范围，刷新视图。 步骤 步骤1： 在winform页面中添加整饰操作按钮。 步骤2： 给按钮添加点击事件 步骤3： 创建元素操作文件（pagelayout_element.cs） 步骤4： 实现添加比例尺，比例文本，图例，指北针，元素 步骤5： 将添加的元素方法进一步封装 步骤6： 实现添加文本，为地图添加标题，添加格网，拉框选择 步骤7： 实现打印结果 步骤8： 运行 – &gt; 添加矢量 – &gt; 符号化 – &gt; 渲染 – &gt; 数据视图、布局视图查看 – &gt; 添加比例尺，比例文本，图例，指北针，标题 – &gt; 打印输出 代码Code Download in GitHUb","tags":[]},{"title":"AE - 01.空间书签的创建及调用","date":"2019-11-25T12:59:02.083Z","path":"2019/11/25/AE - 01.空间书签的创建及调用/","text":"AE - 01.空间书签的创建及调用流程图 引用类库及接口描述 引用类库： using ESRI.ArcGIS.Carto; 接口： 1. IMapBookmarks接口：Bookmarks属性可以得到地图文档中已经存在的所有书签对象，通过该接口的AddBookmark和RemoveBookmark方法可以对书签进行添加和删除。 2. ISpatialBookmark接口：定义所有空间书签的共同功能，特别是书签的Name属性和ZoomTo方法。Name属性定义了书签的名字，通过ZoomTo方法可跳转到书签位置点。 3. IAOIBookmark接口：继承自ISpatialBookmark接口，新增了Location属性，存储地图中感兴趣范围。步骤 步骤1： 添加控件 步骤2： 给控件添加事件，设置删除Button的可见性 步骤3： 封装功能 步骤4： 运行实现 代码七、代码 创建书签 /// &lt;summary&gt; /// 创建书签 /// &lt;/summary&gt; public Boolean CreatBookmark(string sBookmarkName) { Console.WriteLine(sBookmarkName); IAOIBookmark aoiBookmark = new AOIBookmark(); if (aoiBookmark != null) { aoiBookmark.Location = mapControl.ActiveView.Extent; aoiBookmark.Name = sBookmarkName; } IMapBookmarks bookmarks = mapControl.Map as IMapBookmarks; if (bookmarks != null) { bookmarks.AddBookmark(aoiBookmark); cmb_Bookmark.Items.Add(aoiBookmark.Name); return true; } return false; } 监听结束书签列表 /// &lt;summary&gt; /// 监听结束书签列表 /// &lt;/summary&gt; public Boolean oneBookmark(string name) { IMapBookmarks bookmarks = mapControl.Map as IMapBookmarks; IEnumSpatialBookmark enumSpatialBookmark = bookmarks.Bookmarks; enumSpatialBookmark.Reset(); ISpatialBookmark spatialBookmark = enumSpatialBookmark.Next(); while (spatialBookmark != null) { if (name == spatialBookmark.Name) { return false; } spatialBookmark = enumSpatialBookmark.Next(); } return true; } 选中书签列表item private void cmb_Bookmark_SelectedIndexChanged(object sender, EventArgs e) { IMapBookmarks bookmarks = mapControl.Map as IMapBookmarks; IEnumSpatialBookmark enumSpatialBookmark = bookmarks.Bookmarks; enumSpatialBookmark.Reset(); ISpatialBookmark spatialBookmark = enumSpatialBookmark.Next(); while (spatialBookmark != null) { string index = cmb_Bookmark.SelectedIndex.ToString(); string bm_name = cmb_Bookmark.Items[Convert.ToInt32(index)].ToString(); //Console.WriteLine(bm_name + &quot; &quot;+ spatialBookmark.Name); if (bm_name == spatialBookmark.Name) { spatialBookmark.ZoomTo((IMap)mapControl.ActiveView); mapControl.ActiveView.Refresh(); break; } spatialBookmark = enumSpatialBookmark.Next(); } btn_bmDEL.Visible = true; but_addbm.Visible = false; } 添加书签 private void but_addbm_Click(object sender, EventArgs e) { addBookmark add = new addBookmark(this); add.Show(); } 删除书签 private void btn_bmDEL_Click(object sender, EventArgs e) { cmb_Bookmark.Items.Remove(cmb_Bookmark.SelectedItem); cmb_Bookmark.Text = &quot;&quot;; if (cmb_Bookmark.Items.Count == 0) cmb_Bookmark.Text = &quot;无书签&quot;; btn_bmDEL.Visible = false; but_addbm.Visible = true; }","tags":[]},{"title":"AE学习笔记","date":"2019-11-25T12:59:02.081Z","path":"2019/11/25/AE学习笔记/","text":"空间书签的创建及调用 矢量、栅格、Mxd的加载 符号库设计与实现 专题图绘制及打印功能实现","tags":[]},{"title":"AE - 03.符号库设计与实现","date":"2019-11-25T12:59:02.078Z","path":"2019/11/25/AE - 03.符号库设计与实现/","text":"03.符号库设计与实现流程图 #####引用类库及接口描述 引用类库： ESRI.ArcGIS.Carto：包括一些数据显示的接口和类，如ILegend,IMap,ILayer ESRI.ArcGIS.Geodatabase：提供操作地理数据库的接口，如IWorkspace,IDataset,IFeature ESRI.ArcGIS.DataSourcesFile：提供打开矢量数据的接口，如ICoverage,ICadTransformation ESRI.ArcGIS.DataSourcesRaster：提供打开一些栅格数据及转换数据的接口 ESRI.ArcGIS.Display：包括ISymbol,IColor,一些用来在地图上显示或绘制的接口和类 ESRI.ArcGIS.Geometry：包括点线面，路径，环等几何对象3D，地理坐标，投影坐标 ESRI.ArcGIS.Controls：MapControl,TOC,Toolbar,Licence,PageLayout等核心可视化组件 ESRI.ArcGIS.SystemUI：包括ICommand,ITool,等一些用户界面的接口和类 ESRI.ArcGIS.esriSystem：包括IArray,ISet,IFile,等一些基础底层接口和类 接口： IRgbColor：使用RGB（红色，绿色，蓝色）颜色模型维护有关颜色的信息 IColor：IRgbColor的父类接口。符号颜色向Symbol赋值需要接口转换为IColor ISimpleFillSymbol：用于创建简单面状符号 ISimpleLineSymbol：用于创建简单线状符号 ISimpleMarkerSymbol：用于创建简单点状符号 ISymbol：符号接口，所有的符号类都实现了这个接口，符号向渲染器赋值需转换为ISymbol IGeoFeatureLayer：对基于矢量地理数据的图层的符号化和标签属性的访问 IFeatureLayer：访问要素图层常见内容，访问基于矢量图形数据图层的属性和方法 IFeatureRenderer：提供对控制渲染器共有功能的成员的访问。要素渲染器都实现此接口。 步骤 步骤1： 在winform页面中添加渲染按钮。 步骤2： 创建符号化，渲染窗口程序。 步骤3： 为渲染窗口的开始按钮添加事件，获取参数值。 步骤4： 创建符号化渲染操作类(C_S_R) 步骤5： 实现获取颜色，宽度，符号化，渲染方法。 步骤6： 运行 – &gt; 添加矢量 – &gt; 主页面触发渲染 – &gt; 设置参数 – &gt;符号化 – &gt; 渲染 – &gt; 数据视图、布局视图查看 代码Code Download in GitHUb","tags":[]},{"title":"AE - 02.矢量、栅格、Mxd的加载","date":"2019-11-25T12:59:02.076Z","path":"2019/11/25/AE - 02.矢量、栅格、Mxd的加载/","text":"02.矢量、栅格、Mxd的加载流程图 #####引用类库及接口描述 引用类库： using ESRI.ArcGIS.Carto; using ESRI.ArcGIS.Geometry; using ESRI.ArcGIS.Geodatabase; using ESRI.ArcGIS.DataSourcesFile; using ESRI.ArcGIS.DataSourcesRaster; 接口： 1. OpenFileDialog 接口：用于打开文件对话框 2. IWorkspaceFactory 接口：工作空间工厂，工作空间的发布者，允许客户连接通过一组连接属性定义的工作空间。普通类。 3. IWorkspace 接口：提供访问工作空间的通用属性和方法，如它的连接属性，以及包含的数据集的方法。 4. IFeatureWorkspace 接口：用于访问和管理地理数据库中的要素的重要成分—数据集。 5. IRasterWorkspace 接口：用于打开和建立基于文件的RasterDataset。 6. IFeatureClass 接口：获取和设置要素类属性的主要接口。 7. IFeatureLayer 接口：继承自ILayer,提供了访问基于矢量数据图层的属性和方法。、 8. ILayer 接口：Layer 是图层对象，是数据的外壳，必须建立在数据的基础上才有意义。 9. IMap 接口：许多图层的集合，由多个ILayer构成。结构 矢量 获取shp文件的路径和文件名称 由工作空间工厂创建Shp工作空间工厂类，打开工作空间 转换工作空间为要素工作空间，打开要素类 创建要素图层，设置要素图层的FeatureClass为上面打开的要素类 转换IFeatureLayer为ILayer，添加到mapcontorl中。 刷新 栅格 获取shp文件的路径和文件名称 由工作空间工厂创建Raster工作空间工厂类，打开工作空间 转换工作空间为栅格工作空间，打开栅格数据集 影像金字塔的判断和创建 新建栅格图层，添加到mapcontorl中。 刷新 代码七、代码 打开按钮的点击事件 private void menu_open_Click(object sender, EventArgs e) { addMapFile(); } 打开文件 private void addMapFile() { OpenFileDialog pOpenfileDialog = new OpenFileDialog(); pOpenfileDialog.Filter = &quot;全部文件|*.*&quot; + &quot;|Shape 文件|*.shp&quot; + &quot;|Mxd 文件|*.mxd&quot; + &quot;|栅格 文件|*.tif;*.tiff;*.jpep;*.jpg;*.png;*.bmp&quot;; if (pOpenfileDialog.ShowDialog() == DialogResult.OK) { string path = pOpenfileDialog.FileName; bool shp = path.EndsWith(&quot;.shp&quot;); bool mxd = path.EndsWith(&quot;.mxd&quot;); bool tif = path.EndsWith(&quot;.tif&quot;) || path.EndsWith(&quot;.tiff&quot;) || path.EndsWith(&quot;.jpep&quot;) || path.EndsWith(&quot;.jpg&quot;) || path.EndsWith(&quot;.png&quot;) || path.EndsWith(&quot;.bmp&quot;); if (shp) openShpFile(path); else if (mxd) openShpFile(path); else if (tif) openShanGe(path); } } 打开shp /// &lt;summary&gt; /// 打开shp数据 /// &lt;/summary&gt; private void openShpFile(string file) { int index = 0; index = file.LastIndexOf(&quot;\\\\&quot;); string filePath = file.Substring(0, index); string fileName = file.Substring(index + 1, file.Length - (index + 1)); IWorkspaceFactory pWorkspaceFactory = new ShapefileWorkspaceFactory(); IWorkspace pWorkspace = pWorkspaceFactory.OpenFromFile(filePath, 0); IFeatureWorkspace pFeatureWokkspace = pWorkspace as IFeatureWorkspace; IFeatureClass pFC = pFeatureWokkspace.OpenFeatureClass(fileName); IFeatureLayer pFLayer = new FeatureLayer(); pFLayer.FeatureClass = pFC; pFLayer.Name = pFC.AliasName; ILayer pLayer = pFLayer as ILayer; IMap pMap = mapControl.Map; pMap.AddLayer(pLayer); mapControl.ActiveView.Refresh(); } 打开栅格 /// &lt;summary&gt; /// 打开栅格数据 /// &lt;/summary&gt; private void openShanGe(string Path) { string RasterPath = System.IO.Path.GetDirectoryName(Path); string RasterName = System.IO.Path.GetFileName(Path); IWorkspaceFactory pRasterWsF = new RasterWorkspaceFactory(); IWorkspace pWs = pRasterWsF.OpenFromFile(RasterPath, 0); IRasterWorkspace pRasterWs = pWs as IRasterWorkspace; IRasterDataset pRasterDS = pRasterWs.OpenRasterDataset(RasterName); IRasterPyramid pRasterPyramid = pRasterDS as IRasterPyramid; if ((pRasterPyramid != null)&amp;&amp;(!pRasterPyramid.Present)) { if (MessageBox.Show(&quot;是否开始创建金字塔？&quot;, &quot;提示&quot;, MessageBoxButtons.OKCancel, MessageBoxIcon.Question, MessageBoxDefaultButton.Button1) == System.Windows.Forms.DialogResult.OK) { Stopwatch sw = new Stopwatch(); sw.Start(); pRasterPyramid.Create(); sw.Stop(); MessageBox.Show(&quot;创建完成，Time：&quot;+ sw.ElapsedMilliseconds.ToString()+&quot;ms&quot;); } else MessageBox.Show(&quot;放弃创建金字塔&quot;); } IRasterLayer pRasterLayer = new RasterLayer(); pRasterLayer.CreateFromRaster(pRasterDS.CreateDefaultRaster()); IMap pmap = mapControl.Map; pmap.AddLayer(pRasterLayer); mapControl.ActiveView.Refresh(); OpenStatus(); } 打开mxd /// &lt;summary&gt; /// 打开mxd数据 /// &lt;/summary&gt; private void openMXD(string path) { mapControl.MousePointer = esriControlsMousePointer.esriPointerHourglass; mapControl.LoadMxFile(path, 0, Type.Missing); mapControl.MousePointer = esriControlsMousePointer.esriPointerDefault; OpenStatus(); }","tags":[]},{"title":"Express+multer+Ajax 上传图片并加载","date":"2019-11-23T10:34:41.534Z","path":"2019/11/23/Express+multer+Ajax 上传图片并加载/","text":"html&lt;input id=&quot;files&quot; type=&quot;file&quot; name=&quot;file&quot; multiple/&gt; &lt;input type=&quot;submit&quot; id=&quot;shangchuan&quot; value=&quot;上传&quot;/&gt; &lt;ul&gt; &lt;li&gt;&lt;img src=&quot;images/f.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt; &lt;/ul&gt; 需要注意的是里面的name属性，需要和js中的代码一一对应 js$(function () { $(&quot;#shangchuan&quot;).click(function () { var file = document.getElementById(&quot;files&quot;).files[0]; var formdata=new FormData(); formdata.append(&quot;file&quot;,file); $.ajax({ type: &apos;POST&apos;, url: &apos;/upload&apos;, processData:false,//对data参数进行序列化处理 contentType:false,//内容编码类型 cache:false,//不使用缓存 data: formdata, success: function(data) { var $li = $(&quot;&lt;li&gt;&lt;img src=\\&quot;images/&quot;+ file.name +&quot;\\&quot; alt=\\&quot;\\&quot;&gt;&lt;/li&gt;&quot;); $(&quot;ul&quot;).append($li); } }); }); }); formdata.append(&quot;file&quot;,file);最终的提交还是以from表单的形式，在给表单中添加需要上传的文件时，类似键值对。这里的键名对应的时name属性而不是id 其中的：processData，contentType:false，cache的添加是必须的，对于上传文件来说 应为Ajax请求时异步得，所以将添加放置在success的回调函数中，创建的节点很容易出错，需要十分注意转义符号的使用，做好打印看看 nodejsapp.post(&apos;/upload&apos;, multer({dest: &apos;./public/upload_tmp/&apos;}).array(&apos;file&apos;, 10), function (req, res, next) { //这里10表示最大支持的文件上传数目 let files = req.files; console.log(files); if (files.length === 0) { res.render(&quot;error&quot;, {message: &quot;上传文件不能为空！&quot;}); return } else { let fileInfos = []; for (var i in files) { let file = files[i]; let fileInfo = {}; fs.renameSync(&apos;./public/upload_tmp/&apos; + file.filename, &apos;./public/images/&apos; + file.originalname);//这里修改文件名字，比较随意。 //获取文件基本信息 fileInfo.mimetype = file.mimetype; fileInfo.originalname = file.originalname; fileInfo.size = file.size; fileInfo.path = file.path; fileInfos.push(fileInfo); } // 设置响应类型及编码 res.set({ &apos;content-type&apos;: &apos;application/json; charset=utf-8&apos; }); res.json({&quot;result&quot;:{message:&quot;success&quot;}}); res.end(&quot;success!&quot;); } }); .array(&#39;file&#39;, 10)中的file对应，表单对象中存储文件的键名 res.json({&quot;result&quot;:{message:&quot;success&quot;}});这里的这个似乎没有用，但是经过测试，没有这个的时候不能返回success状态 如果要返回，那么设置相应类型及编码最好写上，自测出现了BUG，添加之后通过。","tags":[]},{"title":"封装Cookie.js+使用","date":"2019-11-17T13:28:16.120Z","path":"2019/11/17/封装Cookie.js+使用/","text":"Cookie 1. 添加function addCookie(key, value, day, path, domain) { // 1.处理默认保存的路径 var index = window.location.pathname.lastIndexOf(&quot;/&quot;) var currentPath = window.location.pathname.slice(0, index); path = path || currentPath; // 2.处理默认保存的domain domain = domain || document.domain; // 3.处理默认的过期时间 if (!day) { document.cookie = key + &quot;=&quot; + value + &quot;;path=&quot; + path + &quot;;domain=&quot; + domain + &quot;;&quot;; } else { var date = new Date(); date.setDate(date.getDate() + day); document.cookie = key + &quot;=&quot; + value + &quot;;expires=&quot; + date.toGMTString() + &quot;;path=&quot; + path + &quot;;domain=&quot; + domain + &quot;;&quot;; } }虽然参数有很多，实际使用的时候并不需要这么麻烦。 最简单：addCookie(&quot;city&quot;,&quot;北京&quot;,); 这样就创建了一个Cookie，它的名字为city，值为北京 参数依此为：键名，键值，生存周期，有效路径，域名白名单 键名：名称，不可修改 键值：值，Unicode字符，需要字符编码。二进制数据，需要BASE64编码 生存周期：失效时间，单位为秒，默认为关闭浏览器失效 有效路径：可以访问该Cookie的路径，默认和创建路径相同，设置为&quot;/&quot;代表本域名之下所有文件都可以访问，类似与全局变量 域名白名单：可以访问这条Cookie的域名 2. 获取function getCookie(key) { // console.log(document.cookie); var res = document.cookie.split(&quot;;&quot;); // console.log(res); for(var i = 0; i &lt; res.length; i++){ // console.log(res[i]); var temp = res[i].split(&quot;=&quot;); // console.log(temp); if(temp[0].trim() === key){ return temp[1]; } } } getCookie(key)参数为键名 3. 删除 只要生存时间过期了，这条Cookie就没有了 默认情况下只能删除默认路径中保存的cookie,。 如果想删除指定路径保存的cookie, 那么必须在删除的时候指定路径才可以 function delCookie(key, path) { addCookie(key, getCookie(key), -1, path); } path参数可不写 delCookie(&quot;city&quot;)即可删除创建的那条Cookie 创建固定生存周期，删除，按需修改即可 怎么查看呢？F12 --&gt; Application --&gt; Cookies --&gt; （域名）--&gt; result 封装好了，可别忘记引入哦","tags":[]},{"title":"Nodejs自动重启工具配置 [ nodemon ]","date":"2019-11-13T06:13:41.980Z","path":"2019/11/13/Nodejs自动重启工具配置 [ nodemon ]/","text":"1. 安装依赖包1npm i nodemon --save 2.修改package.json文件找到scripts&quot;scripts&quot;: { &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; },在scripts下面添加start&quot;scripts&quot;: { &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;start&quot;: &quot;nodemon app.js&quot; },3. app.js根目录下打开终端，键入npm run start4. 修改后，ctrl+s保存之后，项目变化重新启动。","tags":[]},{"title":"Express+multer 上传图片（单文件，多文件）","date":"2019-11-11T13:24:37.645Z","path":"2019/11/11/Express+multer 上传图片（单文件，多文件）/","text":"fs模块异步上传 app.post(&apos;/upload&apos;, upload.any(), function(req, res, next) { //req.files[0]// 上传的文件信息 //需要Express托管静态文件public文件夹 var des_file = &quot;./public/images/&quot; + req.files[0].originalname; fs.readFile( req.files[0].path, function (err, data) { fs.writeFile(des_file, data, function (err) { if( err ){ console.log( err ); }else{ console.log( req.files[0].originalname ); } }); }); });multer模块引入npm i multer --save multer单文件上传 //dest设置上传原始文件的路径，single要与file的name保持一致 app.post(&apos;/upload&apos;, multer({dest: &apos;./public/upload_tmp/&apos;}) .single(&apos;file&apos;), function (req, res, next) { if (req.file.length === 0) { res.render(&quot;error&quot;, {message: &quot;上传文件不能为空！&quot;}); return } else { let file = req.file; //存储上传对象信息 let fileInfo = {}; //修改名字，第一个参数为旧路径，第二个参数为新路径（注意：旧路径要和上面的dest保持一致） fs.renameSync(&apos;./public/upload_tmp/&apos; + file.filename, &apos;./public/images/&apos; + file.originalname); // 获取文件信息 fileInfo.mimetype = file.mimetype; fileInfo.originalname = file.originalname; fileInfo.size = file.size; fileInfo.path = file.path; //设置响应类型、编码 res.set({ &apos;content-type&apos;: &apos;application/json; charset=utf-8&apos; }); res.end(&quot;成功&quot;); } });multer多文件上传 //与单文件相比唯一的不同就是不再使用.single //改为.array(&apos;file&apos;, 10)，其中的file和.single的参数一样，10为上传数目的最大限制 app.post(&apos;/upload&apos;, multer({dest: &apos;./public/upload_tmp/&apos;}).array(&apos;file&apos;, 10), function (req, res, next) { let files = req.files; if (files.length === 0) { res.render(&quot;error&quot;, {message: &quot;上传文件不能为空！&quot;}); return } else { let fileInfos = []; for (var i in files) { let file = files[i]; let fileInfo = {}; fs.renameSync(&apos;./public/upload_tmp/&apos; + file.filename, &apos;./public/images/&apos; + file.originalname); //获取文件基本信息 fileInfo.mimetype = file.mimetype; fileInfo.originalname = file.originalname; fileInfo.size = file.size; fileInfo.path = file.path; fileInfos.push(fileInfo); } // 设置响应类型、编码 res.set({ &apos;content-type&apos;: &apos;application/json; charset=utf-8&apos; }); res.end(&quot;成功&quot;); } });html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;/upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;!-- multiple允许多文件上传，单文件可忽略--&gt; &lt;input id=&quot;files&quot; type=&quot;file&quot; name=&quot;file&quot; multiple/&gt; &lt;input type=&quot;submit&quot; value=&quot;上传&quot;/&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt;","tags":[]},{"title":"18 - 对联广告，弹窗广告练习","date":"2019-10-23T08:17:29.508Z","path":"2019/10/23/18 - 对联广告，弹窗广告练习/","text":"对联广告&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;40-对联广告&lt;/title&gt; &lt;style&gt; *{ margin: 0; padding: 0; } .left{ float: left; position: fixed; left: 0; top: 200px; } .right{ float: right; position: fixed; right: 0; top: 200px; } img{ display: none; } &lt;/style&gt; &lt;script src=&quot;js/jquery-1.12.4.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function () { // 1.监听网页的滚动 $(window).scroll(function () { // 1.1获取网页滚动的偏移位 var offset = $(&quot;html,body&quot;).scrollTop(); // 1.2判断网页是否滚动到了指定的位置 if(offset &gt;= 500){ // 1.3显示广告 $(&quot;img&quot;).show(1000); }else{ // 1.4隐藏广告 $(&quot;img&quot;).hide(1000); } }); }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;img src=&quot;images/left_ad.png&quot; class=&quot;left&quot;&gt; &lt;img src=&quot;images/right_ad.png&quot; class=&quot;right&quot;&gt; &lt;br&gt; &lt;br&gt; 。 。 。 （此处省略五百个&lt;br&gt;） 。 。 。 &lt;br&gt; &lt;/body&gt; &lt;/html&gt;弹窗广告&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;46-弹窗广告&lt;/title&gt; &lt;style&gt; *{ margin: 0; padding: 0; } .ad{ position: fixed; right: 0; bottom: 0; display: none; } .ad&gt;span{ display: inline-block; width: 30px; height: 30px; position: absolute; top: 0; right: 0; } &lt;/style&gt; &lt;script src=&quot;js/jquery-1.12.4.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function () { // 1.监听span的点击事件 $(&quot;span&quot;).click(function () { $(&quot;.ad&quot;).remove(); }); // 2.执行广告动画 /* $(&quot;.ad&quot;).slideDown(1000, function () { $(&quot;.ad&quot;).fadeOut(1000, function () { $(&quot;.ad&quot;).fadeIn(1000); }); }); */ $(&quot;.ad&quot;).stop().slideDown(1000).fadeOut(1000).fadeIn(1000); }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;ad&quot;&gt; &lt;img src=&quot;images/ad-pic.png&quot; alt=&quot;&quot;&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;","tags":[]},{"title":"17 - 折叠菜单练习，下拉菜单练习","date":"2019-10-23T08:17:29.506Z","path":"2019/10/23/17 - 折叠菜单练习，下拉菜单练习/","text":"折叠菜单&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;43-折叠菜单下&lt;/title&gt; &lt;style&gt; *{ margin: 0; padding: 0; } .nav{ list-style: none; width: 300px; margin: 100px auto; /*border: 1px solid #000;*/ } .nav&gt;li{ border: 1px solid #000; line-height: 35px; border-bottom: none; text-indent: 2em; position: relative; } .nav&gt;li:last-child{ border-bottom: 1px solid #000; border-bottom-right-radius: 10px; border-bottom-left-radius: 10px; } .nav&gt;li:first-child{ border-top-right-radius: 10px; border-top-left-radius: 10px; } .nav&gt;li&gt;span{ background: url(&quot;images/arrow_right.png&quot;) no-repeat center center; display: inline-block; width: 32px; height: 32px; position: absolute; right: 10px; top: 5px; } .sub{ display: none; } .sub&gt;li{ list-style: none; background: mediumpurple; border-bottom: 1px solid white; } .sub&gt;li:hover{ background: red; } .nav&gt;.current&gt;span{ transform: rotate(90deg); } &lt;/style&gt; &lt;script src=&quot;js/jquery-1.12.4.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function () { // 1.监听一级菜单的点击事件 $(&quot;.nav&gt;li&quot;).click(function () { // 1.1拿到二级菜单 var $sub = $(this).children(&quot;.sub&quot;); // 1.2让二级菜单展开 $sub.slideDown(1000); // 1.3拿到所有非当前的二级菜单 var otherSub = $(this).siblings().children(&quot;.sub&quot;); // 1.4让所有非当前的二级菜单收起 otherSub.slideUp(1000); // 1.5让被点击的一级菜单箭头旋转 $(this).addClass(&quot;current&quot;); // 1.6让所有非被点击的一级菜单箭头还原 $(this).siblings().removeClass(&quot;current&quot;); }); }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;ul class=&quot;nav&quot;&gt; &lt;li&gt;一级菜单&lt;span&gt;&lt;/span&gt; &lt;ul class=&quot;sub&quot;&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;一级菜单&lt;span&gt;&lt;/span&gt; &lt;ul class=&quot;sub&quot;&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;一级菜单&lt;span&gt;&lt;/span&gt; &lt;ul class=&quot;sub&quot;&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;一级菜单&lt;span&gt;&lt;/span&gt; &lt;ul class=&quot;sub&quot;&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;一级菜单&lt;span&gt;&lt;/span&gt; &lt;ul class=&quot;sub&quot;&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;一级菜单&lt;span&gt;&lt;/span&gt; &lt;ul class=&quot;sub&quot;&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;一级菜单&lt;span&gt;&lt;/span&gt; &lt;ul class=&quot;sub&quot;&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;一级菜单&lt;span&gt;&lt;/span&gt; &lt;ul class=&quot;sub&quot;&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt;下拉菜单&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;44-下拉菜单&lt;/title&gt; &lt;style&gt; *{ margin: 0; padding: 0; } .nav{ list-style: none; width: 300px; height: 50px; background: red; margin: 100px auto; } .nav&gt;li{ width: 100px; height: 50px; line-height: 50px; text-align: center; float: left; } .sub{ list-style: none; background: mediumpurple; display: none; } &lt;/style&gt; &lt;script src=&quot;js/jquery-1.12.4.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function () { /* 在jQuery中如果需要执行动画, 建议在执行动画之前先调用stop方法,然后再执行动画 */ // 1.监听一级菜单的移入事件 $(&quot;.nav&gt;li&quot;).mouseenter(function () { // 1.1拿到二级菜单 var $sub = $(this).children(&quot;.sub&quot;); // 停止当前正在运行的动画： $sub.stop(); // 1.2让二级菜单展开 $sub.slideDown(1000); }); // 2.监听一级菜单的移出事件 $(&quot;.nav&gt;li&quot;).mouseleave(function () { // 1.1拿到二级菜单 var $sub = $(this).children(&quot;.sub&quot;); // 停止当前正在运行的动画： $sub.stop(); // 1.2让二级菜单收起 $sub.slideUp(1000); }); }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;ul class=&quot;nav&quot;&gt; &lt;li&gt;一级菜单 &lt;ul class=&quot;sub&quot;&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;li&gt;二级菜单&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;一级菜单&lt;/li&gt; &lt;li&gt;一级菜单&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt;","tags":[]},{"title":"16 - 动画合集（显示隐藏，展开收起，淡入淡出，自定义）","date":"2019-10-23T08:17:29.504Z","path":"2019/10/23/16 - 动画合集（显示隐藏，展开收起，淡入淡出，自定义）/","text":"显示，隐藏 显示$(&quot;div&quot;).show(1000, function () {}); 隐藏$(&quot;div&quot;).hide(1000, function () {}); 切换$(&quot;div&quot;).toggle(1000, function () {}); 示例代码： $(function () { // 编写jQuery相关代码 $(\"button\").eq(0).click(function () { // $(\"div\").css(\"display\", \"block\"); // 注意: 这里的时间是毫秒 $(\"div\").show(1000, function () { // 作用: 动画执行完毕之后调用 alert(\"显示动画执行完毕\"); }); }); $(\"button\").eq(1).click(function () { // $(\"div\").css(\"display\", \"none\"); $(\"div\").hide(1000, function () { alert(\"隐藏动画执行完毕\"); }); }); $(\"button\").eq(2).click(function () { $(\"div\").toggle(1000, function () { alert(\"切换动画执行完毕\"); }); }); }); 展开，收起 显示$(&quot;div&quot;).slideDown(1000, function () {}); 隐藏$(&quot;div&quot;).slideUp(1000, function () {}); 切换$(&quot;div&quot;).slideToggle(1000, function () {});示例代码： &lt;script&gt; $(function () { // 编写jQuery相关代码 $(&quot;button&quot;).eq(0).click(function () { $(&quot;div&quot;).slideDown(1000, function () { alert(&quot;展开完毕&quot;); }); }); $(&quot;button&quot;).eq(1).click(function () { $(&quot;div&quot;).slideUp(1000, function () { alert(&quot;收起完毕&quot;); }); }); $(&quot;button&quot;).eq(2).click(function () { $(&quot;div&quot;).slideToggle(1000, function () { alert(&quot;收起完毕&quot;); }); }); }); &lt;/script&gt;淡入淡出 淡入$(&quot;div&quot;).slideDown(1000, function () {}); 淡出$(&quot;div&quot;).slideUp(1000, function () {}); 切换$(&quot;div&quot;).slideToggle(1000, function () {}); 淡入到$(&quot;div&quot;).fadeTo(1000, function () {});示例代码： &lt;script&gt; $(function () { // 编写jQuery相关代码 $(&quot;button&quot;).eq(0).click(function () { $(&quot;div&quot;).fadeIn(1000, function () { alert(&quot;淡入完毕&quot;); }); }); $(&quot;button&quot;).eq(1).click(function () { $(&quot;div&quot;).fadeOut(1000, function () { alert(&quot;淡出完毕&quot;); }); }); $(&quot;button&quot;).eq(2).click(function () { $(&quot;div&quot;).fadeToggle(1000, function () { alert(&quot;切换完毕&quot;); }); }); $(&quot;button&quot;).eq(3).click(function () { $(&quot;div&quot;).fadeTo(1000, 0.2, function () { alert(&quot;淡入完毕&quot;); }) }); }); &lt;/script&gt;自定义动画第一个参数: 接收一个对象, 可以在对象中修改属性第二个参数: 指定动画时长第三个参数: 指定动画节奏, 默认就是swing第四个参数: 动画执行完毕之后的回调函数 操作属性 $(&quot;.two&quot;).animate({ marginLeft: 500 }, 5000, &quot;linear&quot;, function () { // alert(&quot;自定义动画执行完毕&quot;); }); 累加属性 $(&quot;.one&quot;).animate({ width: &quot;+=100&quot; }, 1000, function () { alert(&quot;自定义动画执行完毕&quot;); }); 关键字 $(&quot;.one&quot;).animate({ // width: &quot;hide&quot;隐藏 // width: &quot;show&quot;显示 width: &quot;toggle&quot;切换 }, 1000, function () { alert(&quot;自定义动画执行完毕&quot;); });","tags":[]},{"title":"15 - 命名空间，委托，移入移出","date":"2019-10-23T08:17:29.502Z","path":"2019/10/23/15 - 命名空间，委托，移入移出/","text":"命名空间 事件是通过on来绑定的 通过trigger触发事件 $(&quot;.son&quot;).on(&quot;click.ls&quot;, function () { alert(&quot;click2&quot;); }); $(&quot;.son&quot;).trigger(&quot;click.ls&quot;);PS： 利用trigger触发子元素带命名空间的事件, 那么父元素带相同命名空间的事件也会被触发. 而父元素没有命名空间的事件不会被触发 利用trigger触发子元素不带命名空间的事件,那么子元素所有相同类型的事件和父元素所有相同类型的事件都会被触发 示例代码： $(function () { $(\".father\").on(\"click.ls\", function () { alert(\"father click1\"); }); $(\".father\").on(\"click\", function () { alert(\"father click2\"); }); $(\".son\").on(\"click.ls\", function () { alert(\"son click1\"); }); // $(\".son\").trigger(\"click.ls\"); $(\".son\").trigger(\"click\"); }); 委托 什么是事件委托?请别人帮忙做事情, 然后将做完的结果反馈给我们 PS：如果通过核心函数找到的元素不止一个, 那么在添加事件的时候,jQuery会遍历所有找到的元素,给所有找到的元素添加事件 $(&quot;ul&gt;li&quot;).click(function () { console.log($(this).html()); });示例：让ul帮li监听click事件 之所以能够监听, 是因为入口函数执行的时候ul就已经存在了, 所以能够添加事件 之所以this是li,是因为点击的是li, 而li没有click事件, 所以事件冒泡传递给了ul,ul响应了事件, 既然事件是从li传递过来的,所以ul必然知道this是谁 $(&quot;ul&quot;).delegate(&quot;li&quot;, &quot;click&quot;, function () { console.log($(this).html()); });委托联系&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;32-jQuery事件委托练习&lt;/title&gt; &lt;style&gt; *{ margin: 0; padding: 0; } html,body{ width: 100%; height: 100%; } .mask{ width: 100%; height: 100%; background: rgba(0,0,0,0.5); position: fixed; top: 0; left: 0; } .login{ width: 522px; height: 290px; margin: 100px auto; position: relative; } .login&gt;span{ width: 50px; height: 50px; /*background: red;*/ position: absolute; top: 0; right: 0; } &lt;/style&gt; &lt;script src=&quot;js/jquery-1.12.4.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function () { // 编写jQuery相关代码 $(&quot;a&quot;).click(function () { var $mask = $(&quot;&lt;div class=\\&quot;mask\\&quot;&gt;\\n&quot; + &quot; &lt;div class=\\&quot;login\\&quot;&gt;\\n&quot; + &quot; &lt;img src=\\&quot;images/login.png\\&quot; alt=\\&quot;\\&quot;&gt;\\n&quot; + &quot; &lt;span&gt;&lt;/span&gt;\\n&quot; + &quot; &lt;/div&gt;\\n&quot; + &quot;&lt;/div&gt;&quot;); // 添加蒙版 $(&quot;body&quot;).append($mask); $(&quot;body&quot;).delegate(&quot;.login&gt;span&quot;, &quot;click&quot;, function () { // 移除蒙版 $mask.remove(); }); return false; }); }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!--&lt;div class=&quot;mask&quot;&gt;--&gt; &lt;!--&lt;div class=&quot;login&quot;&gt;--&gt; &lt;!--&lt;images src=&quot;images/login.png&quot; alt=&quot;&quot;&gt;--&gt; &lt;!--&lt;span&gt;&lt;/span&gt;--&gt; &lt;!--&lt;/div&gt;--&gt; &lt;!--&lt;/div&gt;--&gt; &lt;a href=&quot;http://www.baidu.com&quot;&gt;点击登录&lt;/a&gt; &lt;div&gt;我是段落...（此处省略1W字）...我是段落&lt;/div&gt; &lt;/body&gt; &lt;/html&gt;移入移出 mouseover/mouseout事件, 子元素被移入移出也会触发父元素的事件 $(&quot;.father&quot;).mouseover(function () { console.log(&quot;father被移入了&quot;); }); $(&quot;.father&quot;).mouseout(function () { console.log(&quot;father被移出了&quot;); }); mouseenter/mouseleave事件, 子元素被移入移出不会触发父元素的事件 $(&quot;.father&quot;).mouseenter(function () { console.log(&quot;father被移入了&quot;); }); $(&quot;.father&quot;).mouseleave(function () { console.log(&quot;father被移出了&quot;); });简便写法： $(&quot;.father&quot;).hover(function () { console.log(&quot;father被移入了&quot;); },function () { console.log(&quot;father被移出了&quot;); }); $(&quot;.father&quot;).hover(function () { console.log(&quot;father被移入移出了&quot;); });","tags":[]},{"title":"14 - 冒泡，默认行为，自动触发，自定义事件","date":"2019-10-23T08:17:29.500Z","path":"2019/10/23/14 - 冒泡，默认行为，自动触发，自定义事件/","text":"事件冒泡 什么是事件冒泡？触发子元素的时候，会触发父元素绑定的事件 如何阻止事件冒泡？ 在子元素绑定的事件中 添加return false; 在子元素绑定的事件中 添加event.stopPropagation(); 默认行为 什么是默认行为？a标签点击事件默认会触发跳转到href中的链接地址去 如何组织默认行为？ 在子元素绑定的事件中 添加return false; 在子元素绑定的事件中 添加event.preventDefault(); 自动触发 trigger: 如果利用trigger自动触发事件,会触发事件冒泡，会触发默认行为 triggerHandler: 如果利用triggerHandler自动触发事件, 不会触发事件冒泡，不会触发默认行为 示例代码：&lt;script&gt; $(function () { $(&quot;.son&quot;).click(function (event) { alert(&quot;son&quot;); }); $(&quot;.father&quot;).click(function () { alert(&quot;father&quot;); }); $(&quot;.father&quot;).trigger(&quot;click&quot;); $(&quot;.father&quot;).triggerHandler(&quot;click&quot;); $(&quot;.son&quot;).trigger(&quot;click&quot;); $(&quot;.son&quot;).triggerHandler(&quot;click&quot;); $(&quot;input[type=&apos;submit&apos;]&quot;).click(function () { alert(&quot;submit&quot;); }); $(&quot;input[type=&apos;submit&apos;]&quot;).trigger(&quot;click&quot;); $(&quot;input[type=&apos;submit&apos;]&quot;).triggerHandler(&quot;click&quot;); $(&quot;span&quot;).click(function () { alert(&quot;a&quot;); }); // $(&quot;a&quot;).triggerHandler(&quot;click&quot;); $(&quot;span&quot;).trigger(&quot;click&quot;); }); &lt;/script&gt;自定义事件 事件必须是通过on绑定的 事件必须通过trigger来触发 示例代码：$(&quot;.son&quot;).on(&quot;myClick&quot;, function () { alert(&quot;son&quot;); }); $(&quot;.son&quot;).triggerHandler(&quot;myClick&quot;);","tags":[]},{"title":"13 - 绑定，移除事件","date":"2019-10-23T08:17:29.498Z","path":"2019/10/23/13 - 绑定，移除事件/","text":"绑定 eventName(fn);编码效率略高/ 部分事件jQuery没有实现,所以不能添加 on(eventName, fn);编码效率略低/ 所有js事件都可以添加 注意点:可以添加多个相同或者不同类型的事件,不会覆盖 示例代码：&lt;script&gt; $(&quot;button&quot;).click(function () { alert(&quot;hello lnj&quot;); }); $(&quot;button&quot;).click(function () { alert(&quot;hello 123&quot;); }); $(&quot;button&quot;).mouseleave(function () { alert(&quot;hello mouseleave&quot;); }); $(&quot;button&quot;).mouseenter(function () { alert(&quot;hello mouseenter&quot;); }); $(&quot;button&quot;).on(&quot;click&quot;, function () { alert(&quot;hello click1&quot;); }); $(&quot;button&quot;).on(&quot;click&quot;, function () { alert(&quot;hello click2&quot;); }); $(&quot;button&quot;).on(&quot;mouseleave&quot;, function () { alert(&quot;hello mouseleave&quot;); }); $(&quot;button&quot;).on(&quot;mouseenter&quot;, function () { alert(&quot;hello mouseenter&quot;); }); &lt;/script&gt;移除 off方法如果不传递参数, 会移除所有的事件 $(&quot;button&quot;).off(); off方法如果传递一个参数, 会移除所有指定类型的事件 $(&quot;button&quot;).off(&quot;click&quot;); off方法如果传递两个参数, 会移除所有指定类型的指定事件 $(&quot;button&quot;).off(&quot;click&quot;, test1);示例代码：&lt;script&gt; $(function () { function test1() { alert(&quot;hello lnj&quot;); } function test2() { alert(&quot;hello 123&quot;); } $(&quot;button&quot;).click(test1); $(&quot;button&quot;).click(test2); $(&quot;button&quot;).mouseleave(function () { alert(&quot;hello mouseleave&quot;); }); $(&quot;button&quot;).mouseenter(function () { alert(&quot;hello mouseenter&quot;); }); $(&quot;button&quot;).off(); $(&quot;button&quot;).off(&quot;click&quot;); $(&quot;button&quot;).off(&quot;click&quot;, test1); }); &lt;/script&gt;","tags":[]},{"title":"12 - jQuery操作CSS，位置尺寸，scrollTop","date":"2019-10-23T08:17:29.496Z","path":"2019/10/23/12 - jQuery操作CSS，位置尺寸，scrollTop/","text":"操作CSS 逐个设置 $(&quot;div&quot;).css(&quot;width&quot;, &quot;100px&quot;); $(&quot;div&quot;).css(&quot;height&quot;, &quot;100px&quot;); $(&quot;div&quot;).css(&quot;background&quot;, &quot;red&quot;); 链式设置注意点: 链式操作如果大于3步, 建议分开 $(&quot;div&quot;).css(&quot;width&quot;, &quot;100px&quot;).css(&quot;height&quot;, &quot;100px&quot;).css(&quot;background&quot;, &quot;blue&quot;); 批量设置 $(&quot;div&quot;).css({ width: &quot;100px&quot;, height: &quot;100px&quot;, background: &quot;red&quot; }); 获取CSS样式值 console.log($(&quot;div&quot;).css(&quot;background&quot;));操作位置和尺寸 offset([coordinates])作用: 获取元素距离窗口的偏移位 //距离左窗口的大小 $(&quot;.son&quot;).offset().left position()作用: 获取元素距离定位元素的偏移位 //相对于定位元素而言 $(&quot;.son&quot;).position().left 设置位置和尺寸 123456789101112131415// 设置元素的宽度 $(&quot;.father&quot;).width(&quot;500px&quot;) $(&quot;.son&quot;).offset(&#123; left: 10 &#125;); //注意点: position方法只能获取不能设置 $(&quot;.son&quot;).position(&#123; left: 10 &#125;); //但是可以设置css样式 $(&quot;.son&quot;).css(&#123; left: &quot;10px&quot; &#125;); scrollTop 获取获得滚动的偏移位 1$(&quot;.scroll&quot;).scrollTop() 为了保证浏览器的兼容, 获取网页滚动的偏移位不同 1$(&quot;body&quot;).scrollTop()+$(&quot;html&quot;).scrollTop() 设置设置滚动的偏移位 1$(&quot;.scroll&quot;).scrollTop(300); 浏览器兼容同样存在 1$(&quot;html,body&quot;).scrollTop(300);","tags":[]},{"title":"11 - jQuery操作类，文本值 操作方法","date":"2019-10-23T08:17:29.494Z","path":"2019/10/23/11 - jQuery操作类，文本值 操作方法/","text":"操作类方法 addClass(class|fn)作用: 添加一个类如果要添加多个, 多个类名之间用空格隔开即可 removeClass([class|fn])作用: 删除一个类如果想删除多个, 多个类名之间用空格隔开即可 toggleClass(class|fn[,sw])作用: 切换类有就删除, 没有就添加 示例代码：var btns = document.getElementsByTagName(&quot;button&quot;); btns[0].onclick = function () { // $(&quot;div&quot;).addClass(&quot;class1&quot;); $(&quot;div&quot;).addClass(&quot;class1 class2&quot;); } btns[1].onclick = function () { // $(&quot;div&quot;).removeClass(&quot;class2&quot;); $(&quot;div&quot;).removeClass(&quot;class2 class1&quot;); } btns[2].onclick = function () { $(&quot;div&quot;).toggleClass(&quot;class2 class1&quot;); }文本值方法 html([val|fn])和原生JS中的innerHTML一模一样 text([val|fn])和原生JS中的innerText一模一样 val([val|fn|arr])获取输入框中的默认值 示例代码： &lt;script&gt; var btns = document.getElementsByTagName(&quot;button&quot;); btns[0].onclick = function () { $(&quot;div&quot;).html(&quot;&lt;p&gt;我是段落&lt;span&gt;我是span&lt;/span&gt;&lt;/p&gt;&quot;); } btns[1].onclick = function () { console.log($(&quot;div&quot;).html()); } btns[2].onclick = function () { $(&quot;div&quot;).text(&quot;&lt;p&gt;我是段落&lt;span&gt;我是span&lt;/span&gt;&lt;/p&gt;&quot;); } btns[3].onclick = function () { console.log($(&quot;div&quot;).text()); } btns[4].onclick = function () { $(&quot;input&quot;).val(&quot;请输入内容&quot;); } btns[5].onclick = function () { console.log($(&quot;input&quot;).val());; } &lt;/script&gt; &lt;body&gt; &lt;button&gt;设置html&lt;/button&gt; &lt;button&gt;获取html&lt;/button&gt; &lt;button&gt;设置text&lt;/button&gt; &lt;button&gt;获取text&lt;/button&gt; &lt;button&gt;设置value&lt;/button&gt; &lt;button&gt;获取value&lt;/button&gt; &lt;div&gt;&lt;/div&gt; &lt;input type=&quot;text&quot;&gt; &lt;/body&gt;","tags":[]},{"title":"10 - jQuery的attr和prop","date":"2019-10-23T08:17:29.492Z","path":"2019/10/23/10 - jQuery的attr和prop/","text":"attr（）作用：获取或者设置属性节点的值 传一个参数：获取这个属性节点的值 传两个参数：设置这个属性节点的值 PS：获取： 无论找到多少个元素，都只返回第一个元素指定的属性节点的值。设置： 找到多少个，设置多少个。没找到，就自动新增。 removeAttr（）作用：删除属性节点 会删除所有找到元素指定的属性节点 删除多个属性节点，空格隔开 示例代码：$(&quot;span&quot;).attr(&quot;class&quot;); $(&quot;span&quot;).attr(&quot;class&quot;, &quot;box&quot;); $(&quot;span&quot;).removeAttr(&quot;class name&quot;);prop与attr方法一致 removeProp与removeProp方法一致 PS: prop不仅操作属性，还能操作属性节点 官方推荐在操作属性节点时,具有 true 和 false 两个属性的属性节点，如 checked, selected 或者 disabled 使用prop()，其他的使用 attr() 为什么呢？示例： console.log($(&quot;input&quot;).prop(&quot;checked&quot;)); // true / false console.log($(&quot;input&quot;).attr(&quot;checked&quot;)); // checked / undefined练习：切换图片&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;18-attr和prop方法练习&lt;/title&gt; &lt;script src=&quot;js/jquery-1.12.4.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function () { var btn = document.getElementsByTagName(&quot;button&quot;)[0]; btn.onclick = function () { var input = document.getElementsByTagName(&quot;input&quot;)[0]; var text = input.value; $(&quot;img&quot;).attr(&quot;src&quot;, text); // $(&quot;images&quot;).prop(&quot;src&quot;, text); } }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;text&quot;&gt; &lt;button&gt;切换图片&lt;/button&gt;&lt;br&gt; &lt;img src=&quot;https://www.baidu.com/img/bd_logo1.png?where=super&quot; alt=&quot;&quot;&gt; &lt;/body&gt; &lt;/html&gt;","tags":[]},{"title":"09 - 属性和属性节点","date":"2019-10-23T08:17:29.491Z","path":"2019/10/23/09 - 属性和属性节点/","text":"1. 属性？对象身上保存的变量就是属性 2. 操作属性 对象.属性名称 = 值; 对象.属性名称; 对象[“属性名称”] = 值; 对象[“属性名称”]; 3. 属性节点&lt;span name = &quot;it666&quot;&gt;&lt;/span&gt;HTML标签中添加的属性就是属性节点。在浏览器中找到span这个DOM元素之后, 展开看到的都是属性，在attributes属性中保存的所有内容都是属性节点。 4. 操作属性节点DOM.setAttribute(&quot;属性&quot;, &quot;值&quot;); DOM.getAttribute(&quot;属性&quot;);5. 属性和属性节点的区别 任何对象都有属性 只有DOM对象才有属性节点","tags":[]},{"title":"08 - 内容选择器","date":"2019-10-23T08:17:29.489Z","path":"2019/10/23/08 - 内容选择器/","text":":empty作用:找到既没有文本内容也没有子元素的指定元素 :parent作用: 找到有文本内容或有子元素的指定元素 :contains(text)作用: 找到包含指定文本内容的指定元素 :has(selector)作用: 找到包含指定子元素的指定元素 示例代码：&lt;script&gt; var $div = $(&quot;div:empty&quot;); console.log($div); var $div = $(&quot;div:parent&quot;); console.log($div); var $div = $(&quot;div:contains(&apos;我是div&apos;)&quot;); console.log($div); var $div = $(&quot;div:has(&apos;span&apos;)&quot;); console.log($div); &lt;/script&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;我是div&lt;/div&gt; &lt;div&gt;他们我是div123&lt;/div&gt; &lt;div&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt; &lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt; &lt;/body&gt;","tags":[]},{"title":"07 - 静态方法（trim，isWindow，isArray，isFunction）","date":"2019-10-23T08:17:29.487Z","path":"2019/10/23/07 - 静态方法（trim，isWindow，isArray，isFunction）/","text":"$.trim();作用: 去除字符串两端的空格 参数: 需要去除空格的字符串 返回值: 去除空格之后的字符串 $.isWindow();作用: 判断传入的对象是否是window对象 返回值: true/false $.isArray();作用: 判断传入的对象是否是真数组 返回值: true/false $.isFunction();作用: 判断传入的对象是否是一个函数 返回值: true/false $.holdReady(true); 作用: 暂停ready执行 注意点:jQuery框架本质上是一个函数 (function( window, undefined ) { })( window );示例代码：&lt;script&gt; var str = &quot; lnj &quot;; var res = $.trim(str); console.log(&quot;---&quot;+str+&quot;---&quot;); console.log(&quot;---&quot;+res+&quot;---&quot;); // 真数组 var arr = [1, 3, 5, 7, 9]; // 伪数组 var arrlike = {0:1, 1:3, 2:5, 3:7, 4:9, length:5}; // 对象 var obj = {&quot;name&quot;:&quot;lnj&quot;, age:&quot;33&quot;}; // 函数 var fn = function(){}; // window对象 var w = window; var res = $.isWindow(w); console.log(res); var res = $.isArray(w); console.log(res); var res = $.isFunction(jQuery); console.log(res); $.holdReady(true); $(document).ready(function () { alert(&quot;ready&quot;); }); &lt;/script&gt;","tags":[]},{"title":"06 - 静态方法（each，map）","date":"2019-10-23T08:17:29.485Z","path":"2019/10/23/06 - 静态方法（each，map）/","text":"forEach &amp; each JS的原生forEachforEach（遍历到的元素，当前遍历到的索引） 只能遍历数组, 不能遍历伪数组 jQuery的each静态方法each（当前遍历到的索引，遍历到的元素） 可以遍历伪数组 示例代码： &lt;script&gt; //数组 var arr = [1, 3, 5, 7, 9]; //伪数组 var obj = {0:1, 1:3, 2:5, 3:7, 4:9, length:5}; arr.forEach(function (value, index) { console.log(index, value); }); obj.forEach(function (value, index) { console.log(index, value); }); $.each(arr, function (index, value) { console.log(index, value); }); $.each(obj, function (index, value) { console.log(index, value); }); &lt;/script&gt;map &amp; map JS的原生mapforEach（当前遍历到的元素，当前遍历到的索引，当前被遍历的数组） 只能遍历数组, 不能遍历伪数组 jQuery的map静态方法each（要遍历的数组，每遍历一个元素之后执行的回调函数 ( 遍历到的元素,遍历到的索引){}） 可以遍历伪数组 &lt;script&gt; var arr = [1, 3, 5, 7, 9]; var obj = {0:1, 1:3, 2:5, 3:7, 4:9, length:5}; arr.map(function (value, index, array) { console.log(index, value, array); }); obj.map(function (value, index, array) { console.log(index, value, array); }); $.map(arr, function (value, index) { console.log(index, value); }); $.map(obj, function (value, index) { console.log(index, value); return value + index; }); &lt;/script&gt;each &amp; map each静态方法 默认的返回值：遍历谁就返回谁 不支持在回调函数中对遍历的数组进行处理 map静态方法 默认返回值：空数组 可以在回调函数中通过return对遍历的数组进行处理, 然后生成一个新的数组返回 &lt;script&gt; var arr = [1, 3, 5, 7, 9]; var obj = {0:1, 1:3, 2:5, 3:7, 4:9, length:5}; var res = $.map(obj, function (value, index) { console.log(index, value); return value + index; }); var res2 = $.each(obj, function (index, value) { console.log(index, value); return value + index; }); console.log(res); console.log(res2); &lt;/script&gt;","tags":[]},{"title":"05 - jQuery静态方法，实例方法","date":"2019-10-23T08:17:29.483Z","path":"2019/10/23/05 - jQuery静态方法，实例方法/","text":"静态方法 直接添加给类 AClass.staticMethod = function () { alert(&quot;staticMethod&quot;); } 静态方法通过类名调用 AClass.staticMethod(); 实例方法 给类添加一个实例方法 AClass.prototype.instanceMethod = function () { alert(&quot;instanceMethod&quot;); } 实例方法通过类的实例调用，创建一个对象 var a = new AClass(); a.instanceMethod();","tags":[]},{"title":"04 - jQuery冲突，核心函数，对象","date":"2019-10-23T08:17:29.482Z","path":"2019/10/23/04 - jQuery冲突，核心函数，对象/","text":"冲突？问题当引入一个js文件，文件中” $ “为关键字或变量的时候，js文件和jQuery的引用顺序决定了两个文件对” $ “的使用权。 @解决 释放” $ “的使用权注意点: 释放操作必须在编写其它jQuery代码之前编写释放之后就不能再使用$,改为使用jQuery 自定义一个访问符号 var nj = jQuery.noConflict(); $(function () { alert(&quot;hello&quot;); }); //自定义符号 nj(function () { alert(&quot;hello&quot;); }); 核心函数 $();调用核心函数 对象jQuery对象是一个伪数组（有0到length-1的属性, 并且有length属性）","tags":[]},{"title":"03 -jQuery入口函数写法","date":"2019-10-23T08:17:29.480Z","path":"2019/10/23/03 -jQuery入口函数写法/","text":"$(document).ready(function () {}); jQuery(document).ready(function () {}); $(function () {}); jQuery(function () {}); 推荐使用：$(function () {});","tags":[]},{"title":"02 - jQuery获取元素，属性，加载，入口函数","date":"2019-10-23T08:17:29.478Z","path":"2019/10/23/02 - jQuery获取元素，属性，加载，入口函数/","text":"获取元素 通过原生的JS入口函数可以拿到DOM元素var images = document.getElementsByTagName(&quot;images&quot;)[0]; 通过jQuery入口函数可以拿到DOM元素var $images = $(&quot;images&quot;); 获取元素属性 通过原生的JS入口函数可以拿到DOM元素的宽高var width = window.getComputedStyle(images).width; 通过jQuery入口函数不可以拿到DOM元素的宽高var $width = $images.width(); 入口函数加载模式 原生JS会等到DOM元素加载完毕,并且图片也加载完毕才会执行 jQuery会等到DOM元素加载完毕,但不会等到图片也加载完毕就会执行 多个入口函数 原生的JS,后面编写的会覆盖前面编写的 jQuery,后面的不会覆盖前面的","tags":[]},{"title":"01 - jQuery的Hello World","date":"2019-10-23T08:17:29.477Z","path":"2019/10/23/01 - jQuery的Hello World/","text":"原生JS 1window.onload = function (ev) &#123; &#125; jQuery 123$(document).ready(function () &#123; alert(&quot;Hello World&quot;); &#125;);","tags":[]},{"title":"正则表达式&常用工具类","date":"2019-10-23T08:17:29.473Z","path":"2019/10/23/正则表达式&常用工具类/","text":"(正则表达式的概述和简单使用) A:正则表达式 是指一个用来描述或者匹配一系列符合某个语法规则的字符串的单个字符串。其实就是一种规则。有自己特殊的应用。 作用:比如注册邮箱,邮箱有用户名和密码,一般会对其限制长度,这个限制长度的事情就是正则表达式做的 B:案例演示 需求：校验qq号码. 1:要求必须是5-15位数字 2:0不能开头 3:必须都是数字 a:非正则表达式实现 b:正则表达式实现 (字符类演示) A:字符类 [abc] a、b 或 c（简单类） [^abc] 任何字符，除了 a、b 或 c（否定） [a-zA-Z] a到 z 或 A到 Z，两头的字母包括在内（范围） [0-9] 0到9的字符都包括(预定义字符类演示) A:预定义字符类 . 任何字符。 \\d 数字：[0-9] \\w 单词字符：[a-zA-Z_0-9](数量词) A:Greedy 数量词 X? X，一次或一次也没有 X* X，零次或多次 X+ X，一次或多次 X{n} X，恰好 n 次 X{n,} X，至少 n 次 X{n,m} X，至少 n 次，但是不超过 m 次 (正则表达式的分割功能) A:正则表达式的分割功能 String类的功能：public String[] split(String regex) B:案例演示 正则表达式的分割功能 (把给定字符串中的数字排序) A:案例演示 需求：我有如下一个字符串:”91 27 46 38 50”，请写代码实现最终输出结果是：”27 38 46 50 91” (正则表达式的替换功能) A:正则表达式的替换功能 String类的功能：public String replaceAll(String regex,String replacement) B:案例演示 正则表达式的替换功能 (正则表达式的分组功能) A:正则表达式的分组功能 捕获组可以通过从左到右计算其开括号来编号。例如，在表达式 ((A)(B(C))) 中，存在四个这样的组： 1 ((A)(B(C))) 2 (A 3 (B(C)) 4 (C) 组零始终代表整个表达式。 B:案例演示 a:切割 需求：请按照叠词切割： &quot;sdqqfgkkkhjppppkl&quot;; b:替换 需求：我我....我...我.要...要要...要学....学学..学.编..编编.编.程.程.程..程 将字符串还原成:“我要学编程”。(Pattern和Matcher的概述) A:Pattern和Matcher的概述 B:模式和匹配器的典型调用顺序 通过JDK提供的API，查看Pattern类的说明 典型的调用顺序是 Pattern p = Pattern.compile(“a*b”); Matcher m = p.matcher(“aaaaab”); boolean b = m.matches(); (正则表达式的获取功能) A:正则表达式的获取功能 Pattern和Matcher的结合使用 B:案例演示 需求：把一个字符串中的手机号码获取出来 (Math类概述和方法使用) A:Math类概述 Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。 B:成员方法 public static int abs(int a) public static double ceil(double a) public static double floor(double a) public static int max(int a,int b) min自学 public static double pow(double a,double b) public static double random() public static int round(float a) 参数为double的自学 public static double sqrt(double a) (Random类的概述和方法使用) A:Random类的概述 此类用于产生随机数如果用相同的种子创建两个 Random 实例， 则对每个实例进行相同的方法调用序列，它们将生成并返回相同的数字序列。 B:构造方法 public Random() public Random(long seed) C:成员方法 public int nextInt() public int nextInt(int n)(重点掌握) (System类的概述和方法使用) A:System类的概述 System 类包含一些有用的类字段和方法。它不能被实例化。 B:成员方法 public static void gc() public static void exit(int status) public static long currentTimeMillis() pubiic static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length) C:案例演示 System类的成员方法使用 (BigInteger类的概述和方法使用) A:BigInteger的概述 可以让超过Integer范围内的数据进行运算 B:构造方法 public BigInteger(String val) C:成员方法 public BigInteger add(BigInteger val) public BigInteger subtract(BigInteger val) public BigInteger multiply(BigInteger val) public BigInteger divide(BigInteger val) public BigInteger[] divideAndRemainder(BigInteger val) (BigDecimal类的概述和方法使用) A:BigDecimal的概述 由于在运算的时候，float类型和double很容易丢失精度，演示案例。 所以，为了能精确的表示、计算浮点数，Java提供了BigDecimal 不可变的、任意精度的有符号十进制数。 B:构造方法 public BigDecimal(String val) C:成员方法 public BigDecimal add(BigDecimal augend) public BigDecimal subtract(BigDecimal subtrahend) public BigDecimal multiply(BigDecimal multiplicand) public BigDecimal divide(BigDecimal divisor) D:案例演示 BigDecimal类的构造方法和成员方法使用 (Date类的概述和方法使用)(掌握) A:Date类的概述 类 Date 表示特定的瞬间，精确到毫秒。 B:构造方法 public Date() public Date(long date) C:成员方法 public long getTime() public void setTime(long time) (SimpleDateFormat类实现日期和字符串的相互转换)(掌握) A:DateFormat类的概述 DateFormat 是日期/时间格式化子类的抽象类，它以与语言无关的方式格式化并解析日期或时间。是抽象类，所以使用其子类SimpleDateFormat B:SimpleDateFormat构造方法 public SimpleDateFormat() public SimpleDateFormat(String pattern) C:成员方法 public final String format(Date date) public Date parse(String source) (你来到这个世界多少天案例)(掌握) A:案例演示 需求：算一下你来到这个世界多少天? （Calendar类的概述和获取日期的方法)(掌握) A:Calendar类的概述 Calendar 类是一个抽象类，它为特定瞬间与一组诸如 YEAR、MONTH、DAY_OF_MONTH、HOUR 等日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。 B:成员方法 public static Calendar getInstance() public int get(int field) (Calendar类的add()和set()方法)(掌握) A:成员方法 public void add(int field,int amount) public final void set(int year,int month,int date) B:案例演示 Calendar类的成员方法使用 如何获取任意年份是平年还是闰年)(掌握) A:案例演示 需求：键盘录入任意一个年份，判断该年是闰年还是平年","tags":[]},{"title":"异常&File类","date":"2019-10-23T08:17:29.471Z","path":"2019/10/23/异常&File类/","text":"01_异常(异常的概述和分类) A:异常的概述 异常就是Java程序在运行过程中出现的错误。 B:异常的分类 通过API查看Throwable Error 服务器宕机,数据库崩溃等 ExceptionC:异常的继承体系 Throwable Error Exception RuntimeException 02_异常(JVM默认是如何处理异常的) A:JVM默认是如何处理异常的 main函数收到这个问题时,有两种处理方式: a:自己将该问题处理,然后继续运行 b:自己没有针对的处理方式,只有交给调用main的jvm来处理 jvm有一个默认的异常处理机制,就将该异常进行处理. 并将该异常的名称,异常的信息.异常出现的位置打印在了控制台上,同时将程序停止运行 B:案例演示 JVM默认如何处理异常 03_异常(try…catch的方式处理异常1) A:异常处理的两种方式 a:try…catch…finally try catch try catch finally try finally b:throws B:try…catch处理异常的基本格式 try…catch…finally C:案例演示 try…catch的方式处理1个异常 04_异常(try…catch的方式处理异常2) A:案例演示 try…catch的方式处理多个异常 JDK7以后处理多个异常的方式及注意事项 05_异常(编译期异常和运行期异常的区别) A:编译期异常和运行期异常的区别 Java中的异常被分为两大类：编译时异常和运行时异常。 所有的RuntimeException类及其子类的实例被称为运行时异常，其他的异常就是编译时异常 编译时异常 Java程序必须显示处理，否则程序就会发生错误，无法通过编译 运行时异常 无需显示处理，也可以和编译时异常一样处理 B:案例演示 编译期异常和运行期异常的区别 06_异常(Throwable的几个常见方法) A:Throwable的几个常见方法 a:getMessage() 获取异常信息，返回字符串。 b:toString() 获取异常类名和异常信息，返回字符串。 c:printStackTrace() 获取异常类名和异常信息，以及异常出现在程序中的位置。返回值void。 B:案例演示 Throwable的几个常见方法的基本使用 07_异常(throws的方式处理异常) A:throws的方式处理异常 定义功能方法时，需要把出现的问题暴露出来让调用者去处理。 那么就通过throws在方法上标识。 B:案例演示 举例分别演示编译时异常和运行时异常的抛出 08_异常(throw的概述以及和throws的区别) A:throw的概述 在功能方法内部出现某种情况，程序不能继续运行，需要进行跳转时，就用throw把异常对象抛出。 B:案例演示 分别演示编译时异常对象和运行时异常对象的抛出 C:throws和throw的区别 a:throws 用在方法声明后面，跟的是异常类名 可以跟多个异常类名，用逗号隔开 表示抛出异常，由该方法的调用者来处理 b:throw 用在方法体内，跟的是异常对象名 只能抛出一个异常对象名 表示抛出异常，由方法体内的语句处理 09_异常(finally关键字的特点及作用) A:finally的特点 被finally控制的语句体一定会执行 特殊情况：在执行到finally之前jvm退出了(比如System.exit(0)) B:finally的作用 用于释放资源，在IO流操作和数据库操作中会见到 C:案例演示 finally关键字的特点及作用 10_异常(finally关键字的面试题) A:面试题1 final,finally和finalize的区别 B:面试题2 如果catch里面有return语句，请问finally的代码还会执行吗?如果会，请问是在return前还是return后。 11_异常(自定义异常概述和基本使用) A:为什么需要自定义异常 举例：人的年龄 B:自定义异常概述 继承自Exception 继承自RuntimeException C:案例演示 自定义异常的基本使用 12_异常(异常的注意事项及如何使用异常处理) A:异常注意事项 a:子类重写父类方法时，子类的方法必须抛出相同的异常或父类异常的子类。(父亲坏了,儿子不能比父亲更坏) b:如果父类抛出了多个异常,子类重写父类时,只能抛出相同的异常或者是他的子集,子类不能抛出父类没有的异常 c:如果被重写的方法没有异常抛出,那么子类的方法绝对不可以抛出异常,如果子类方法内有异常发生,那么子类只能try,不能throws B:如何使用异常处理 原则:如果该功能内部可以将问题处理,用try,如果处理不了,交由调用者处理,这是用throws 区别: 后续程序需要继续运行就try 后续程序不需要继续运行就throws 如果JDK没有提供对应的异常，需要自定义异常。 13_异常(练习) 键盘录入一个int类型的整数,对其求二进制表现形式 如果录入的整数过大,给予提示,录入的整数过大请重新录入一个整数BigInteger 如果录入的是小数,给予提示,录入的是小数,请重新录入一个整数 如果录入的是其他字符,给予提示,录入的是非法字符,请重新录入一个整数 14_File类(File类的概述和构造方法) A:File类的概述 File更应该叫做一个路径 文件路径或者文件夹路径 路径分为绝对路径和相对路径 绝对路径是一个固定的路径,从盘符开始 相对路径相对于某个位置,在eclipse下是指当前项目下,在dos下 查看API指的是当前路径 文件和目录路径名的抽象表示形式 B:构造方法 File(String pathname)：根据一个路径得到File对象 File(String parent, String child):根据一个目录和一个子文件/目录得到File对象 File(File parent, String child):根据一个父File对象和一个子文件/目录得到File对象 C:案例演示 File类的构造方法 15_File类(File类的创建功能) A:创建功能 public boolean createNewFile():创建文件 如果存在这样的文件，就不创建了 public boolean mkdir():创建文件夹 如果存在这样的文件夹，就不创建了 public boolean mkdirs():创建文件夹,如果父文件夹不存在，会帮你创建出来 B:案例演示 File类的创建功能 注意事项： 如果你创建文件或者文件夹忘了写盘符路径，那么，默认在项目路径下。 16_File类(File类的重命名和删除功能) A:重命名和删除功能 public boolean renameTo(File dest):把文件重命名为指定的文件路径 public boolean delete():删除文件或者文件夹 B:重命名注意事项 如果路径名相同，就是改名。 如果路径名不同，就是改名并剪切。 C:删除注意事项： Java中的删除不走回收站。 要删除一个文件夹，请注意该文件夹内不能包含文件或者文件夹 17_File类(File类的判断功能) A:判断功能 public boolean isDirectory():判断是否是目录 public boolean isFile():判断是否是文件 public boolean exists():判断是否存在 public boolean canRead():判断是否可读 public boolean canWrite():判断是否可写 public boolean isHidden():判断是否隐藏 B:案例演示 File类的判断功能 18_File类(File类的获取功能) A:获取功能 public String getAbsolutePath()：获取绝对路径 public String getPath():获取路径 public String getName():获取名称 public long length():获取长度。字节数 public long lastModified():获取最后一次的修改时间，毫秒值 public String[] list():获取指定目录下的所有文件或者文件夹的名称数组 public File[] listFiles():获取指定目录下的所有文件或者文件夹的File数组 B:案例演示 File类的获取功能 19_File类(输出指定目录下指定后缀的文件名) A:案例演示 需求：判断E盘目录下是否有后缀名为.jpg的文件，如果有，就输出该文件名称 20_File类(文件名称过滤器的概述及使用) A:文件名称过滤器的概述 public String[] list(FilenameFilter filter) public File[] listFiles(FileFilter filter) B:文件名称过滤器的使用 需求：判断E盘目录下是否有后缀名为.jpg的文件，如果有，就输出该文件名称 C:源码分析 带文件名称过滤器的list()方法的源码","tags":[]},{"title":"遥感原理与应用 【Ⅰ】","date":"2019-10-23T08:17:29.470Z","path":"2019/10/23/遥感原理与应用 【I】/","text":"态度决定一切。小时候常听，长大了才懂。 文章较长，建议从目录选取感兴趣内容，然后Ctry+F搜索、跳转 目录1、电磁波的是3个特性在遥感中的应用2、电磁波谱3、黑体辐射（三个特性）4、大气对辐射的影响5、大气窗口6、一般物体的发射辐射7、光谱反射率8、反射波谱曲线9、假彩色10、为什么天是蓝色的？11、遥感平台12、卫星轨道6参数13、传感器分类14、扫描成像传感器15、MSS多光谱扫描仪16、CCD线阵列传感器17、成像光谱仪18、遥感传感器记录地物电磁波的图像形式19、数字图像的存储20、遥感图像的构像方程21、几何变形22、传感器外方位元素变化的影响24、大气折射引起的图像变形25、地球自转引起的图像变形26、基于多项式的遥感图像纠正27、图像亮度值的重采样28、辐射误差29、大气校正30、遥感图像辐射增强31、图像融合 ———————————————正文———————————————————– (1、电磁波的是3个特性在遥感中的应用)三个特性： 波粒二重性（波动性、粒子性） 波动性包括干涉、衍射、偏振等现象 以离散形式存在。其离散单元成为光子或量子。 波长与光子能量成反比关系 波长越短光子能量越大，则穿透力越强 应用 干涉：干涉雷达指采用干涉测量技术的合成孔径雷达 相干条件：两列频率相同、震动方向相同、相位差恒定的波。 衍射：设计遥感仪器和提高遥感图像几何分辨率、数字影像的处理 光通过有限大小的障碍物时偏离直线路径的现象 偏振（极化）：雷达遥感系统常用四种极化方式——HH、VV、HV、VH 水平极化（H）：电场方向平行于电磁波投射的平面 垂直极化（V）：垂直于水平极化的方向 HH、VV：同向极化 HV、VH：交叉极化 自然光（非偏正光）振动方向不变光振动面是一个固定平面 (2、电磁波谱)电磁波在真空中传播的波长或频率递增或递减顺序排序 电磁波包括：γ射线、X射线、紫外线、可见光、红外线、微波 遥感应用波段： 紫外线：0.01~0.38μm，对油污染敏感 可见光：0.38~0.76μm， 红外线：0.76~1000μm，（近、中、远、超远） 微波：1mm~1m，穿透性好，不受云雾影响 应用 遥感就是根据感兴趣的地物的波谱特性，选择相应的电磁波段通过传感器探测不同的电磁波谱的发射或反射能量而成像的。 (3、黑体辐射（三个特性）) 一个物体对于任何波长的电磁辐射都全部吸收（能量由温度决定） 特性： 辐射通量密度随波长连续变化，每条曲线只有一个最大值。 温度越高，总的辐射通量密度越大，不同温度的曲线不同且不相交 随着温度的升高，辐射最大值所对应的波长向短波方向移动（维恩位移定律 ） 热红外遥感探测和识别原理 斯忒藩-玻尔兹曼公式：绝对黑体表面上，单位面积发出的总辐射能与绝对温度的四次方成正比。 (4、大气对辐射的影响) 地球大气 对流层、平流层、电离层、大气外层 大气对太阳辐射的吸收、散射、反射 （1）大气对遥感波段的影响（吸收） 可见光波段：分子散射 紫外、红外、微波：大气吸收 （2）散射：电磁波与物质相互作用后，电磁波传播方向发生改变，并向各个方向散开。 主要发生在可见光，只改变传播方向 对遥感图像，降低了传感器接收数据的质量，造成图像模糊不清。 米氏散射、均匀散射、瑞利散射 思考：为什么微波遥感具有穿透能力？ 微波波长比粒子的直径大很多，属于瑞利散射， 波长越长散射强度越小，所以微波才可能由最小散射，最大投射， 而被称为具有穿云透雾的能力。 晴好的天气可见光通过大气时发生瑞利散射，蓝光比红光散射多； 当天空有云层或雨时，满足均匀反射条件， 各波长散射强度相同，天空云呈现白色，此时散射最大， 可见光难以通过云层，即阴天不利于用可见光进行遥感探测地物。(５、大气窗口) 电磁波通过大气衰减较小，透过率较高的波段 紫外、可见光、近红外：白天探测 近红外：白天夜间，地质遥感 中红外：探测高温目标，森林火灾 远红外：探测地物的发射率及温度 (6、一般物体的发射辐射)依据光谱发射率随波长的变化形式，将地物分为： 绝对黑体：发射率等于1 灰体：发射率小于1，各波长处的发射率相等 选择性辐射体，发射率小于1，各波长发射率不同 绝对白体，发射率为0。 影响发射率的因素：地物的性质、表面状况、温度（比热，热惯量）。 比热大、热惯量大以及具有保温作用的地物一般发射率大 任何材料的吸收率等于发射率 发射率 + 反射率 = 1(７、光谱反射率)物体在特定波长上的辐射通量与该波长的入射通量之比。 (8、反射波谱曲线)以波长为横坐标，反射率为纵坐标所得到的曲线 植被 在可见光波段：（叶绿素吸收） 0.45μm蓝波段有一个吸收谷 0.55μm绿波段有一个反射峰 0.67μm红波段有一个吸收谷 在近红外波段：(近红外穿透叶绿素，被多孔薄壁组织反射) 0.76μm反射率迅速增大，在1.1处达到峰值，形成植被的独有特征。 影响植被波谱曲线的因素： 植被类型 生长季节 植被病虫害 根据植被波谱曲线特征的差异，区分植被的类型和生长状态。 水体 反射特性: 在蓝绿波段具有反射率 在近红外、中红外波段完全吸收 影响水体波谱曲线的因素： 水中含有泥沙，在可见光波段反射率会增加，峰值出现在黄红区。 水中还有绿色植被时，近红外波段反射率明显提高。 城市道路、建筑 反射特性 红外波段较可见光波段反射强。 石棉瓦较其他材料反射强。 沥青较其他材料反射弱。 土壤 反射特性 自然状态下土壤的反射波谱曲线没有明显的峰值和谷值。 与土壤质地组成有关。 土壤含水量增加，反射率下降 - 影响地物光谱反射率变化的因素： - 时间效应： 地物的光谱特性一般随时间季节变化。 - 空间效应： 处在不同地理位置和区域的同种地物具有不同的光谱特性。 - 太阳高度，大气条件，环境状况 - 地形（阴影、坡度），气候、植物的病变(9、假彩色)（B）Band2 --&gt; 绿光波段 （G）Band3 --&gt; 红光波段 （R）Band4 --&gt; 近红外波段 植被 绿色与红色相加为品红，但红多绿少，因此品红偏红，植被在影像中大致呈红色。 水体 水体的反射主要在蓝绿光波段，绿波段被赋蓝，因此水库呈蓝偏黑。 (10、为什么天蓝)阳光在穿过大气层时，波长较长的红光、橙光、黄光都能穿透大气层，直接射到地面，而波长较短的蓝、紫、靛等色光，很容易被悬浮在空气中的微粒阻挡，从而使光线散射向四方，使天空呈现出蔚蓝色。 (11、遥感平台)地面平台、航空平台、航天平台。 (12、卫星轨道6参数)卫星轨道面与赤道面的相对位置 升交点赤经Ω ：升交点和赤道面春分点的夹角 近地点角距 ：轨道平面近地点和升交点的夹角 轨道倾角 ：轨道面和赤道面的夹角 卫星过近地点时刻 卫星轨道的形状 卫星轨道长半轴 卫星轨道扁率(13、传感器分类) 按工作方式： 主动遥感 被动遥感 按成像方式： 摄影成像传感器 x 扫描成像传感器 雷达成像传感器 x 非图像传感器 (14、扫描成像传感器) 红外扫描仪-分辨率 瞬时视场：在扫描成像过程中一个光敏探测元件通过望远镜系统投射到地面上的直径或对应的视场角度。 注意： 垂直观测时分辨率，即星下点空间分辨率 对于一个使用着的传感器，β在设计时已确定，地面分辨率变化只与航高有关。航高越大，a指越大，地面分辨率差 观测视线倾斜时，即非星下点时 扫描仪空间分辨率是变化的，产生全景畸变。 红外扫描仪-扫描线的衔接 假定旋转棱镜扫描一次的时间为t，探测器地面分辨率为a，若要使两条扫描带的重叠度为0，但又不能有空隙，必须 W = a/t Wt&gt;a 出现扫描漏洞 Wt&lt;a 出现扫描重叠 红外扫描仪-影响特征 热红外像片上的色调变化与相应的地物的辐射强度变化呈函数关系。 地物发射电磁波的功率和地物的发射率成正比，与地物温度的四次方成正比。 (15、MSS多光谱扫描仪) Landsat含24+2个探测元，按波段排列成四列，每列由六个探测元，每个探测元的地面观察面积为79m×79m。陆地卫星2、3上增加一个热红外通道，分辨率为240m×240m，仅用两个探测元构成。每个波段由六个相同大小的探测元与飞行方向平行排列，这样在瞬间看到的地面大小474m×79m，又由于扫描总视场为11.56度，地面宽度为185km，因此扫描一次每个波段获取六条扫描图像，其地面范围为474m×185km。又因卫星速度6.5km/s，在扫描一次的时间里卫星正好往前移动474m，因此扫描现恰好衔接。 扫描行不垂直于飞行轨道 从西向东扫描 (16、CCD线阵列传感器)HRV（高分辨率可见光扫描仪）是一种CCD线阵列传感器，又称为线阵列推扫式扫描仪。 不需要扫描镜的摆动，像缝隙式摄影机那样，以“推扫”方式获取连续条带影像。 将若干个CCD元器件排成一行，称为CCD线阵列传感器。 CCD上植入的微小光敏物质称作像素。一块CCD上包含的像素数越多，其提供的画面分辨率也就越高。 目前发射高分辨率卫星几乎均为线阵列 CCD工作原理 仪器中的平面反射镜将地面辐射来的电磁波反射到反射镜组 电磁波聚焦在CCD线阵列元件上 CCD输出端输出时间序列视频信号，以推扫的方式获取沿轨道方向的连续图像条带。 HRV-CCD优点 CCD线阵上的每个点同时曝光，保证了每个点上都有最大限度的曝光时间。 机械部件大大简化，运行稳定，几何精度比较高。 灵敏度高，可以探测到地面0.5％的反射变化信息。 突破了光/机扫描仪要求探测元件的响应速度足够快的要求。 (17、成像光谱仪)成像光谱仪其构造与像面扫描仪或物面扫描仪相近，但通道多。光谱分辨率高，可以获得接近连续的光谱。 特点：波段更窄，波段数更多 面阵探测器加推扫式扫描仪的成像光谱仪： 它利用线阵列探测器进行扫描，利用色散元件和面阵探测器完成光谱扫描，利用线阵列探测器及其沿轨道方向的运动完成空间扫描。 线阵列探测器加光机扫描仪的成像光谱仪： 它利用点探测器收集光谱信息，经色散元件后分成不同的波段，分别在线阵列探测器的不同元件上，通过点扫描镜在垂直于轨道方向的面内摆动以及沿轨道方向的运动完成空间扫描，而利用线探测器完成光谱扫描。 (18、遥感传感器记录地物电磁波的图像形式) （1）光学图像- 一个二维的连续的光密度函数 - 像片上的密度随坐标x,y变化而变化特点：光照位置和光照强度均为连续变化的。 （2）数字图像- 一个二维的离散的光密度（或亮度）函数 - 以矩阵f（x，y） ( x=0,1,…,m-1;y=0,1, …,n-1)表示 - 空间坐标（x,y）和密度上都已离散化（3）光学图像与数字图像的转换1.光学图像转化为数字图像 采样：数字化坐标值。 - 采样间隔越大，所得图像像素数越少，空间分辨率低，质量差，严重时出现马赛克效应； - 采样间隔越小，所得图像像素数越多，空间分辨率高，图像质量好，但数据量大。 dx和dy采样窗口，Δx和Δy为采样间隔 量化：无穷多个离散值约简为有限个离散值（整数来表示）图像数字化：- 连续图像 - 扫描线AB亮度分布 - 采样和量化 - 数字扫描线 数字图像转化为光学图像 通过显示终端设备显示出来，利用数模转换设备将数字信号以模拟方式表现出来 通过照相或打印的方式输出，彩色打印机。 (19、数字图像的存储)BSQ：按波段顺序依次排列，保证了像素空间位置的连续性。BIL：以行为单位分块，像素的空间位置在列的方向上是连续的。BIP：以像素为核心，为图像数据波谱的存取提供最佳性能。 BSQ：按波段顺序依次排列的数据格式，即先按照波段顺序分块排列，在每个波段块内，再按照行列顺序排列。通一波段的像素保存在一个快中，保证了像素空间位置的连续性。 BIL：以行为单位分块，在每个块内，按照波段顺序排列像素。同一行不同波段的数据保存在一个数据块中。像素的空间位置在列的方向上是连续的。 BIP：以像素为核心，同一像素不同波段数据保存在一起。每个块内为当前像素不同波段的像素值。该格式为图像数据波谱的存取提供最佳性能。 20、遥感图像的构像方程)遥感图像几何处理的目的？ &gt; 遥感任务是获取地物的空间信息和属性信息； &gt; 在利用遥感图像提取信息的过程中，要求将所有提取的信息 表达在某一个规定的图像投影参照系统内； &gt;遥感图像成图时，因为各种因素的影响，图像本身的 几何形状与其对应的地物形状不一致。 &gt;遥感图像的几何处理：统一坐标系，解决遥感图像的几何变形问题， 消除遥感图像的几何误差，获得所提取地物的几何位置。1、通用构像方程设地面点P在地面坐标系中的坐标为(X, Y ,Z)P，P在传感器坐标系中的坐标为(U V W)P，传感器投影中心S在地面坐标系中的坐标为(X Y Z)S，A为传感器坐标相对于地面坐标系统的旋转矩阵，则通用构像方程为： 2、中心投影构像方程中心投影：等比例缩放 中心投影构像方程：中心投影像片坐标与地面点大地坐标的关系 共线方程：描述像点、对应地物点和传感器中心之间的关系 共线方程物理意义：当地物点P、对应像点p和投影中心S位于同一条直线上时，上式公式成立。 为什么说中心投影构像方程是遥感构像方程的基础？ 答：框幅式影像属于纯中心投影构像， 全景影像属于多中心等焦距圆柱投影， 多光谱影像属于多中心扫描投影， HRV影像属于多中心推扫扫描投影， 合成孔径侧视雷达属于多中心斜距投影。3、全景摄影机的构像方程全景摄影机影像是由一条曝光缝隙沿旁向扫描而成，对于每条缝隙图像的形成，其几何关系等效于中心投影沿旁向倾斜一个扫描角θ 4、推扫式传感器的构像方程 5、扫描式传感器的构像方程 (21、几何变形) 静态误差：传感器相对于地球表面呈静止状态时所具有的各种变形误差。 动态误差：由于地球的旋转等因素所造成的图像变形误差。 内部误差：由于传感器自身的性能技术指标偏移标准数值所造成的。 外部变形误差：由传感器以外的各种因素所造成的误差，如传感器的外方位元素变化，传播介质不均匀，地球曲率，地形起伏以及地球旋转等因素引起的变形误差。 (22、传感器外方位元素变化的影响)传感器的外方位元素：传感器成像时的位置（Xs,Ys,Zs）和姿态角（φ,ω,κ） dXs、dYs、dZs 、dκ——线性变化 dφ、dω——非线性变形 (23、地球曲率引起的图像变形)地球曲率引起的像点位移与地形起伏引起的像点位移类似。只要把地球表面（把地球表面看成球面）上的点到地球切平面的正射投影距离看作是一种系统的地形起伏，就可以利用前面介绍的像点位移公式来估计地球曲率所引起的像点位移。 (24、大气折射引起的图像变形)大气层不是一个均匀的介质，它的密度是随离地面高度的增加而递减，因此电磁波在大气层中传播时的折射率也随高度而变化，使得电磁波的传播路径不是一条直线而变成了曲线，从而引起像点的位移，这种像点位移就是大气层折射的影响。 (25、地球自转引起的图像变形)在常规框幅摄影机成像的情况下，地球自转不会引起图像变形，因为其整幅图像是在瞬间一次曝光成像的。 地球自转主要是对动态传感器的图像产生变形影响，特别是对卫星遥感图像。当卫星由北向南运行的同时，地球表面也在由西向东自转，由于卫星图像每条扫描线的成像时间不同，因而造成扫描线在地面上的投影依次向西平移，最终使得图像发生扭曲。 (26、基于多项式的遥感图像纠正)多项式纠正直接对图像变形的本身进行数字模拟。对各种类型传感器图像的纠正是适用的。 利用地面控制点的图像坐标和其同名点的地面坐标通过平差原理计算多项式中的系数，然后用该多项式对图像进行纠正。 常用的多项式有一般多项式、勒让德多项式以及双变量分区插值多项式等。 多项式系数求解： 可预测的图像变形参数构成； 利用已知控制点的坐标值按最小二乘法原理求解 多项式的项数（即系数个数）N与其阶数n有着固定的关系：N=(n+1)(n+2)/2 一次项纠正：可以纠正图像因平移、旋转、比例尺变化和仿射变形等引起的线性变形。 二次项纠正时：在改正一次项各种变形的基础上，改正二次非线性变形。 三次项纠正：改正更高次的非线性变形。 例题： 多项式纠正步骤： 利用已知地面控制点求解多项式系数 地面控制点（GCP）：图像的配准以地面坐标在地图或遥感图像上相对应的点为匹配标准，这些对应的点称为地面控制点。 地面控制点数目的确定 地面控制点选取原则 图像上为明显的地物点，易于判读（道路交叉口、河流转弯处等）。 图像上均匀分布（图像的边缘部分选取控制点，尽量满幅均匀选取）。 数量要足够（特征变化大的地区，多选控制点）。 (27、图像亮度值的重采样)最邻近像元法 优点：简单容易，计算简单。 缺点：图像的灰度具有不连续性。 双线性内插法 优点：对灰度不连续现象或线状特征的块状化有明显的改善，对图像起到平滑作用 缺点：使对比度明显的分界线变得模糊。 双三次卷积法 优点：精度高。 缺点：计算量大。 (28、辐射误差)内容： 传感器本身的性能引起 大气的散射和吸收引起 地形影响和光照条件的辩护引起的辐射误差 辐射处理： 辐射定标：指传感器探测值的标定过程方法，用以确定传感器入口处的准确辐射值。 辐射定标分为绝对定标和相对定标。 绝对定标要建立传感器测量的数字信号与对应的辐射能量之间的数量关系。 绝对定标方法： 传感器定标、星上定标、场地定标 - 优点：实现了对遥感器运行状态下与获取地面图像完全同条件的绝对校正 - 缺点：需要测量和计算空中遥感器过顶时的大气环境和地物反射率。 辐射校正：指消除或改正遥感图像成像过程中附加在传感器输出的辐射能量中的各种噪声的过程。 (29、大气校正)大气的影响：大气对阳光和来自目标的辐射产生吸收和散射。 大气校正的方法 基于辐射传输方程的大气校正 基于地面场地数据或辅助数据进行辐射校正 利用某些不受大气影响或影响小的特性来校正其他波段的大气影响。 (30、遥感图像辐射增强)一、图像灰度直方图 反映了一幅图像中灰度级与其出现概率之间的关系。 可以看成一个随机分布密度函数，其分布状态用灰度均值和标准差来衡量。 二、图像反差调整 线性变换：按比例拉伸原始图像灰度等级范围。 目的：提高图像对比度。 特点：一对一关系，像元总数不变。 ![](https://img-blog.csdnimg.cn/201904150738009.png) 直方图均衡化 将随机分布的图像直方图修改成均匀分布的直方图，其实质是对图像进行非线性拉伸，重新分配图像像元值，使一定灰度范围内的像元的数量大致相等。 特点：各级灰度值所占图像的面积近似相等 原图像上频率小的灰度级被合并、频率高的灰度级被保留 增强图像上大面积地物与周围地物的反差 具体增强效果不能控制，只能全局均衡 直方图正太化 将随机分布的原图像直方图修改成高斯分布的直方图 直方图匹配 密度分割 密度分割与直方图均衡类似。原始图像的灰度值被分成等间隔的离散的灰度级，每一级有其灰度值。 其他非线性变换 对数变换、指数变换、平方根变换、标准偏差变换、直方图周期性变换。 灰度反转 结果：原来亮的地方变暗，原来暗的地方变亮。 (31、图像融合)目的： 空间分辨率的提高 目标特征增强 提高分类精度 信息互补 方法： 条件 融合图像应包括不同空间和光谱分辨率 融合的图像应是同一区域 图像应尽可能精确配准 在不同时间获取的图像中，其内容没有大的变化 基于像素的图像融合的方法 加权融合 基于HIS变换的图像融合 基于主分量变换的图像融合 基于小波变换的图像融合 比值变换融合 乘积变换融合基于IHS变换的图像融合 IHS变换将图像处理常用的RGB彩色空间变换到IHS空间。 I：亮度（Intensity） H：色调（Hue） S：饱和度(Saturation) IHS变换可以把图像的亮度、色调和饱和度分开，图像融合只在亮度通道上进行，图像的色调和饱和度保持不变。 效果评价 IHS变换融合：分辨率提高，图像变得清晰，光谱信息明显降低，色彩严重失真 比值变换融合：亮度太低，反差不合适，目视效果不好 ，光谱信息丢失严重","tags":[]},{"title":"遥感原理与应用 【Ⅱ】","date":"2019-10-23T08:17:29.468Z","path":"2019/10/23/遥感原理与应用 【Ⅱ】/","text":"1、电磁波的是3个特性在遥感中的应用大（小）———— 频率（波长）———— 小（大）————————————————————————Y射线 X射线 紫外线 可见光 红外线 微波 无线电 三个特性： 波粒二重性（波动性、粒子性） 波动性包括干涉、衍射、偏振等现象 以离散形式存在。其离散单元成为光子或量子。 波长与光子能量成反比关系 波长越短光子能量越大，则穿透力越强 应用 干涉：干涉雷达指采用干涉测量技术的合成孔径雷达 相干条件：两列频率相同、震动方向相同、相位差恒定的波。 衍射：设计遥感仪器和提高遥感图像几何分辨率、数字影像的处理 光通过有限大小的障碍物时偏离直线路径的现象 偏振（极化）：雷达遥感系统常用四种极化方式——HH、VV、HV、VH 水平极化（H）：电场方向平行于电磁波投射的平面 垂直极化（V）：垂直于水平极化的方向 HH、VV：同向极化 HV、VH：交叉极化 自然光（非偏正光）振动方向不变光振动面是一个固定平面 2、黑体辐射（三个特性） 一个物体对于任何波长的电磁辐射都全部吸收（能量由温度决定） 特性： 辐射通量密度随波长连续变化，每条曲线只有一个最大值。 温度越高，总的辐射通量密度越大，不同温度的曲线不同且不相交 随着温度的升高，辐射最大值所对应的波长向短波方向移动（维恩位移定律 ） 热红外遥感探测和识别原理 斯忒藩-玻尔兹曼公式：绝对黑体表面上，单位面积发出的总辐射能与绝对温度的四次方成正比。 3、大气窗口电磁波通过大气衰减较小，透过率较高的波段 紫外、可见光、近红外：白天探测 近红外：白天夜间，地质遥感 中红外：探测高温目标，森林火灾 远红外：探测地物的发射率及温度 4、地物反射类型 镜面反射 漫反射 方向反射5、反射波谱曲线物体的 反射波谱特性曲线 ：反射波谱是某物体得反射率（或反射辐射能）随波长变化的规律、以波长为横坐标，反射率为纵坐标所得到的曲线 植被 在可见光波段：（叶绿素吸收） 0.45μm蓝波段有一个吸收谷 0.55μm绿波段有一个反射峰 0.67μm红波段有一个吸收谷 在近红外波段：(近红外穿透叶绿素，被多孔薄壁组织反射) 0.76μm反射率迅速增大，在1.1处达到峰值，形成植被的独有特征。 影响植被波谱曲线的因素： 植被类型 生长季节 植被病虫害 根据植被波谱曲线特征的差异，区分植被的类型和生长状态。 水体 反射特性: 在蓝绿波段具有反射率 在近红外、中红外波段完全吸收 影响水体波谱曲线的因素： 水中含有泥沙，在可见光波段反射率会增加，峰值出现在黄红区。 水中还有绿色植被时，近红外波段反射率明显提高。 影响地物光谱反射率变化的因素： 时间效应： 地物的光谱特性一般随时间季节变化。 空间效应： 处在不同地理位置和区域的同种地物具有不同的光谱特性。 太阳高度，大气条件，环境状况 地形（阴影、坡度），气候、植物的病变 6、遥感平台 地面平台、航空平台、航天平台。 7、卫星轨道6参数卫星轨道面与赤道面的相对位置 升交点赤经Ω ：升交点和赤道面春分点的夹角 近地点角距 ：轨道平面近地点和升交点的夹角 轨道倾角 ：轨道面和赤道面的夹角 卫星过近地点时刻 卫星轨道的形状 卫星轨道长半轴 卫星轨道扁率8、卫星姿态角 滚动角：绕X轴旋转的姿态角 俯仰角：绕Y轴旋转的姿态角 航偏角：绕Z轴旋转的姿态角 9、传感器分类按工作方式： 主动遥感 被动遥感 按成像方式： 摄影成像传感器 x 扫描成像传感器 雷达成像传感器 x 非图像传感器 10、扫描类型的传感器逐点逐行地以时序方式获取二维图像 对地面扫描的成像仪特点：对地面直接扫描成像 红外扫描仪 多光谱扫描仪 成像扫描仪 瞬间在像面上先形成一条线图像 / 二维影像，然后对影像扫描成像 线阵列CCD推扫式成像仪 电视摄影机11、MSS多光谱扫描仪 Landsat含24+2个探测元，按波段排列成四列，每列由六个探测元，每个探测元的地面观察面积为79m×79m。陆地卫星2、3上增加一个热红外通道，分辨率为240m×240m，仅用两个探测元构成。每个波段由六个相同大小的探测元与飞行方向平行排列，这样在瞬间看到的地面大小474m×79m，又由于扫描总视场为11.56度，地面宽度为185km，因此扫描一次每个波段获取六条扫描图像，其地面范围为474m×185km。又因卫星速度6.5km/s，在扫描一次的时间里卫星正好往前移动474m，因此扫描现恰好衔接。 扫描行不垂直于飞行轨道 从西向东扫描 12、数字图像的存储BSQ：按波段顺序依次排列，保证了像素空间位置的连续性。BIL：以行为单位分块，像素的空间位置在列的方向上是连续的。BIP：以像素为核心，为图像数据波谱的存取提供最佳性能。 BSQ：按波段顺序依次排列的数据格式，即先按照波段顺序分块排列，在每个波段块内，再按照行列顺序排列。通一波段的像素保存在一个快中，保证了像素空间位置的连续性。 BIL：以行为单位分块，在每个块内，按照波段顺序排列像素。同一行不同波段的数据保存在一个数据块中。像素的空间位置在列的方向上是连续的。 BIP：以像素为核心，同一像素不同波段数据保存在一起。每个块内为当前像素不同波段的像素值。该格式为图像数据波谱的存取提供最佳性能。 13、遥感图像的构像方程遥感图像几何处理的目的？ &gt; 遥感任务是获取地物的空间信息和属性信息； &gt; 在利用遥感图像提取信息的过程中，要求将所有提取的信息 表达在某一个规定的图像投影参照系统内； &gt;遥感图像成图时，因为各种因素的影响，图像本身的 几何形状与其对应的地物形状不一致。 &gt;遥感图像的几何处理：统一坐标系，解决遥感图像的几何变形问题， 消除遥感图像的几何误差，获得所提取地物的几何位置。1、通用构像方程设地面点P在地面坐标系中的坐标为(X, Y ,Z)P，P在传感器坐标系中的坐标为(U V W)P，传感器投影中心S在地面坐标系中的坐标为(X Y Z)S，A为传感器坐标相对于地面坐标系统的旋转矩阵，则通用构像方程为： 主要坐标系： 传感器坐标系S-UVW，S为传感器投影中心，作为传感器坐标系的坐标原点，U轴的方向为遥感平台的飞行方向，W轴为传感器指向地底点方向的负方向，V轴垂直于WU平面，该坐标系描述了像点在空间的位置。 地面坐标系O-XYZ，主要采用地心坐标系统。当传感器对地成像时， Z轴与原点的天顶方向一致，XY平面与Z轴垂直。 图像（像点）坐标系o-xyf，(x,y)为像点在图像上的平面坐标，f为传感器成像时的等效焦距，方向与S-UVW一致。 2、中心投影构像方程中心投影：等比例缩放中心投影构像方程：中心投影像片坐标与地面点大地坐标的关系 共线方程：描述像点、对应地物点和传感器中心之间的关系 共线方程物理意义：当地物点P、对应像点p和投影中心S位于同一条直线上时，上式公式成立。 为什么说中心投影构像方程是遥感构像方程的基础？ 答：框幅式影像属于纯中心投影构像， 全景影像属于多中心等焦距圆柱投影， 多光谱影像属于多中心扫描投影， HRV影像属于多中心推扫扫描投影， 合成孔径侧视雷达属于多中心斜距投影。14、几何变形 静态误差：传感器相对于地球表面呈静止状态时所具有的各种变形误差。 动态误差：由于地球的旋转等因素所造成的图像变形误差。 内部变形误差：由于传感器自身的性能技术指标偏移标准数值所造成的。 外部变形误差：由传感器以外的各种因素所造成的误差，如传感器的外方位元素变化，传播介质不均匀，地球曲率，地形起伏以及地球旋转等因素引起的变形误差。 15、几何处理1. 粗加工处理作用：消除传感器误差 2. 精纠正处理消除图像中的几何变形，产生一副符合某种地图投影或图形表达要求的新图像 环节： 像素坐标的变换，即将图像坐标转变为地图或地面坐标 对坐标变换后的像素亮度值进行重采样。 处理过程： 根据图像的成像方式确定图像坐标和地面坐标之间的数学模型 根据地面控制点和对应像点坐标进行平差计算变换参数，平定精度。 对原始图像进行几何变换计算，像素亮度重采样。 纠正方法： 基于多项式的遥感图像纠正 基于共线方程的遥感图像纠正 基于有理函数的遥感图像纠正 16、基于多项式的遥感图像纠正多项式纠正直接对图像变形的本身进行数字模拟。对各种类型传感器图像的纠正是适用的。 利用地面控制点的图像坐标和其同名点的地面坐标通过平差原理计算多项式中的系数，然后用该多项式对图像进行纠正。 常用的多项式有一般多项式、勒让德多项式以及双变量分区插值多项式等。 多项式系数求解： 可预测的图像变形参数构成； 利用已知控制点的坐标值按最小二乘法原理求解 多项式的项数（即系数个数）N与其阶数n有着固定的关系：N=(n+1)(n+2)/2 一次项纠正：可以纠正图像因平移、旋转、比例尺变化和仿射变形等引起的线性变形。 二次项纠正时：在改正一次项各种变形的基础上，改正二次非线性变形。 三次项纠正：改正更高次的非线性变形。 例题： 多项式纠正步骤： 利用已知地面控制点求解多项式系数 地面控制点（GCP）：图像的配准以地面坐标在地图或遥感图像上相对应的点为匹配标准，这些对应的点称为地面控制点。 地面控制点数目的确定 地面控制点选取原则 图像上为明显的地物点，易于判读（道路交叉口、河流转弯处等）。 图像上均匀分布（图像的边缘部分选取控制点，尽量满幅均匀选取）。 数量要足够（特征变化大的地区，多选控制点）。 遥感图像的纠正变换 纠正后数字图像范围的确定 直接法和间接法纠正 数字图像亮度值的重采样 17、图像亮度值的重采样最邻近像元法 优点：简单容易，计算简单。 缺点：图像的灰度具有不连续性。 双线性内插法 优点：对灰度不连续现象或线状特征的块状化有明显的改善，对图像起到平滑作用 缺点：使对比度明显的分界线变得模糊。 双三次卷积法 优点：精度高。 缺点：计算量大。 18、辐射误差传感器接受的电磁波能量包含三部分： 太阳光经大气衰减后照射到地面，经地面反射后，又经大气第二次衰减进入传感器的能量。 大气散射、反射、辐射的能量 地面本身辐射的能量经大气后进入传感器的能量。 内容： 传感器本身的性能引起 ==》 辐射定标 大气的散射和吸收引起 ==》 大气校正 地形影响和光照条件的变化引起的辐射误差 ==》 太阳高度角、日地距离矫正和地形影响引起的辐射误差矫正。 19、辐射定标辐射定标：指传感器探测值的标定过程、方法，用以确定传感器入口处的准确辐射值。 辐射定标分为绝对定标和相对定标。绝对定标：要建立传感器测量的数字信号与对应的辐射能量之间的数量关系。 绝对定标方法：传感器定标、星上定标、场地定标 优点：实现了对遥感器运行状态下与获取地面图像完全同条件的绝对校正 缺点：需要测量和计算空中遥感器过顶时的大气环境和地物反射率。 20、大气校正大气的影响：大气对阳光和来自目标的辐射产生吸收和散射。 大气校正的方法 基于辐射传输方程的大气校正 基于地面场地数据或辅助数据进行辐射校正 利用某些不受大气影响或影响小的特性来校正其他波段的大气影响。 辐射校正：指消除或改正遥感图像成像过程中附加在传感器输出的辐射能量中的各种噪声的过程。 21、遥感图像辐射增强一、图像灰度直方图 反映了一幅图像中灰度级与其出现概率之间的关系。 可以看成一个随机分布密度函数，其分布状态用灰度均值和标准差来衡量。 可以判断图像质量 二、图像反差调整 线性变换：按比例拉伸原始图像灰度等级范围。 目的：提高图像对比度。 特点：一对一关系，像元总数不变。 ![](https://img-blog.csdnimg.cn/201904150738009.png) 直方图均衡化 将随机分布的图像直方图修改成均匀分布的直方图，其实质是对图像进行非线性拉伸，重新分配图像像元值，使一定灰度范围内的像元的数量大致相等。 特点：各级灰度值所占图像的面积近似相等 原图像上频率小的灰度级被合并、频率高的灰度级被保留 增强图像上大面积地物与周围地物的反差 具体增强效果不能控制，只能全局均衡 直方图正太化 将随机分布的原图像直方图修改成高斯分布的直方图 直方图匹配 密度分割 密度分割与直方图均衡类似。原始图像的灰度值被分成等间隔的离散的灰度级，每一级有其灰度值。 其他非线性变换 对数变换、指数变换、平方根变换、标准偏差变换、直方图周期性变换。 灰度反转 结果：原来亮的地方变暗，原来暗的地方变亮。 22、图像融合目的：提高分类精度 提高空间分辨率 改善配准精度 增强目标特征 提高分类精度 信息互补 23、景物特征及其判读标志1. 光谱特征地物的反射波谱特性一般是用一条连续的曲线表示 2. 空间特征形状：指各种地物的外形和轮廓 大小：地物尺寸、面积、体积在图像上按比例缩小后的相似性记录 图形：自然或人造复合地物所构成的图形 阴影：由于地物高度Z的变化，阻挡太阳光照射而产生的阴影。表示地物隆起高度，侧面形状 位置：地物存在的地点和所处的环境 纹理：同类地物聚集分布。光滑的、波纹的、斑纹的、线性、不规则的纹理特征。 类型：各大类别组成系统。水系系统、地貌系统、地质构造系统等，在各自类型中，根据形状、结构、图形分为许多种类。3. 时间特征24、影响景物特征及其判读的因素 地物本身的复杂性 大类地物特征 / 光谱特征不同 同类地物特征 / 光谱特征类似 同种地物由于自身因素或外界环境因素影响导致光谱信息不同 传感器特性的影响 几何分辨率：传感器瞬时视场内所观察到的地面场元的宽度 辐射分辨率：传感器能区分两种辐射强度最小差别的能力 光谱分辨率：探测波段宽度、波段数、各波段波长范围和间隔 时间分辨率：对同一地区重复获取图像所需的时间间隔 目视能力 空间分辨能力：与眼睛分辨角、影像距离人眼距离、照明条件、图像形状和反差等有关。 灰阶分辨能力：取决于视网膜上的视杆细胞的灵敏度 色别和色阶分辨能力：RGB的分辨能力 25、特征变换什么？将原有的m量值集合通过某种变换，然后产生n（ m &gt;= n ）个特征 为什么？ 减少参加分类的特征图像的数目 从原始信息中抽取能更好进行分类的特征图像 分类 主分量变化 哈达玛变换 比值变换 缨帽变换 性质均方误差最小的最佳正交线变换 主分量变换步骤 计算 均值向量M和协方差矩阵C 计算 矩阵C的特征值和特征向量、 特征值的排序（大到小） 选择前几个特征值（及对应特征向量）构造变换矩阵Φn 根据Y=ΦnX变换，得到新特征影像，即结果。缨帽变换经验性线性特征变换 什么是特征选择？ 选择一组最佳的特征影响分类 从原有的m个测量值集合中，按某一准则选择出n个特征 定量选择方法： 距离测度 散布矩阵测度 类内散矩阵 类间散布矩阵 总体散布矩阵监督分类过程（1）确定感兴趣的类别数（2）特征变换和特征选择（3）选择训练样区（准确性、代表性和统计性）（4）确定判决函数和判决规则（5）根据判决函数和判决规则对非训练样区的图像区域进行分类K-均值聚类法准则：点到类别中心的距离的平方和最小。思想：通过迭代，逐次移动各类的中心，直至得到最好的聚类结果为止。 步骤： 选择m个类的初始中心 按照到类中心距离最小的原则对像元分类 重新计算类中心 类中心不变，算法结束；否则返回(2)IOSDATA算法聚类分析 步骤： 初始化； 选择初始中心； 按一定规则(如距离最小)对所有像元划分； 重新计算每个集群的均值和方差；按初始化的参数进行分裂和合并； 结束，迭代若干次数或者两次迭代之间类别均值变化小于阈值 否则，重复3-5； 确认类别，精度评定. 26、 监督分类与非监督分类的结合 选择一些有代表性的区域进行非监督分类。 获得多个聚类类别的先验知识。 特征选择。选择最适合的特征图像进行后续分类。 使用监督法对整个影像进行分类。 输出标记图像。 27、分类后的处理为什么？用光谱信息对影像逐个像元地分类，在结果的分类地图上会出现“噪声” 。分类是正确的，但某种类别零星分布于地面，占的面积很小 ，希望用综合的方法使它从图面上消失。 分类平滑技术采用邻区处理法。平滑时中心像元值取周围倒数的类别。 28、混淆矩阵（计算）行：错分。用户精度列：漏分。制图精度 Kappa系数 = （ Pa - Pe ）/ （ 1 - Pe ） Pa = （ P11+P22+…+Pnn）/ ( P )Pe = ( P1+ * P+1) + ( P2+ * P+2) + … +( Pn+ * P+n) / P^2","tags":[]},{"title":"渲染---唯一值渲染","date":"2019-10-23T08:17:29.466Z","path":"2019/10/23/渲染---唯一值渲染/","text":"1.效果图 2.通过定义唯一值渲染器，渲染字段，设置渲染方式渲染唯一值写死，方式设置参考官方api //定义唯一值渲染器，对字段alias进行渲染，fill是默认的渲染符号 var renderer = new UniqueValueRenderer(fill, &quot;name&quot;); //设置渲染的方式 renderer.addValue(&quot;C&quot;, new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new Color([0, 255, 0, 0.5]))); renderer.addValue(&quot;B&quot;, new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new Color([0, 0, 255, 0.5]))); renderer.addValue(&quot;A&quot;,new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new Color([255, 0, 255, 0.5]))); renderer.addValue(&quot;O&quot;, new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new Color([255, 255, 255, 0.75]))); featureLayer.setRenderer(renderer);贴代码&lt;!DOCTYPE html&gt; &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt; &lt;title&gt;UniqueValueRenderer&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/esri/css/esri.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/dijit/themes/tundra/tundra.css&quot;/&gt; &lt;script type=&quot;text/Javascript&quot; src=&quot;https://js.arcgis.com/3.28/&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .MapClass{ width:100%; height:600px; border:1px solid #000; } &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; require([&quot;esri/map&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;dojo/on&quot;, &quot;dojo/dom&quot;, &quot;dojo/colors&quot;, &quot;esri/symbols/SimpleFillSymbol&quot;, &quot;esri/layers/FeatureLayer&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;, &quot;esri/renderers/UniqueValueRenderer&quot;, &quot;dojo/domReady!&quot;], function (Map, ArcGISDynamicMapServiceLayer,on,dom,Color,SimpleFillSymbol, FeatureLayer, SimpleLineSymbol,UniqueValueRenderer) { var map = new esri.Map(&quot;MyMapDiv&quot;); var layer = new ArcGISDynamicMapServiceLayer(&quot;http://localhost:6080/arcgis/rest/services/demo/Practice/MapServer&quot;); map.addLayer(layer); //获得id为btn的DOM元素 var btn=dom.byId(&quot;btn&quot;); //绑定相应的事件 on(btn,&quot;click&quot;,function(){ //定义一个要素图层 var featureLayer = new FeatureLayer( &quot;http://localhost:6080/arcgis/rest/services/demo/Practice/MapServer/2&quot;, { mode:FeatureLayer.MODE_SNAPSHOT, outFields: [&quot;*&quot;] }); //定义线符号 var lineSymbol=new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new Color([255, 0, 0]), 3); //定义面符号 var fill=new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new Color(&quot;#FFFFCC&quot;)); //定义唯一值渲染器，对字段alias进行渲染，fill是默认的渲染符号 var renderer = new UniqueValueRenderer(fill, &quot;name&quot;); //设置渲染的方式 renderer.addValue(&quot;C&quot;, new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new Color([0, 255, 0, 0.5]))); renderer.addValue(&quot;B&quot;, new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new Color([0, 0, 255, 0.5]))); renderer.addValue(&quot;A&quot;,new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new Color([255, 0, 255, 0.5]))); renderer.addValue(&quot;O&quot;, new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new Color([255, 255, 255, 0.75]))); featureLayer.setRenderer(renderer); map.addLayer(featureLayer); }) }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;MyMapDiv&quot; class=&quot;MapClass&quot;&gt;&lt;/div&gt; &lt;button id=&quot;btn&quot;&gt;渲染&lt;/button&gt; &lt;/body&gt; &lt;/html&gt;","tags":[]},{"title":"渲染---服务器分类渲染","date":"2019-10-23T08:17:29.465Z","path":"2019/10/23/渲染---服务器分类渲染/","text":"1.引入模块&quot;esri/tasks/GenerateRendererTask&quot;, &quot;esri/tasks/GenerateRendererParameters&quot;, &quot;esri/tasks/ClassBreaksDefinition&quot;, &quot;esri/tasks/AlgorithmicColorRamp&quot;,2.与前两个相比当数据量很大的时候，服务器渲染的速度明显快过客户端渲染。客户端和服务端的渲染都分为两种：唯一值渲染和分类渲染 3.服务器分类步骤相比客户端较多，有层次 创建对象 var lineSymbol=new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new dojo.Color([255, 0, 0]), 3); var fill=new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new dojo.Color(&quot;#FFFFCC&quot;)); //创建服务器渲染对象 var RenderAnalyst = new GenerateRendererTask(&quot;http://localhost:6080/arcgis/rest/services/demo/Practice/MapServer/1&quot;); //创建服务器渲染参数对象 var params = new GenerateRendererParameters(); //创建颜色坡道对象 var colorRamp = new AlgorithmicColorRamp(); 设置颜色位置、类型 //颜色的起始位置 colorRamp.fromColor = dojo.colorFromHex(&quot;#998ec3&quot;); //颜色的终止位置 colorRamp.toColor = dojo.colorFromHex(&quot;#f1a340&quot;); //颜色的类型 colorRamp.algorithm = &quot;hsv&quot;; 渲染器样式、分类字段，怎么分，分几类 //渲染器样式 var unidef = new ClassBreaksDefinition(); //分类字段 unidef.classificationField = &quot;Shape.STArea()&quot;; //如何分类 unidef.classificationMethod=&quot;natural-breaks&quot;; //几类 unidef.breakCount = 3; 显示分类符号，颜色，赋值渲染 //默认的符号 unidef.baseSymbol=fill; //将自定义的颜色坡道告诉服务器 unidef.colorRamp=colorRamp; //给渲染参数对象赋值 params.classificationDefinition = unidef; //进行服务器渲染 RenderAnalyst.execute(params, showRender); 4.贴代码&lt;!DOCTYPE html&gt; &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt; &lt;title&gt;GenerateRendererTask&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/esri/css/esri.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/dijit/themes/tundra/tundra.css&quot;/&gt; &lt;script type=&quot;text/Javascript&quot; src=&quot;https://js.arcgis.com/3.28/&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .MapClass{ width:100%; height:500px; border:1px solid #000; } &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; require([&quot;esri/map&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;dojo/dom&quot;, &quot;dojo/on&quot;, &quot;esri/tasks/GenerateRendererTask&quot;, &quot;esri/layers/FeatureLayer&quot;, &quot;esri/symbols/SimpleFillSymbol&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;, &quot;esri/tasks/GenerateRendererParameters&quot;, &quot;esri/tasks/ClassBreaksDefinition&quot;, &quot;esri/tasks/AlgorithmicColorRamp&quot;, &quot;dojo/domReady!&quot;], function (Map, ArcGISDynamicMapServiceLayer, dom,on, GenerateRendererTask, FeatureLayer, SimpleFillSymbol, SimpleLineSymbol, GenerateRendererParameters, ClassBreaksDefinition, AlgorithmicColorRamp ) { //服务器端渲染 var MyMap = new Map(&quot;MyMapDiv&quot;); var layer = new ArcGISDynamicMapServiceLayer (&quot;http://localhost:6080/arcgis/rest/services/demo/Practice/MapServer/&quot;); MyMap.addLayer(layer) //获得id为Btn的DOM对象 var btn=dom.byId(&quot;Btn&quot;); //给btn绑定点击事件 on(btn,&quot;click&quot;,function(e){ //定义线符号 var lineSymbol=new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new dojo.Color([255, 0, 0]), 3); //定义面符号 var fill=new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new dojo.Color(&quot;#FFFFCC&quot;)); //创建服务器渲染对象 var RenderAnalyst = new GenerateRendererTask(&quot;http://localhost:6080/arcgis/rest/services/demo/Practice/MapServer/1&quot;); //创建服务器渲染参数对象 var params = new GenerateRendererParameters(); //创建颜色坡道对象 var colorRamp = new AlgorithmicColorRamp(); //颜色的起始位置 colorRamp.fromColor = dojo.colorFromHex(&quot;#998ec3&quot;); //颜色的终止位置 colorRamp.toColor = dojo.colorFromHex(&quot;#f1a340&quot;); //颜色的类型 colorRamp.algorithm = &quot;hsv&quot;; //渲染器样式 var unidef = new ClassBreaksDefinition(); //分类字段 unidef.classificationField = &quot;Shape.STArea()&quot;; //如何分类 unidef.classificationMethod=&quot;natural-breaks&quot;; //几类 unidef.breakCount = 3; //默认的符号 unidef.baseSymbol=fill; //将自定义的颜色坡道告诉服务器 unidef.colorRamp=colorRamp; //给渲染参数对象赋值 params.classificationDefinition = unidef; //进行服务器渲染 RenderAnalyst.execute(params, showRender); }); //处理服务器返回来的结果 function showRender(renderer) { if (renderer != null) { //定义要素图层，注意：这个地方我们用到并不是要素服务，而是地图服务 var featureLayer = new FeatureLayer(&quot;http://localhost:6080/arcgis/rest/services/demo/Practice/MapServer/1&quot;,{ mode: FeatureLayer.MODE_SNAPSHOT, outFields: [&quot;*&quot;] }); //赋予渲染器 featureLayer.setRenderer(renderer); featureLayer.refresh(); MyMap.addLayer(featureLayer); } } }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;MyMapDiv&quot; class=&quot;MapClass&quot;&gt;&lt;/div&gt; &lt;input type=&quot;button&quot; id=&quot;Btn&quot; value=&quot;服务器渲染&quot; /&gt; &lt;/body&gt; &lt;/html&gt;","tags":[]},{"title":"渲染---分类渲染","date":"2019-10-23T08:17:29.463Z","path":"2019/10/23/渲染---分类渲染/","text":"1.效果图 2.与唯一值渲染相比不同的只有渲染方式的设置 唯一值渲染： renderer.addValue(“C”, new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new Color([0, 255, 0, 0.5]))); renderer.addValue(“B”, new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new Color([0, 0, 255, 0.5]))); renderer.addValue(“A”,new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new Color([255, 0, 255, 0.5]))); renderer.addValue(“O”, new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new Color([255, 255, 255, 0.75]))); 分类渲染： renderer.addBreak(0,20, new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new Color([0, 255, 0, 0.5]))); renderer.addBreak(20,30, new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new Color([0, 0, 255, 0.5]))); renderer.addBreak(30,40,new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new Color([255, 0, 255, 0.5]))); renderer.addBreak(40,60, new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new Color([255, 255, 255, 0.75]))); 分类渲染即将选择字段的值分为不同阶段渲染为不同颜色 3.贴代码&lt;!DOCTYPE html&gt; &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt; &lt;title&gt;UniqueValueRenderer&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/esri/css/esri.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/dijit/themes/tundra/tundra.css&quot;/&gt; &lt;script type=&quot;text/Javascript&quot; src=&quot;https://js.arcgis.com/3.28/&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .MapClass{ width:100%; height:600px; border:1px solid #000; } &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; require([&quot;esri/map&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;dojo/on&quot;, &quot;dojo/dom&quot;, &quot;dojo/colors&quot;, &quot;esri/symbols/SimpleFillSymbol&quot;, &quot;esri/layers/FeatureLayer&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;, &quot;esri/renderers/ClassBreaksRenderer&quot;, &quot;dojo/domReady!&quot;], function (Map, ArcGISDynamicMapServiceLayer,on,dom,Color,SimpleFillSymbol, FeatureLayer, SimpleLineSymbol,ClassBreaksRenderer) { var map = new esri.Map(&quot;MyMapDiv&quot;); var layer = new ArcGISDynamicMapServiceLayer(&quot;http://localhost:6080/arcgis/rest/services/demo/Practice/MapServer&quot;); map.addLayer(layer); //获得id为btn的DOM元素 var btn=dom.byId(&quot;btn&quot;); //绑定相应的事件 on(btn,&quot;click&quot;,function(){ //定义一个要素图层 var featureLayer = new FeatureLayer( &quot;http://localhost:6080/arcgis/rest/services/demo/Practice/MapServer/1&quot;, { mode:FeatureLayer.MODE_SNAPSHOT, outFields: [&quot;*&quot;] }); //定义线符号 var lineSymbol=new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new Color([255, 0, 0]), 3); //定义面符号 var fill=new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new Color(&quot;#FFFFCC&quot;)); //定义唯一值渲染器，对字段alias进行渲染，fill是默认的渲染符号 var renderer = new ClassBreaksRenderer(fill, &quot;OBJECTID&quot;); //设置渲染间隔 renderer.addBreak(0,20, new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new Color([0, 255, 0, 0.5]))); renderer.addBreak(20,30, new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new Color([0, 0, 255, 0.5]))); renderer.addBreak(30,40,new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new Color([255, 0, 255, 0.5]))); renderer.addBreak(40,60, new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol,new Color([255, 255, 255, 0.75]))); featureLayer.setRenderer(renderer); map.addLayer(featureLayer); }) }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;MyMapDiv&quot; class=&quot;MapClass&quot;&gt;&lt;/div&gt; &lt;button id=&quot;btn&quot;&gt;渲染&lt;/button&gt; &lt;/body&gt; &lt;/html&gt;","tags":[]},{"title":"小操作","date":"2019-10-23T08:17:29.461Z","path":"2019/10/23/小操作/","text":"2019.9.21 更添加图层map.addLayer(Shp); 移除图层map.removeLayer(Shp); 隐藏图层shp.hide(); 显示图层shp.show();","tags":[]},{"title":"小部件---鹰眼图","date":"2019-10-23T08:17:29.460Z","path":"2019/10/23/小部件---鹰眼图/","text":"1. 效果图 2. 引用模块鹰眼图&quot;esri/dijit/OverviewMap&quot;, 3. 增加了一个鹰眼图，div的布局会不会有什么变化？&lt;body&gt; &lt;div id=&quot;map&quot; style=&quot;height: 800px;&quot;&gt;&lt;/div&gt; &lt;button&gt;拉框放大&lt;/button&gt; &lt;button&gt;拉框缩小&lt;/button&gt; &lt;button&gt;平移&lt;/button&gt; &lt;button&gt;全图&lt;/button&gt; &lt;button&gt;漫游&lt;/button&gt; &lt;/body&gt;嗯，，，似乎是没有任何变化 这样看来。鹰眼图就像是map的属性一样，本身便存在，需要设置它的setVisibleXX来控制它的可见性。我猜是这样 4. 看一下JS代码证实一下猜想var overviewMapDijit = new OverviewMap({ map: map, //LOOK LOOK visible: true }); overviewMapDijit.startup();OverviewMap就是创建鹰眼图的类。创建参数中第一个绑定地图。第二个就是设置鹰眼图的可见性。并且它的可见性默认是false（亲测） 5. 试试在上一篇中的绑定小部件上加上鹰眼图，贴代码&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1, maximum-scale=1,user-scalable=no&quot;&gt; &lt;title&gt;Overview Map&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/esri/css/esri.css&quot;/&gt; &lt;style&gt; html, body { height: 100%; width: 100%; margin: 0; padding: 0; } &lt;/style&gt; &lt;script src=&quot;https://js.arcgis.com/3.29/&quot;&gt;&lt;/script&gt; &lt;script&gt; var map; require([ &quot;esri/map&quot;, &quot;esri/dijit/OverviewMap&quot;, &quot;dojo/parser&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;dojo/query&quot;,&quot;esri/toolbars/navigation&quot;, &quot;dijit/layout/BorderContainer&quot;, &quot;dijit/layout/ContentPane&quot;, &quot;dojo/domReady!&quot; ], function ( Map, OverviewMap, parser,ArcGISDynamicMapServiceLayer,query,Navigation) { parser.parse(); map = new Map(&quot;map&quot;); var layer = new ArcGISDynamicMapServiceLayer (&quot;http://localhost:6080/arcgis/rest/services/ecology/beijing_2012_3/MapServer&quot;); map.addLayer(layer); var overviewMapDijit = new OverviewMap({ map: map, visible: true }); overviewMapDijit.startup(); //创建地图操作对象 var navToolbar = new Navigation(map); //给按钮添加绑定事件 query(&quot;button&quot;).on(&quot;click&quot;,function(event){ //获得按钮的文本信息 var value=this.innerHTML; switch(value){ case &quot;平移&quot;: navToolbar.activate(Navigation.PAN); break; case &quot;拉框缩小&quot;: navToolbar.activate(Navigation.ZOOM_OUT); break; case &quot;拉框放大&quot;: navToolbar.activate(Navigation.ZOOM_IN); break; case &quot;全图&quot;: navToolbar.zoomToFullExtent(); break; case &quot;漫游&quot;: //默认是漫游操作 navToolbar.deactivate(); break; } }); }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;map&quot; style=&quot;height: 800px;&quot;&gt;&lt;/div&gt; &lt;button&gt;拉框放大&lt;/button&gt; &lt;button&gt;拉框缩小&lt;/button&gt; &lt;button&gt;平移&lt;/button&gt; &lt;button&gt;全图&lt;/button&gt; &lt;button&gt;漫游&lt;/button&gt; &lt;/body&gt; &lt;/html&gt;6. 结果 7. 拓展：尝试设置重新鹰眼图的位置","tags":[]},{"title":"小部件---图例","date":"2019-10-23T08:17:29.458Z","path":"2019/10/23/小部件---图例/","text":"1. 效果图 2. 引用模块图例 &quot;esri/dijit/Legend&quot;, 3. 右侧增加的图例框会不会对div有一定的影响？先看一下HTML结构 &lt;body class=&quot;claro&quot;&gt; &lt;div id=&quot;content&quot; data-dojo-type=&quot;dijit/layout/BorderContainer&quot; data-dojo-props=&quot;design:&apos;headline&apos;, gutters:true&quot; style=&quot;width: 100%; height: 100%; margin: 0;&quot;&gt; &lt;div id=&quot;rightPane&quot; data-dojo-type=&quot;dijit/layout/ContentPane&quot; data-dojo-props=&quot;region:&apos;right&apos;&quot;&gt; &lt;div data-dojo-type=&quot;dijit/layout/AccordionContainer&quot;&gt; &lt;div data-dojo-type=&quot;dijit/layout/ContentPane&quot; id=&quot;legendPane&quot; data-dojo-props=&quot;title:&apos;Legend&apos;, selected:true&quot;&gt; &lt;div id=&quot;legendDiv&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div data-dojo-type=&quot;dijit/layout/ContentPane&quot; data-dojo-props=&quot;title:&apos;Pane 2&apos;&quot;&gt; This pane could contain tools or additional content &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;map&quot; data-dojo-type=&quot;dijit/layout/ContentPane&quot; data-dojo-props=&quot;region:&apos;center&apos;&quot; style=&quot;overflow:hidden;&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;好吧，很乱。大致分为四层。如图与之对应的图例中：解释一下：①：获取的图例对象的内容即框中的数据②：显示图例的标签卡及其平行标签卡，可以当作是对图例对象显示上的改进④：与map平行的同级div，border: solid #CCC 1px（灰色边框）③：②和④中间的间隙，它取决于②，换句话说，如果②为空，那么③的存在就没有意义。 除了①中的是必须获取的数据之外，剩余的有都是由Esri官方提供的方便开发的方法。不妨尝试进一步美化。这样看来，右侧增加的图例框的真实存在的div，但是它也是获取map中的数据。所以它更像是map对象的一种方法，而非属性。这也是和鹰眼图比较根本上的区别。 4. 大概因为都与map对象密切相关，所以鹰眼图和图例在启动上都十分相似，看一眼JS代码//add the legend var legend = new Legend({ map:map },&quot;legendDiv&quot;); legend.startup();相比而言，图例只是不用设置它的可见性。但我认为它们还是由本质上的区别。（个人拙见） 5. 贴代码动态图层&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1, maximum-scale=1,user-scalable=no&quot;&gt; &lt;title&gt;Map with legend&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.29/dijit/themes/claro/claro.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.29/esri/css/esri.css&quot;&gt; &lt;style&gt; html, body { height: 99%; width: 99%; } #rightPane { width: 20%; } #legendPane { border: solid #97DCF2 1px; } &lt;/style&gt; &lt;script src=&quot;https://js.arcgis.com/3.29/&quot;&gt;&lt;/script&gt; &lt;script&gt; var map; require([ &quot;esri/map&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;esri/dijit/Legend&quot;, &quot;dojo/_base/array&quot;, &quot;dojo/parser&quot;, &quot;dijit/layout/BorderContainer&quot;, &quot;dijit/layout/ContentPane&quot;, &quot;dijit/layout/AccordionContainer&quot;, &quot;dojo/domReady!&quot; ], function( Map, ArcGISDynamicMapServiceLayer, Legend, arrayUtils, parser ) { parser.parse(); map = new Map(&quot;map&quot;, { logo:false }); var layer = new ArcGISDynamicMapServiceLayer (&quot;http://localhost:6080/arcgis/rest/services/ecology/beijing_2012_3/MapServer&quot;); map.addLayer(layer) //不设置显示图层，默认显示&apos;[0]&apos;的图层 layer.setVisibleLayers([0]); //add the legend var legend = new Legend({ map:map },&quot;legendDiv&quot;); legend.startup(); }); &lt;/script&gt; &lt;/head&gt; &lt;body class=&quot;claro&quot;&gt; &lt;div id=&quot;content&quot; data-dojo-type=&quot;dijit/layout/BorderContainer&quot; data-dojo-props=&quot;design:&apos;headline&apos;, gutters:true&quot; style=&quot;width: 100%; height: 100%; margin: 0;&quot;&gt; &lt;div id=&quot;rightPane&quot; data-dojo-type=&quot;dijit/layout/ContentPane&quot; data-dojo-props=&quot;region:&apos;right&apos;&quot;&gt; &lt;div data-dojo-type=&quot;dijit/layout/AccordionContainer&quot;&gt; &lt;div data-dojo-type=&quot;dijit/layout/ContentPane&quot; id=&quot;legendPane&quot; data-dojo-props=&quot;title:&apos;Legend&apos;, selected:true&quot;&gt; &lt;div id=&quot;legendDiv&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div data-dojo-type=&quot;dijit/layout/ContentPane&quot; data-dojo-props=&quot;title:&apos;Pane 2&apos;&quot;&gt; This pane could contain tools or additional content &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;map&quot; data-dojo-type=&quot;dijit/layout/ContentPane&quot; data-dojo-props=&quot;region:&apos;center&apos;&quot; style=&quot;overflow:hidden;&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;要素图层将其中的对应的改为下面的代码即可注意：需要引入模块：&quot;esri/layers/FeatureLayer&quot;注意加载的时候为单图层，及动态图层后加显示序号 &lt;script&gt; var map; require([ &quot;esri/map&quot;, &quot;esri/layers/FeatureLayer&quot;, &quot;esri/dijit/Legend&quot;, &quot;dojo/_base/array&quot;, &quot;dojo/parser&quot;, &quot;dijit/layout/BorderContainer&quot;, &quot;dijit/layout/ContentPane&quot;, &quot;dijit/layout/AccordionContainer&quot;, &quot;dojo/domReady!&quot; ], function( Map, FeatureLayer, Legend, arrayUtils, parser ) { parser.parse(); map = new Map(&quot;map&quot;, { logo:false }); var rivers = new FeatureLayer(&quot;http://localhost:6080/arcgis/rest/services/ecology/beijing_2012_3/MapServer/1&quot;, { mode: FeatureLayer.MODE_ONDEMAND, outFields: [&quot;*&quot;] }); var waterbodies = new FeatureLayer(&quot;http://localhost:6080/arcgis/rest/services/ecology/beijing_2012_3/MapServer/0&quot;, { mode: FeatureLayer.MODE_ONDEMAND, outFields: [&quot;*&quot;] }); map.addLayers([waterbodies, rivers]); //add the legend var legend = new Legend({ map:map },&quot;legendDiv&quot;); legend.startup(); s }); &lt;/script&gt;要素图层显示效果：加载了两个要素图层，所以也会显示两个图例信息。个人认为交互性的动态图层更加方便，单一展示的要素图层更加方便。 7. 拓展：上面贴的代码中引入模块中多了三个&quot;dijit/layout/BorderContainer&quot;, &quot;dijit/layout/ContentPane&quot;, &quot;dijit/layout/AccordionContainer&quot; 如果删掉这三个模块，最终结果没有变化，但是在加载过程中，显示最终结果之前出现了一个过度样式，如下图：显然图里位置改变了，并且注意图最下方的地方可见图幅的大小也改变了。 为什么呢？后解。 文章中不正确的地方，麻烦大家指出，一起改进","tags":[]},{"title":"小部件---绑定小部件","date":"2019-10-23T08:17:29.456Z","path":"2019/10/23/小部件---绑定小部件/","text":"鼠标滚轮的放大缩小是地图的加载就有的操作方法，绑定的是拉框放大，缩小，全图等方法。 先看看效果图（拉框放大为例）放大前： 拉框放大： 放大后： 新添加模块：”dojo/query” “esri/toolbars/navigation” &quot;dojo/query&quot;绑定点击事件，注意：该点击事件凡是操作地图的要用query不能用on绑定 例如：query(&quot;button&quot;).on(&quot;click&quot;,function(event){}✔ on(dom.byId(&quot;button&quot;),&quot;click&quot;,function(event){}❌ &quot;esri/toolbars/navigation&quot;实现对地图的操作首先创建地图操作对象，给but等绑定该对象的方法。例如放大、缩小等。 步骤： 加载地图 var map = new Map(&quot;mapDiv&quot;); var layer = new ArcGISDynamicMapServiceLayer (&quot;http://localhost:6080/arcgis/rest/services/ecology/beijing_2012_3/MapServer&quot;); map.addLayer(layer); 创建地图操作对象 var navToolbar = new Navigation(map); 为btn绑定事件 query(&quot;button&quot;).on(&quot;click&quot;,function(event){ 获取btn的识别信息 var value=this.innerHTML; switch选择合适的操作方法 switch(value){ case &quot;平移&quot;: navToolbar.activate(Navigation.PAN); break; case &quot;拉框缩小&quot;: navToolbar.activate(Navigation.ZOOM_OUT); break; case &quot;拉框放大&quot;: navToolbar.activate(Navigation.ZOOM_IN); break; } 贴代码：&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/esri/css/esri.css&quot;/&gt; &lt;script src=&quot;https://js.arcgis.com/3.28/&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .MapClass{ width:100%; height:600px; border:1px solid #000; } &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; require([&quot;esri/map&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;dojo/query&quot;,&quot;esri/toolbars/navigation&quot;, &quot;dojo/domReady!&quot;], function (Map,ArcGISDynamicMapServiceLayer,query,Navigation) { var map = new Map(&quot;mapDiv&quot;); var layer = new ArcGISDynamicMapServiceLayer (&quot;http://localhost:6080/arcgis/rest/services/ecology/beijing_2012_3/MapServer&quot;); map.addLayer(layer); //创建地图操作对象 var navToolbar = new Navigation(map); //为btn绑定事件 query(&quot;button&quot;).on(&quot;click&quot;,function(event){ //获得btn的识别信息 var value=this.innerHTML; switch(value){ case &quot;平移&quot;: navToolbar.activate(Navigation.PAN); break; case &quot;拉框缩小&quot;: navToolbar.activate(Navigation.ZOOM_OUT); break; case &quot;拉框放大&quot;: navToolbar.activate(Navigation.ZOOM_IN); break; case &quot;全图&quot;: navToolbar.zoomToFullExtent(); break; case &quot;漫游&quot;: //默认是漫游操作 navToolbar.deactivate(); break; } }) }); &lt;/script&gt; &lt;/head&gt; &lt;body class=&quot;tundra&quot;&gt; &lt;div id=&quot;mapDiv&quot; class=&quot;MapClass&quot;&gt;&lt;/div&gt; &lt;button&gt;拉框放大&lt;/button&gt; &lt;button&gt;拉框缩小&lt;/button&gt; &lt;button&gt;平移&lt;/button&gt; &lt;button&gt;全图&lt;/button&gt; &lt;button&gt;漫游&lt;/button&gt; &lt;/body&gt; &lt;/html&gt;结果图","tags":[]},{"title":"数据分析 PyDay05","date":"2019-10-23T08:17:29.454Z","path":"2019/10/23/数据分析 PyDay05/","text":"第九章 IPython科学计算库（有点像是py标准库的升级，更具有方向性，很多优点）IPython壳基础自动补全可以通过按下Tab键，搜索命名空间内的对象，并自动补全正在输入的字符。 IPython会自动隐藏以双下划线开始的实体属性（私有属性）和方法（私有方法） 访问私有属性或私有方法：输入点符号后，输入下画线，并按Tab键。 检查 检查变量（函数、类）：变量名（函数名、类名）之前或之后使用”?”会给出该对象的基本信息 查看该类的构造函数的详细信息：在它之前或者之后输入两个问号”??” “?” 和 通配符（*） 结合起来。例如：搜索pandas库中所有含有”lo”的对象 pandas.*lo*?%run命令Python脚本都可以在IPython的环境下运行，工作路径下有一个test_run.py脚本文件，运行： %run test_run.py 通过Ctrl+C出发KeyboardInterrupt异常的方式来终止正在运行的程序。 快捷键C代表Ctrl C+P 从当前位置向前查找命令行历史 C+N 从打开壳开始查找命令行 C+C 终止程序运行 C+A 把光标移动到命令行开始处 C+E 把光标移动到命令行结尾处 C+K 删除一行文本 C+L 清楚屏幕 异常和错误定位%run命令行的方式运行脚本，出错时，会打印整个错误路径和异常的详细信息。 IPython排除程序错误比python高效 %xmode魔法方法控制谁出错误信息（任何以%作为前缀的方法都可以被称作魔法方法） %timeit魔法方法来检查程序运行的时间。 融合Matplotlib库和Pylab模型 Python标准库中，如果绘图，每次绘好图之后必须关闭图形窗口才能继续输入命令。 Ipython库融合了Matplotlib库，而Pylab模型是Matplotlib库提供给用户的绘图接口，和Matlab的绘图语法很接近。 可以在终端发起融合了Matplotlib库并以Pylab的方式绘图的IPython壳。 ipython –pylab 输入输出变量 当处理一个复杂问题的时候我们经常会用到多个变量和函数，可能会犯一些错误比如：忘记把函数的输出值赋给一个变量，而其他函数正好需要这个输出值作为输入值的时候。需要重新计算。 在IPython中，使用_（单下画线）指代最近一次的输入值，使用__（双下画线）指代最近一次的输出值 交互式调试器 代码运行错误时会按照代码的执行顺序打印全部调用路径，接着输入%debug，只打印出错的那部分代码。 如果是调试（Debugger）模式，可以任意执行代码的一部分并且检查其中的函数，数据等对象。默认处于调用路径的最后一层。可以通过u（向上）或者d（向下）（操作左边箭头）改变路径的位置 计时通常我们需要通过计时知道哪一部分用到的时间多，以便对代码进行优化。 Python的time模块可以记录时间，但是当代码量十分大的时候，会有很多重复工作。 IPyhon的%time和%timeit魔法方法可以避免这其中的重复工作使用%time多次测试同一个代码的时候会发现运行时间会有轻微的变化，因为这不是一个精确的方法。%timeit在多次运行后，报告平均时间。 %timeit是多次运行同一个声明或者函数并计算均值。如果代码的运行时间比较短，比如在微妙或者纳米级别，那么每次的时间波动会比较大，取多次运行的平均值，更恒反映实际。 重新载入模块经常导入一个库后，如果对里面的函数进行了修改，再次运行脚本Python会使用之前的函数而不是最新的。因为IPython只导入一次库。Matlab会自动更新导入的库函数。 解决： 退出IPython壳，重新进入。 Python的函数reload()可以保证每次运行脚本的时候都的到最后的库函数。当依赖的库比较多的时候，会比较麻烦。 Ipython提供了dreload()函数。 dreload（lib_name）函数会寻找lib_name模块内的所有其它库，并且重新导入。 新的比较凌乱，欢迎大家的讨论，留下建议，小白新手上路，不喜勿喷。谢谢","tags":[]},{"title":"数据分析 PyDay04","date":"2019-10-23T08:17:29.452Z","path":"2019/10/23/数据分析 PyDay04/","text":"可复用的函数和模块函数的定义def hi(): print(&apos;heelo world&apos;) hi()参数自定义参数def Cube(x=5): return x**3 Cube(2) #计算2的三次方 Cube() #计算默认值的三次方传参方式def fun(x,y,z): return x+y-z fun(1,2,3) #按顺序传递参数 fun(x=1,y=2,z=3) #按参数名传递参数按顺序传递的参数要位于按参数名传递的参数之前 fun(1,z=3,y=2)传递任意数量的参数在定义函数时，如果在参数名前加上一个星号“*”，则表示该参数是一个可变长参数。 def my_min(*list):参数返回计算结果参数中使用可变对象（列表等），使函数中的结果返回到参数中。 def change(x): x[0]=x[0]**2 b = [2] change(b) &gt;&gt;&gt;[4]变量的作用域lambda表达式定义函数使用lambda表达式可以定义一个匿名函数（所定义的函数没有函数名）一般形式： lambda 参数列表：表达式例： fun = lambda x: x * x - x #使用lambda表达式定义一个函数，返回函数地址（给fun） fun(3) #调用lambda表达式定义的函数 6 #函数返回值lambda表达式适用于定义小型函数，在函数中仅能包含单一的参数表达式，而不能包含其他语句。 def show(): #使用def定义show()函数 print(&apos;lambda&apos;) f = lambda:show() #在lambda表达式中调用show()函数 f() #调用使用lambda表达式生成的函数 &gt;&gt;&gt;lambda模块导入 import 模块名 import 模块名 as 新名字 from 模块名 import 函数名编译模块运行完.py文件之后会发现在目录中会多一个pycache文件夹，下面会有一个mymodule.cpython-36.pyc文件，这个文件就是Python将mymodule.py文件编译成字节码的文件。 由于Python是脚本语言，如果不想发布源文件，可以发布编译后的脚本。 将1.py编译为.pyc文件 #file：compile.py # import py_compile #导入py_compile模块 py_compile.compile(&apos;1.py&apos;,&apos;1.pyc&apos;); #编译1.py可以看到编译后的1.py文件并没有改变程序功能，只是以Python字节码的形式存在。 在命令行中优化脚本 python -O 1.py #对脚本的优化不多，编译后的脚本以.pyo为扩展名。 python -OO 1.py #优化程度大，脚本更小，但是可能会导致脚本错误，谨慎使用！查看模块函数名import sys dir(sys)包（解决查找路径的问题）包可以看作处于同一目录中的模块，在包的每个目录中都必须包含一个名为init.py的文件。可以是空文件，仅用来表示该目录是一个包。 init.py文件主要用途是设置all变量，以及所包含的包初始化所需的代码。 在from中使用通配符“*”导入包内所有的名字时，在init.py文件中设置all变量可以保证名字正确输导入。 from A.B import a #是哟弄个form导入模块 import A.B.a #使用import导入模块只要将所有的模块放在当前目录中的某个文件夹内，然后在该文件夹中新建一个空的init.py文件，就可以通过目录结构的层次导入所需的模块，不用将目录的路径添加到sys.path路径列表中。 内部引用A: __init__.py B: __init__.py a.py C: __init__.py a.py b.py对于C目录中的b.py引用同样位于C目录中的a.py import aC目录中的b.py要引用B目录中的a.py from A.B import a","tags":[]},{"title":"数据分析 PyDay03","date":"2019-10-23T08:17:29.451Z","path":"2019/10/23/数据分析 PyDay03/","text":"第三章列表元组列表 以’[]’包围的数据的集合，以’，’分隔，列表中可以包含，任何数据类型也可以包含另一个列表。 12345678910列表操作 list.append() 追加成员 list.count(x) 计算x出现的次数 list.extend(L) 向列表中追加另一个列表L list.index(x) 获得参数x在列表中的位置 list.insert() 像列表中插入数据 list.pop() 删除最后一个值，并返回 list.remove() 删除列表中的成员 list.reverse() 列表成员顺序颠倒 list.sort() 列表中成员排序 元组 元组以’()’包围的数据集合，元组中的数据一旦确定就不能改变，只有分片和索引操作。 可以将元组插入在列表list[4]中 list[4] #索引访问列表的第五个成员即插入的元组 list[1,4] #使用切片获得2-5的成员，不包括5字典 字典中的元素由键/值对组成，每个值必须是唯一的。以’{}’包围的数据集合。字典是无序的，通过键访问成员。哈希技术实现字典。键对应的值可以改变，可以包含任何其他类型，键不可变。声明方式：“ 键 : 值 ” 字典操作 dict.clear() #清空 dict.copy() #复制 dict.get(k) #获得k键的值 dict.items() #获得由键和值组成的列表 dict.keys() #获得键的列表 dict.pop(k) #删除键k dict.update() #更新成员 dict.values() #获取值得列表文件open(filename,mode) filename：要打开的文件名 mode： &apos;r&apos;：只读; &apos;w&apos;：只写; &apos;b&apos;：二进制文件操作 file.read() #整个文件读入字符串中 file.readline() #读入文件的一行到字符串中 file.readlines() #整个文件按行读入字符串中 file.write() #向文件中写入字符串 file.writelines() #向文件中写入一个列表 file.close() #关闭打开的文件布尔值TrueFlase 流程控制语句if语句 if &lt;条件&gt;: &lt;语句&gt; elif &lt;条件&gt;: &lt;语句&gt; else: &lt;语句&gt;比较运算符 a==b a!=b a&gt;b a&gt;=b a&lt;b a&lt;=b循环：for语句 for &lt;&gt; in &lt;对象集合&gt;： #可以是列表，元组，字典 或 range()函数产生一个整数列表 if &lt;条件&gt;: break #终止循环 if &lt;条件&gt;: continue #跳过本次循环，继续下一轮循环 &lt;其他语句&gt; else: #如果for循环未被break终止，则执行else中的语句 &lt;语句&gt; &gt; #range( 1 , 5+1 )产生1-5的整数列表 1 2 3 4 5循环：while语句 while &lt;条件&gt;: if &lt;条件&gt;: break #终止循环 if &lt;条件&gt;: continue #跳过本次循环，继续下一轮循环 &lt;其他语句&gt; else: #如果for循环未被break终止，则执行else中的语句 &lt;语句&gt;","tags":[]},{"title":"数据分析 PyDay02","date":"2019-10-23T08:17:29.449Z","path":"2019/10/23/数据分析 PyDay02/","text":"第三章 数据类型和流程控制语句。。。（有点高大上）数字 整型和浮点型 在Python3中，int类型可保存任意大小的整数， 数字无需事先声明类型，自动赋给值类型 运算符 字符串 由单引号(‘’)，双引号(“”)，三引号(‘’’…’’’,”””…”””)包围三引号包围的字符可以由多行组成 转义字符 操作字符串 使用字符串操作函数或运算符对字符串进行操作，不会改变字符的内容。要修改原字符串，要将函数操作结果返回给字符串字符串操作函数中较复杂的：str.join()/str.split() 字符串的索引和切片 字符串相当于一个不可变序列的列表（列表相当于数组），声明后，字符位置不可变。允许负数表示字符的序号，负数从尾部开始计算str[0,4] 半闭半开区间 str字符串中第一个到第四个。 格式化字符串（感觉平时没有用到太多） 类型转换 int(‘10’) + 4 #将字符转换为数字‘10’ + str(4) #将数字转换为字符串ps:Python3中locale模块提供了atoi()函数，将字符串转换为数字 原始字符串 以R或r开始，原始字符串中，字符’&#39;失去转义作用为正则表达式设计，可以用来表示windows下的路径，但是如果以’&#39;结尾会报错 示例代码： import os path=r&apos;e:\\book&apos; #使用原始字符串 path=r&apos;e:\\book\\&apos;会报错 os.listdir(path) #列出目录中内容","tags":[]},{"title":"数据分析 PyDay01","date":"2019-10-23T08:17:29.447Z","path":"2019/10/23/数据分析 PyDay01/","text":"2018/11/27 开始学习Python数据分析第一章1、再一次了解了python的很多优点 开源 跨平台 可扩展 模块丰富 它和java一样是解释型语言 2、其他程序设计语言中的python Jython:Python语言的中文实现 Cpython 这两个相比Jython的运行速度会慢一些。 Jython首先需要Java解释器进行解释，而python脚本有需要python的解释器来解释。 Jython使得Python可以使用Java丰富的链接库 Python for .NET 可以使用Python与.NET进行交互 IronPython 也是Python在.NET平台上的实现和Python for .NET 相比IronPython的功能更加强大 3、Python开发环境文本编辑器 Vim Vi是UNIX系统下的文本编辑器。Vim是Vi的改进版本，可以在windows上使用。 下载地址 Emacs 号称“世界还是那个最强大的文本编辑器” 与Vim不同，Emacs不是有模式编辑器。 解压版软件 下载地址 PythonWin Vim和Emacs上手较难，一旦习惯，就会发现确实强大。 Python在Windows系统下的扩展包。 下载地址 集成开发环境 Wing IDE windows和Linux系统中 下载地址 Komodo windows和Linux系统中 除了Python还有Perl、PHP、Tcl和HTML等提供了集成开发环境 下载地址 Boa Constructor 提供可视化的编程和操作框架 下载地址 PyDev Eclipse中的Python开发插件 下载地址 Eric3 集成了项目管理工具，可以生成UML的图表 下载地址 DrPython 基于wxPython和Scintilla库 下载地址 SciTE 支持语法高亮，代码折叠等功能 可以将代码导出为HTML\\RTF和PDF格式 下载地址 看了书才了解到了这么多的python编辑器，我现在用的，竟然也没有，一丝尴尬我使用的Pycharm属于集成开发环境，个人觉得很牛逼，毕竟身边的大佬用Pycharm开发了很多好玩的东西。","tags":[]},{"title":"数据分析 PyDay01（续）","date":"2019-10-23T08:17:29.445Z","path":"2019/10/23/数据分析 PyDay01（续）/","text":"第二章 Python基础啊。。。2.1缩进分层 python标准缩进为四个空格，即一个Tab键 python自带的IDLE和Python的集成环境设置是一个Tab键等于四个空格 但是一些普通的文本编辑器不是这样的，需要自己设置 缩进仅仅是Python组织代码的一种方式 2.2注释方式`#注释。。。。。。。。。。`#仅仅注释自己所在行 `&quot;&quot;&quot;` `三个双引号包围的部分为注释` `&quot;&quot;&quot;` 2.3断行 python中不需要以 ; 作为结束符号 但是可以以 ; 为分隔将两个语句写在一行 `print(&apos;1&apos;);print(&apos;2&apos;)` 单引号=双引号可以使用 \\ 来换行 `c = 1 + \\` `2`或者使用（） `c = (1 + ` `2)` 2.4输入输出输入 input()函数返回值为字符串 类型转换函数 - int()：**整形** - float()：**浮点数** - str()：**字符串** - chr()：**ASCII值转化为ASCII字符** - hex()：**十六进制字符串** - oct()：**八进制字符串** - ord()：**ASCII值转化为ASCII字符**输出 print()输出函数 - `print(a) #输出整形/值/字符串` - `print(a+b) #输出表达式` - `l = [1,2,3]` `print(l) #输出列表` - `t =(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;)` `print(t) #输出元组` - `print(l,&apos;\\n&apos;,t) #使用换行符` 2.5中文支持Python2中的py文件中，需要在第一行制定字符编码集 `#-*- coding:UTF-8 -*-`or `print a.decode(&apos;utf-8&apos;).encode(&apos;cp936&apos;)` Windows命令行中采用的是CP936编码 Python3中不需要反复编码和解码，直接输出即可。 Python3.6中没有decode()函数，只有encode()函数 Python中可以使用的字符编码： UTF-8 , CP936 , GB2312 , ISO-8859-1 2.6Python计算器math模块的数学函数 使用之前 import math math.sin(0.5) sin(x)：正弦值 cos(x)：余弦值 asin(x)：反正弦值 acos(x)：反余弦值 tan(x)：正切值 atan(x)：余切值、反正切值 hypot(x)：RT三角形斜边长度 fmod(x)：求x/y的余数 ceil(x)：取不小于x的最小整数 floor(x)：取不大于x的最大整数 fabs(x)：绝对值 exp(x)：e的x次幂 pow(x，y)：x的y次幂 log10(x)：以10为底x的对数 sqrt(x)：x的平方根 pi:π的值","tags":[]},{"title":"联动","date":"2019-10-23T08:17:29.443Z","path":"2019/10/23/联动/","text":"这次采用了使用4.x的功能实现联动，3.x的extent-change可以实现，但是会出现延迟。实现嗯，很简单，创建两个Mapview，监听事件，设置center和zoom但是设置zoom，总是会莫名的出BUG，或者在多监听一个滚轮方便一点就是现在使用的办法。 4.x 动态地图的加载 view01.on([&quot;pointer-down&quot;, &quot;pointer-move&quot;], function (evt) { view02.center = view01.center; view02.scale = view01.scale;//代替zoom }); view02.on([&quot;pointer-down&quot;, &quot;pointer-move&quot;], function (evt) { view01.center = view02.center; view01.scale = view02.scale; });","tags":[]},{"title":"卷帘","date":"2019-10-23T08:17:29.441Z","path":"2019/10/23/卷帘/","text":"思路 定义要素图层 new一个卷帘对象 开启小部件PS：要素图层需要添加在map容器中才能在卷帘对象中设置layers 实用方法swipeWidget01.disable();//禁用小部件 swipeWidget23.enable();//启用小部件完整代码&lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1, maximum-scale=1,user-scalable=no&quot;&gt; &lt;title&gt;Layer Swipe&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;esri.css&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;tundra.css&quot; /&gt; &lt;style&gt; html, body, #map { padding: 0; margin: 0; height: 100%; position: relative; } &lt;/style&gt; &lt;script src=&quot;https://js.arcgis.com/3.29/&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body class=&quot;calcite&quot;&gt; &lt;div id=&quot;map&quot; class=&quot;map&quot;&gt; &lt;div id=&quot;swipeDiv&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; require([ &quot;esri/map&quot;, &quot;esri/layers/FeatureLayer&quot;, &quot;esri/dijit/LayerSwipe&quot;, &quot;dojo/domReady!&quot; ], function ( Map, FeatureLayer, LayerSwipe ) { var map = new Map(&quot;map&quot;); thingslayer0 = new FeatureLayer(&quot;http://localhost:6080/arcgis/rest/services/gaofen/bazhou/MapServer&quot; + &quot;/0&quot;, { mode: FeatureLayer.MODE_ONDEMAND, outFields: [&quot;*&quot;] }); thingslayer1 = new FeatureLayer(&quot;http://localhost:6080/arcgis/rest/services/gaofen/bazhou/MapServer&quot; + &quot;/1&quot;, { mode: FeatureLayer.MODE_ONDEMAND, outFields: [&quot;*&quot;] }); //矢量 map.addLayer(thingslayer0); map.addLayer(thingslayer1); var swipeWidget = new LayerSwipe({ type: &quot;vertical&quot;, map: map, // 要卷帘哪些图层 layers: [thingslayer0, thingslayer1], }, &quot;swipeDiv&quot;); swipeWidget.startup(); }); &lt;/script&gt; &lt;/html&gt;","tags":[]},{"title":"加载---闪烁Layer","date":"2019-10-23T08:17:29.439Z","path":"2019/10/23/加载---闪烁Layer/","text":"一个简单的图层切换闪烁动画，js入门练手知识点设置显示图层layer.setVisibleLayers([0]); 查看图层编号步骤： 查看已经发布地图服务 功能—REST URL 查看 贴代码&lt;!DOCTYPE html&gt; &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/esri/css/esri.css&quot; /&gt; &lt;script src=&quot;https://js.arcgis.com/3.28/&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .MapClass { width: 100%; height: 960px; border: 1px solid #000; } &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; var flag = 0; var Max_layer=30; function init(){ var btn = document.getElementById(&quot;btn0&quot;); setInterval(function(){ btn.click(); },500); } require([&quot;esri/map&quot;, &quot;dojo/on&quot;, &quot;dojo/dom&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;dojo/domReady!&quot;], function (Map, on, dom, ArcGISDynamicMapServiceLayer ) { var map = new Map(&quot;MyMapDiv&quot;); var layer = new ArcGISDynamicMapServiceLayer (&quot;http://localhost:6080/arcgis/rest/services/demo/WLFX_huanbao/MapServer&quot;); map.addLayer(layer); layer.setVisibleLayers([0]); on(dom.byId(&quot;btn0&quot;),&quot;click&quot;,function(e){ flag++; if(flag&lt;=Max_layer) layer.setVisibleLayers([flag]); else flag=0; }) }); &lt;/script&gt; &lt;/head&gt; &lt;body onload=&quot;init()&quot;&gt; &lt;div id=&quot;MyMapDiv&quot; class=&quot;MapClass&quot;&gt;&lt;/div&gt; &lt;button type=&quot;button&quot; id=&quot;btn0&quot; &gt;&lt;/button&gt; &lt;/body&gt; &lt;/html&gt;","tags":[]},{"title":"加载---加载动态图层+注册文件夹","date":"2019-10-23T08:17:29.437Z","path":"2019/10/23/加载---加载动态图层+注册文件夹/","text":"基础：加载动态图层方法： 添加一个button（添加动态图层），给button绑定on模块的点击事件 on(dom.byId(&quot;btn&quot;),&quot;click&quot;,function(e){}) 定义数据源，设置命名空间，设置命名空间下面的shp var dataSource = new TableDataSource(); dataSource.workspaceId = &quot;demo&quot;; dataSource.dataSourceName = &quot;demoShp.shp&quot;; 定义图层数据源，对其赋值 var layerSource = new LayerDataSource(); layerSource.dataSource = dataSource; 定义要素图层（动态图层） var layer2 = new FeatureLayer (&quot;http://localhost:6080/arcgis/rest/services/demo/Practice/MapServer/dynamicLayer&quot;, { mode: FeatureLayer.MODE_ONDEMAND, outFields: [&quot;*&quot;], source: layerSource }); 定义线符号，渲染器 var lineSymbol = new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new dojo.Color([255, 0, 0]), 3); var renderer = new esri.renderer.SimpleRenderer(lineSymbol); 给要素图层设置渲染器 layer2.setRenderer(renderer); layer2.refresh(); 把要素图层添加到map上 map.addLayer(layer2); 贴代码&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head lang=&quot;en&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/esri/css/esri.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/dijit/themes/tundra/tundra.css&quot;/&gt; &lt;script type=&quot;text/Javascript&quot; src=&quot;https://js.arcgis.com/3.28/&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; require([&quot;esri/map&quot;, &quot;dojo/dom&quot;, &quot;dojo/on&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;esri/layers/FeatureLayer&quot;, &quot;esri/layers/TableDataSource&quot;, &quot;esri/layers/LayerDataSource&quot;, &quot;esri/renderers/SimpleRenderer&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;, &quot;dojo/domReady!&quot;], function ( Map,dom,on, ArcGISDynamicMapServiceLayer, FeatureLayer, TableDataSource, LayerDataSource, SimpleRenderer,SimpleLineSymbol) { var map = new Map(&quot;mapDiv&quot;); var layer1 = new ArcGISDynamicMapServiceLayer(&quot;http://localhost:6080/arcgis/rest/services/demo/Practice/MapServer&quot;); map.addLayer(layer1); on(dom.byId(&quot;btn&quot;),&quot;click&quot;,function(e){ // 定义数据源，设置命名空间，设置命名空间下面的shp var dataSource = new TableDataSource(); dataSource.workspaceId = &quot;demo&quot;; dataSource.dataSourceName = &quot;demoShp.shp&quot;; // 定义图层数据源，对其赋值 var layerSource = new LayerDataSource(); layerSource.dataSource = dataSource; //定义一个要素图层:动态图层 var layer2 = new FeatureLayer(&quot;http://localhost:6080/arcgis/rest/services/demo/Practice/MapServer/dynamicLayer&quot;, { mode: FeatureLayer.MODE_ONDEMAND, outFields: [&quot;*&quot;], source: layerSource }); //定义线符号，渲染器 var lineSymbol = new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new dojo.Color([255, 0, 0]), 3); var renderer = new esri.renderer.SimpleRenderer(lineSymbol); //给要素图层设置渲染器 layer2.setRenderer(renderer); layer2.refresh(); //把要素图层添加到map上 map.addLayer(layer2); }) }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;mapDiv&quot; style=&quot;height:600px;&quot;&gt;&lt;/div&gt; &lt;button id=&quot;btn&quot;&gt;添加动态图层&lt;/button&gt; &lt;/body&gt; &lt;/html&gt;","tags":[]},{"title":"加载---动态地图加载","date":"2019-10-23T08:17:29.436Z","path":"2019/10/23/加载---动态地图加载/","text":"先来看看效果图这是北京市的2000年的土地资源主题地图 页面按加载完成之后，地图可以放大缩小，平移。所有的放大缩小平移都是一起的，显而易见这是一个图层。可以在esri官方查找ArcJS的APIArcGIS API for JavaScript 3.29 进入主题1. 先来看一下一般的html代码框架&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/esri/css/esri.css&quot;/&gt; &lt;script src=&quot;https://js.arcgis.com/3.28/&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; require( , function () {} ); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;mapDiv&quot; style=&quot;height:800px;&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt;其中不同的几行：&lt;!-- 引入map相关的引用css，可以通过https://js.arcgis.com或者部署本地js --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/esri/css/esri.css&quot;/&gt; &lt;!-- 引入map相关的引用js --&gt; &lt;script src=&quot;https://js.arcgis.com/3.28/&quot;&gt;&lt;/script&gt; &lt;!-- 实际的js操作代码 --&gt; &lt;!-- require中一般为2/2及以上的function、on等参数 --&gt; &lt;!-- 第一个参数为地图操作中的相关模块引用 --&gt; &lt;!-- 在本案例中，该函数为记载函数 --&gt; &lt;script type=&quot;text/javascript&quot;&gt; require( , function () {} ); &lt;/script&gt;2. 引用模块记载地图的引用基本模块：例如加载Arcgis官方的自带底图 require([&quot;esri/map&quot;, &quot;dojo/domReady!&quot;] , function () {} );本例中，通过引用ArcSer的REST URL加载地图。需要引用动态图层模块：&quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;引用以&quot;dojo/domReady!&quot;结尾，基于dojo require([&quot;esri/map&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;dojo/domReady!&quot;] , function () {} );3. 操作函数分为三步： 给div定义一个map容器 定义一个图层Layer 把Layer加载到map容器里 // function中的参数顺序必须和引用的模块顺序一样，否则会出现未定义的ERROR function (Map, ArcGISDynamicMapServiceLayer) { // div的id为mapDiv var map = new Map(&quot;mapDiv&quot;); // 引用ArcSer的REST URL var layer1 = new ArcGISDynamicMapServiceLayer(&quot;http://localhost:6080/arcgis/rest/services/ecology/beijing_2012_3/MapServer&quot;); // 引用map的addLayer方法加载动态图层 map.addLayer(layer1); }完整代码&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/esri/css/esri.css&quot;/&gt; &lt;script src=&quot;https://js.arcgis.com/3.28/&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; require([&quot;esri/map&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;dojo/domReady!&quot;], function (Map, ArcGISDynamicMapServiceLayer) { var map = new Map(&quot;mapDiv&quot;,{ logo:false }); var layer1 = new ArcGISDynamicMapServiceLayer(&quot;http://localhost:6080/arcgis/rest/services/ecology/beijing_2012_3/MapServer&quot;); map.addLayer(layer1); }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;mapDiv&quot; style=&quot;height:800px;&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt;多加尝试，万事开头难，后面就会容易些了，学习中的bug可以在放在评论区一起讨论欢迎指出文章中的错误","tags":[]},{"title":"基础功能---具体坐标生成Graphic","date":"2019-10-23T08:17:29.434Z","path":"2019/10/23/基础功能---具体坐标生成Graphic/","text":"1.图层分析共两层 底图（动态图层） 客户端图层（添加指定坐标的点线面） 2. 步骤 通过switch选择定义对应的geometry 根据坐标创建Graphic graphic=new Graphic(geometry, xxx ); 把图形加载到图层中 graphicsLayer.add(graphic); 3.贴代码 Graphic .MapClass{ width:100%; height:500px; border:1px solid #000; } require([\"esri/map\",\"esri/layers/ArcGISDynamicMapServiceLayer\", \"esri/layers/GraphicsLayer\", \"dojo/on\",\"dojo/query\",\"dojo/colors\", \"esri/graphic\",\"esri/symbols/SimpleMarkerSymbol\", \"esri/symbols/SimpleLineSymbol\", \"esri/symbols/SimpleFillSymbol\", \"esri/geometry/Point\", \"esri/geometry/Polyline\",\"esri/geometry/Polygon\", \"esri/geometry/Circle\", \"dojo/domReady!\"], function(Map,ArcGISDynamicMapServiceLayer, GraphicsLayer,on,query,Color,Graphic, SimpleMarkerSymbol,SimpleLineSymbol, SimpleFillSymbol,Point,Polyline,Polygon,Circle){ var map = new Map(\"mapDiv\"); var layer = new ArcGISDynamicMapServiceLayer (\"http://localhost:6080/arcgis/rest/services/ecology/beijing_2012_3/MapServer\"); map.addLayer(layer); //创建客户端图层 var graphicsLayer=new GraphicsLayer(); //将客户端图层添加到地图中 map.addLayer(graphicsLayer); //通过query查询到button对象 var btns=query(&quot;button&quot;); on(btns,&quot;click&quot;,function(event){ var text=this.innerHTML; //定义符号 var lineSymbol=new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new Color([255, 0, 0]), 3); var pSymbol=new SimpleMarkerSymbol(SimpleMarkerSymbol.STYLE_CIRCLE,10, lineSymbol, new Color([255, 0, 0])); var fill=SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol, new Color([255, 0, 0])); //声明类型和图形 var geometry; var graphic; //根据文本定义相应的geometry switch(text) { case &quot;添加点&quot;: geometry=new Point({ &quot;x&quot;:510706, &quot;y&quot;:3986100, &quot;spatialReference&quot;:map.spatialReference }); graphic=new Graphic(geometry,pSymbol); break; case &quot;添加线&quot;: //点的坐标对 var paths=[]; paths[0]=[ [510326,3985702], [510994, 3985676], [511078, 3985903], [510433, 3985928] ]; geometry=new Polyline({ &quot;paths&quot;:paths, &quot;spatialReference&quot;:map.spatialReference }) graphic=new Graphic(geometry,lineSymbol); break; case &quot;添加面&quot;: //点的坐标对 var ring=[]; ring[0]=[ [510275, 3986100], [510508, 3986162], [510596, 3986032], [510271, 3985847], [510275, 3986100] ]; geometry=new Polygon({ &quot;rings&quot;:ring, &quot;spatialReference&quot;:map.spatialReference }); graphic=new Graphic(geometry,fill); break; case &quot;添加圆&quot;: //圆心 var p=new Point({ &quot;x&quot;:510706, &quot;y&quot;:3986100, &quot;spatialReference&quot;:map.spatialReference }); //半径 var r=20; geometry=new Circle(p,{ &quot;radius&quot;:r }); graphic=new Graphic(geometry,fill); break; } //将图形添加到图层中 graphicsLayer.add(graphic); }) }) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;mapDiv&quot; class=&quot;MapClass&quot;&gt;&lt;/div&gt; &lt;button&gt;添加点&lt;/button&gt; &lt;button&gt;添加线&lt;/button&gt; &lt;button&gt;添加面&lt;/button&gt; &lt;button&gt;添加圆&lt;/button&gt; &lt;/body&gt; &lt;/html&gt;","tags":[]},{"title":"基础功能---交互画图","date":"2019-10-23T08:17:29.432Z","path":"2019/10/23/基础功能---交互画图/","text":"1.效果图 2.引入模块&quot;esri/toolbars/draw&quot;, &quot;esri/graphic&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;, &quot;esri/symbols/SimpleMarkerSymbol&quot;, &quot;esri/symbols/SimpleFillSymbol&quot;,3.像是绑定小部件的进阶版 都是使用switch选择合适的操作方法 query(&quot;button&quot;).on(&quot;click&quot;,function(event){ var value=this.innerHTML; switch(value){ case &quot;绘制点&quot;:{ toolbar.activate(Draw.POINT, { showTooltips:true }) break; } case &quot;绘制折线&quot;:{ toolbar.activate(Draw.POLYLINE, { showTooltips:true }) break; } case &quot;绘制面&quot;:{ toolbar.activate(Draw.POLYGON, { showTooltips:true }) break; } case &quot;徒手线&quot;:{ toolbar.activate(Draw.FREEHAND_POLYLINE, { showTooltips:true }) break; } case &quot;徒手面&quot;:{ toolbar.activate(Draw.FREEHAND_POLYGON, { showTooltips:true }) break; } } }); 具有改进的是，引入on模块，toolbar通过switch决定各自操作方法（这里还不是太明白@@@标记） on(toolbar,&quot;draw-complete&quot;, function (result) { var geometry=result.geometry; var type=geometry.type; var graphic; switch (type) { case &quot;point&quot;: graphic= new Graphic(geometry, marker); break; case &quot;polyline&quot;: graphic= new Graphic(geometry, lineSymbol); break; case &quot;polygon&quot;: graphic= new Graphic(geometry, fill); break; } map.graphics.add(graphic); toolbar.deactivate(); }); 4.贴代码&lt;!DOCTYPE html&gt; &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt; &lt;title&gt;WebGIS&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/esri/css/esri.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/dijit/themes/tundra/tundra.css&quot;/&gt; &lt;script type=&quot;text/Javascript&quot; src=&quot;https://js.arcgis.com/3.28/&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .MapClass{ width:100%; height:800px; border:1px solid #000; } &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; require([&quot;esri/map&quot;,&quot;dojo/dom&quot;,&quot;dojo/on&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;dojo/query&quot;, &quot;esri/toolbars/draw&quot;, &quot;esri/graphic&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;, &quot;esri/symbols/SimpleMarkerSymbol&quot;, &quot;esri/symbols/SimpleFillSymbol&quot;, &quot;dojo/domReady!&quot;], function (Map,dom,on, ArcGISDynamicMapServiceLayer,query, Draw, SimpleLineSymbol,Graphic,SimpleMarkerSymbol,SimpleFillSymbol) { var map = new esri.Map(&quot;MyMapDiv&quot;); var layer = new ArcGISDynamicMapServiceLayer (&quot;http://localhost:6080/arcgis/rest/services/ecology/beijing_2012_3/MapServer&quot;); map.addLayer(layer) var toolbar = new Draw(map, { showTooltips: true }); var lineSymbol = new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new dojo.Color([255, 0, 0]), 3); var marker= new SimpleMarkerSymbol(SimpleMarkerSymbol.STYLE_CIRCLE,10, lineSymbol, new dojo.Color([255, 0, 0])); var fill= new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol, new dojo.Color([255, 0, 0])); on(toolbar,&quot;draw-complete&quot;, function (result) { var geometry=result.geometry; var type=geometry.type; var graphic; switch (type) { case &quot;point&quot;: graphic= new Graphic(geometry, marker); break; case &quot;polyline&quot;: graphic= new Graphic(geometry, lineSymbol); break; case &quot;polygon&quot;: graphic= new Graphic(geometry, fill); break; } map.graphics.add(graphic); toolbar.deactivate(); }); query(&quot;button&quot;).on(&quot;click&quot;,function(event){ var value=this.innerHTML; switch(value){ case &quot;绘制点&quot;:{ toolbar.activate(Draw.POINT, { showTooltips:true }) break; } case &quot;绘制折线&quot;:{ toolbar.activate(Draw.POLYLINE, { showTooltips:true }) break; } case &quot;绘制面&quot;:{ toolbar.activate(Draw.POLYGON, { showTooltips:true }) break; } case &quot;徒手线&quot;:{ toolbar.activate(Draw.FREEHAND_POLYLINE, { showTooltips:true }) break; } case &quot;徒手面&quot;:{ toolbar.activate(Draw.FREEHAND_POLYGON, { showTooltips:true }) break; } } }); }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;MyMapDiv&quot; class=&quot;MapClass&quot;&gt;&lt;/div&gt; &lt;button&gt;绘制点&lt;/button&gt; &lt;button&gt;绘制折线&lt;/button&gt; &lt;button&gt;绘制面&lt;/button&gt; &lt;button&gt;徒手线&lt;/button&gt; &lt;button&gt;徒手面&lt;/button&gt; &lt;/body&gt; &lt;/html&gt;拓展将交互画图与空间查询结合。","tags":[]},{"title":"基础功能---几何服务_缓冲区","date":"2019-10-23T08:17:29.430Z","path":"2019/10/23/基础功能---几何服务_缓冲区/","text":"1.效果图 2.启用几何服务和发布的地图一样，通过REST URL调用 3.引入模块&quot;esri/toolbars/draw&quot;, &quot;esri/graphic&quot;, &quot;esri/tasks/GeometryService&quot;, &quot;esri/tasks/BufferParameters&quot;, &quot;dojo/colors&quot;,4.步骤 创建几何服务对象 //这里是几何服务的REST URL var geometryServices = new GeometryService(&quot;http://localhost:6080/arcgis/rest/services/Utilities/Geometry/GeometryServer&quot;); 创建缓存参数对象 var params = new BufferParameters(); 使用toolbar上的绘图工具 var toolBar = new Draw(map); 创建点，线，面 var pointSymbol = new SimpleMarkerSymbol(); lineSymbol = new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new Color([255, 0, 0]), 2); polygonSymbol = new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol, new Color([255, 255, 0, 0.25])); 给画点按钮绑定事件 on(dom.byId(&quot;point&quot;), &quot;click&quot;, function () { //激活画点工具 toolBar.activate(Draw.POINT, { showTooltips: true }) }) 绘图结束绑定事件 on(toolBar, &quot;draw-end&quot;, function (result) { //获得点形状 var geometry = result.geometry; //创建Graphic var graphicpoint = new Graphic(geometry, pointSymbol); map.graphics.add(graphicpoint); //关闭绘图工具 toolBar.deactivate(); // *** 构建缓冲区分析的形状属性 //注意这里可以放一个数组，此处为了方便我们只对一个形状进行缓冲区分析 params.geometries = [geometry]; }) 给缓冲区分析按钮绑定事件 on(dom.byId(&quot;Btn&quot;), &quot;click&quot;, function () { var mi = $(&quot;#te&quot;).val(); //缓冲距离 params.distances = [mi]; //空间参考，缓冲区样式，透明度等 params.bufferSpatialReference = map.spatialReference; params.outSpatialReference = map.spatialReference; //执行分析处理结果 geometryServices.buffer(params, function (result) { //处理缓冲区分析得到的结果 for (var idx in result) { //创建Graphic var graphic = new Graphic(result[idx], polygonSymbol) //结果放在map中 map.graphics.add(graphic) } }); })5. 贴代码&lt;!DOCTYPE html&gt; &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;title&gt;缓冲区分析&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/esri/css/esri.css&quot; /&gt; &lt;script src=&quot;https://js.arcgis.com/3.28/&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://code.jquery.com/jquery-1.12.4.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .MapClass { width: 100%; height: 900px; } &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; require([&quot;esri/map&quot;, &quot;dojo/dom&quot;, &quot;dojo/on&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;esri/symbols/SimpleMarkerSymbol&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;, &quot;esri/symbols/SimpleFillSymbol&quot;, &quot;esri/toolbars/draw&quot;, &quot;esri/graphic&quot;, &quot;esri/tasks/GeometryService&quot;, &quot;esri/tasks/BufferParameters&quot;, &quot;dojo/colors&quot;, &quot;dojo/domReady!&quot;], function (Map, dom, on, ArcGISDynamicMapServiceLayer, SimpleMarkerSymbol, SimpleLineSymbol, SimpleFillSymbol, Draw, Graphic, GeometryService, BufferParameters, Color) { var map = new esri.Map(&quot;mapDiv&quot;); var layer = new esri.layers.ArcGISDynamicMapServiceLayer (&quot;http://localhost:6080/arcgis/rest/services/ecology/beijing_2012_3/MapServer&quot;); map.addLayer(layer); //创建几何服务对象 var geometryServices = new GeometryService(&quot;http://localhost:6080/arcgis/rest/services/Utilities/Geometry/GeometryServer&quot;); //创建缓存参数对象 var params = new BufferParameters(); //使用toolbar上的绘图工具 var toolBar = new Draw(map); //创建点符号 var pointSymbol = new SimpleMarkerSymbol(); pointSymbol.style = SimpleMarkerSymbol.STYLE_CIRCLE; pointSymbol.setSize(10); pointSymbol.setColor(new Color(&quot;#FFFFCC&quot;)); //线符号 lineSymbol = new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new Color([255, 0, 0]), 2); //面符号 polygonSymbol = new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol, new Color([255, 255, 0, 0.25])); //给画点按钮绑定事件 on(dom.byId(&quot;point&quot;), &quot;click&quot;, function () { //激活画点工具 toolBar.activate(Draw.POINT, { showTooltips: true }) }) //绘图结束绑定事件 on(toolBar, &quot;draw-end&quot;, function (result) { //获得点形状 var geometry = result.geometry; //创建Graphic var graphicpoint = new Graphic(geometry, pointSymbol); map.graphics.add(graphicpoint); //关闭绘图工具 toolBar.deactivate(); //很重要！！！在这里构建缓冲区分析的形状属性 //注意这里可以放一个数组，此处为了方便我们只对一个形状进行缓冲区分析 params.geometries = [geometry]; }) //给缓冲区分析按钮绑定事件 on(dom.byId(&quot;Btn&quot;), &quot;click&quot;, function () { // var mi = document.getElementById(&quot;te&quot;).value; var mi = $(&quot;#te&quot;).val(); //缓冲距离 params.distances = [mi]; //空间参考 params.bufferSpatialReference = map.spatialReference; params.outSpatialReference = map.spatialReference; //执行分析处理结果 geometryServices.buffer(params, function (result) { //处理缓冲区分析得到的结果 for (var idx in result) { //创建Graphic var graphic = new Graphic(result[idx], polygonSymbol) //将每一个结果都放在map中 map.graphics.add(graphic) } }); }) }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;mapDiv&quot; class=&quot;MapClass&quot;&gt;&lt;/div&gt; &lt;input id=&quot;point&quot; type=&quot;button&quot; value=&quot;点&quot; /&gt; &lt;input id=&quot;te&quot; type=&quot;text&quot; value=&quot;缓冲距离&quot;&gt; &lt;input id=&quot;Btn&quot; type=&quot;button&quot; value=&quot;缓冲区分析&quot; /&gt; &lt;/body&gt; &lt;/html&gt;6. 拓展对连续点进行缓冲区操作，怎么消除上一个操作的缓冲区？怎么连续选点，批量建立缓冲区？","tags":[]},{"title":"基础功能---地图打印","date":"2019-10-23T08:17:29.429Z","path":"2019/10/23/基础功能---地图打印/","text":"官方的例子这部分很清楚。 应用都是很简单的复制粘贴，此处不再赘述。可以将官方的代码封装成接口，方便开发使用 贴代码&lt;!DOCTYPE html&gt; &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt; &lt;title&gt;地图打印&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/esri/css/esri.css&quot; /&gt; &lt;script src=&quot;https://js.arcgis.com/3.28/&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://code.jquery.com/jquery-1.12.4.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .MapClass{ width:100%; height:500px; border:1px solid #000; } &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; require([&quot;esri/map&quot;, &quot;dojo/dom&quot;,&quot;dojo/on&quot;,&quot;dojo/query&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;esri/symbols/SimpleMarkerSymbol&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;, &quot;esri/symbols/SimpleFillSymbol&quot;, &quot;esri/toolbars/draw&quot;, &quot;esri/graphic&quot;, &quot;esri/tasks/PrintTask&quot;, &quot;esri/tasks/PrintTemplate&quot;, &quot;esri/tasks/PrintParameters&quot;, &quot;dojo/colors&quot;, &quot;dojo/domReady!&quot;], function (Map,dom,on,query, ArcGISDynamicMapServiceLayer, SimpleMarkerSymbol, SimpleLineSymbol, SimpleFillSymbol, Draw, Graphic, PrintTask,PrintTemplate,PrintParameters, Color) { var map = new esri.Map(&quot;mapDiv&quot;); var layer = new esri.layers.ArcGISDynamicMapServiceLayer (&quot;http://localhost:6080/arcgis/rest/services/ecology/beijing_2012_3/MapServer&quot;); map.addLayer(layer); //创建绘图对象 var toolBar = new Draw(map); //线符号 lineSymbol = new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new Color([255, 0, 0]), 3); //面符号 polygonSymbol = new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol, new Color([255, 0, 0, 0.25])); //给绘制polygon的按钮绑定事件 query(&quot;.pbtn&quot;).on(&quot;click&quot;,function(event){ //激活绘制多边形 toolBar.activate(Draw.POLYGON, { showTooltips:true }) }) //绘图结束绑定事件 on(toolBar,&quot;draw-end&quot;,function(result){ //获得面形状 var geometry=result.geometry; //创建Graphic var graphicpoint= new Graphic(geometry, polygonSymbol); map.graphics.add(graphicpoint); //关闭绘图工具 toolBar.deactivate(); }) //给地图打印按钮绑定事件 on(dom.byId(&quot;Btn&quot;),&quot;click&quot;,function(){ //创建地图打印对象 var printMap = new PrintTask(&quot;http://localhost:6080/arcgis/rest/services/Utilities/PrintingTools/GPServer/Export%20Web%20Map%20Task&quot;); //创建地图打印模版 var template = new PrintTemplate(); //创建地图的打印参数，参数里面包括：模版和地图 var params = new PrintParameters(); //输出图片的空间参考 printMap.outSpatialReference = map.SpatialReference //打印图片的各种参数 template.exportOptions = { width: 850, height: 650, dpi: 96 }; //打印输出的格式 template.format = &quot;PDF&quot;; //输出地图的布局 template.layout = &quot;MAP_ONLY&quot;; PrintTemplate //设置参数地图 params.map = map; //设置参数模版 params.template = template; //运行结果 printMap.execute(params, function(result){ if (result != null) { //网页打开生成的地图 window.open(result.url); } }) }) }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;mapDiv&quot; class=&quot;MapClass&quot;&gt;&lt;/div&gt; &lt;button class=&quot;pbtn&quot; &gt;画多边形&lt;/button&gt; &lt;input id=&quot;Btn&quot; type=&quot;button&quot; value=&quot;地图打印&quot; /&gt; &lt;/body&gt; &lt;/html&gt;","tags":[]},{"title":"基础功能---地理编码","date":"2019-10-23T08:17:29.427Z","path":"2019/10/23/基础功能---地理编码/","text":"首先需要发布地理编码服务，再调用。还没有使用过这一功能。记录贴 贴代码： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt; &lt;title&gt;地理编码_动态图层服务&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/esri/css/esri.css&quot; /&gt; &lt;script src=&quot;https://js.arcgis.com/3.28/&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://code.jquery.com/jquery-1.12.4.js&quot;&gt;&lt;/script&gt; &lt;script&gt; require([&quot;esri/map&quot;,&quot;dojo/query&quot;,&quot;dojo/on&quot;,&quot;dojo/_base/array&quot;,&quot;dojo/dom&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;esri/tasks/locator&quot;, &quot;esri/symbols/SimpleMarkerSymbol&quot;, &quot;dojo/colors&quot;, &quot;esri/InfoTemplate&quot;,&quot;esri/graphic&quot;, &quot;dojo/domReady!&quot;], function(Map,query,on,array,dom,ArcGISDynamicMapServiceLayer,Locator,SimpleMarkerSymbol,Color,InfoTemplate,Graphic){ var map = new Map(&quot;mapDiv&quot;); var layer=new ArcGISDynamicMapServiceLayer(&quot;http://localhost:6080/arcgis/rest/services/demo/Practice/MapServer&quot;); map.addLayer(layer); query(&quot;#btn&quot;).on(&quot;click&quot;,function(){ //获得名称 var name=query(&quot;.nm&quot;)[0].value; //创建地理编码对象 var locator = new Locator(&quot;http://localhost:6080/arcgis/rest/services/demo/nameLoc_geo/GeocodeServer&quot;); //参数和服务的参数对应 var address = { &quot;Single Line Input&quot;: name}; //输出的空间参考 locator.outSpatialReference = map.spatialReference; var options = { address: address, outFields: [&quot;*&quot;] } //执行方法 locator.addressToLocations(options,function(candidates){ //获得运行之后的信息 if (candidates.length &gt; 0){ var htmls = &quot;&lt;table style=&apos;width: 100%&apos;&gt;&quot;; htmls = htmls + &quot;&lt;tr bgcolor=&apos;#E0E0E0&apos;&gt;&lt;td&gt;X 坐标&lt;/td&gt;&lt;td&gt;Y 坐标&lt;/td&gt;&lt;td&gt;得分&lt;/td&gt;&lt;/tr&gt;&quot;; array.forEach(candidates, function (candidate, index) { if (index % 2 == 1) { htmls = htmls + &quot;&lt;tr bgcolor=&apos;#E0E0E0&apos;&gt;&lt;td style=&apos;width: 60px&apos;&gt;&quot; + candidate.location.x + &quot;&lt;/td&gt;&lt;td style=&apos;width: 60px&apos;&gt;&quot; + candidate.location.y+ &quot;&lt;/td&gt;&lt;td&gt;&quot; + candidate.score + &quot;&lt;/td&gt;&lt;/tr&gt;&quot;; } else { htmls = htmls + &quot;&lt;tr&gt;&lt;td style=&apos;width: 60px&apos;&gt;&quot; + candidate.location.x + &quot;&lt;/td&gt;&lt;td style=&apos;width: 60px&apos;&gt;&quot; + candidate.location.y+ &quot;&lt;/td&gt;&lt;td&gt;&quot; + candidate.score + &quot;&lt;/td&gt;&lt;/tr&gt;&quot;; } }); htmls = htmls + &quot;&lt;/table&gt;&quot;; dom.byId(&quot;divShowResult&quot;).innerHTML = htmls; } },function(error){alert(error)}); }); }); &lt;/script&gt; &lt;/head&gt; &lt;body class=&quot;tundra&quot;&gt; &lt;div id=&quot;mapDiv&quot; style=&quot;width:900px; height:580px; border:1px solid #000;&quot;&gt;&lt;/div&gt; Name:&lt;input class=&quot;nm&quot; type=&quot;text&quot;&gt; &lt;input id=&quot;btn&quot; type=&quot;button&quot; value=&quot;定位&quot;&gt; &lt;div id=&quot;divShowResult&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt;","tags":[]},{"title":"分析---影像分析","date":"2019-10-23T08:17:29.425Z","path":"2019/10/23/分析---影像分析/","text":"1.效果图 2.发布服务 在Arccatalog中共享为影像服务 发布成功之后查看 说明发布成功 3.引入模块查询影像数据esri/tasks/ImageServiceIdentifyTask 参数：esri/tasks/ImageServiceIdentifyParameters esri/tasks/ImageServiceIdentifyResultesri/tasks/ImageServiceIdentifyResult接收返回的参数 影像测量esri/tasks/ImageServiceMeasureTask 参数：esri/tasks/ImageServiceMeasureParameters 4.步骤 加载图层（不使用动态，使用影像服务） 创建影像分析和分析方法的参数对象 绑定事件，获取高程值并弹出 其中的掩模规则等可以封装为接口，方便以后使用 5.代码 影像分析 &lt;meta http-equiv=&quot;keywords&quot; content=&quot;keyword1,keyword2,keyword3&quot;&gt; &lt;meta http-equiv=&quot;description&quot; content=&quot;this is my page&quot;&gt; &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/esri/css/esri.css&quot; /&gt; &lt;script src=&quot;https://js.arcgis.com/3.28/&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://code.jquery.com/jquery-1.12.4.js&quot;&gt;&lt;/script&gt; &lt;style&gt; .MapClass{ width:100%; height:700px; border:1px solid #000; } &lt;/style&gt; &lt;script&gt; require([&quot;esri/map&quot;,&quot;esri/layers/ArcGISImageServiceLayer&quot;,&quot;dojo/on&quot;, &quot;dojo/dom&quot;,&quot;esri/toolbars/draw&quot;, &quot;esri/tasks/ImageServiceIdentifyTask&quot;,&quot;esri/tasks/ImageServiceIdentifyParameters&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;,&quot;esri/graphic&quot;,&quot;esri/symbols/SimpleMarkerSymbol&quot;, &quot;esri/symbols/SimpleFillSymbol&quot;, &quot;esri/layers/MosaicRule&quot;, &quot;dojo/domReady!&quot;],function(Map,ArcGISImageServiceLayer,on,dom,Draw,ImageServiceIdentifyTask, ImageServiceIdentifyParameters,SimpleLineSymbol, Graphic,SimpleMarkerSymbol,SimpleFillSymbol,MosaicRule){ var map=new Map(&quot;mapDiv&quot;) //注意这里是影像服务 var layer=new ArcGISImageServiceLayer(&quot;http://localhost:6080/arcgis/rest/services/demo/ImageService_qingdao/ImageServer&quot;) map.addLayer(layer); //用于绘制点 var toolbar =new Draw(map); //创建影像分析对象 var task=new ImageServiceIdentifyTask(&quot;http://localhost:6080/arcgis/rest/services/demo/ImageService_qingdao/ImageServer&quot;); //创建影像分析参数对象 var params=new ImageServiceIdentifyParameters(); var lineSymbol = new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new dojo.Color([255, 0, 0]), 3); var marker= new SimpleMarkerSymbol(SimpleMarkerSymbol.STYLE_CIRCLE,10, lineSymbol, new dojo.Color([255, 0, 0])); var fill= new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol, new dojo.Color([255, 0, 0])); //给绘制折线按钮绑定事件 on(dom.byId(&quot;drawp&quot;),&quot;click&quot;,function(){ toolbar.activate(Draw.POINT, { showTooltips:true }) }) //给draw工具的绘制完成事件绑定函数 on(toolbar,&quot;draw-complete&quot;, function (result) { map.graphics.clear(); var geometry=result.geometry; //给参数对象的几何属性赋值 params.geometry =geometry; graphic= new Graphic(geometry, marker); map.graphics.add(graphic); toolbar.deactivate(); }) on(dom.byId(&quot;btn&quot;),&quot;click&quot;,function(){ //设置掩膜规则 var mosaicRule=new MosaicRule(); mosaicRule.ascending=false; mosaicRule.method=MosaicRule.METHOD_CENTER params.mosaicRule=mosaicRule params.pixelSizeX=layer.pixelSizeX; params.pixelSizeY=layer.pixelSizeY; task.execute(params,function(result){ //弹出改点的高程值 alert(result.value) }) }) }); &lt;/script&gt; 绘制点 查询","tags":[]},{"title":"分析---网络分析","date":"2019-10-23T08:17:29.423Z","path":"2019/10/23/分析---网络分析/","text":"1.效果图分析经过停靠点，避开障碍点之间的最优路径 2.发布服务在ArcMap中进行网络分析制图后需要发布地图服务才可以被调用。 为了以后方便，全选择 打开工具条，进行新建路径等，结束制图后进行服务发布 发布服务时，需要增加Network Analysis功能 成功发布之后进入http://localhost:6080/arcgis/rest/services找到存放目录这样说明服务发布成功了 选择(NAServer)后缀的链接，复制URL 创建路径分析对象的时候参数为URL+/Route 2.引入模块&quot;esri/tasks/RouteTask&quot;, &quot;esri/tasks/FeatureSet&quot;, 3.分析 分析需要不为0的停靠点和障碍点，所以先写添加点的方法， 为分析按钮添加事件，执行分析函数 得到路径分析结果，显示在图层上 需要注意健壮性的检验，即特殊情况的特判 4. 贴代码&lt;!DOCTYPE html&gt; &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt; &lt;title&gt;Geometric _Network&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/esri/css/esri.css&quot; /&gt; &lt;script src=&quot;https://js.arcgis.com/3.28/&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .MapClass{ width:100%; height:600px; border:1px solid #000; } &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; require([&quot;esri/map&quot;, &quot;dojo/on&quot;, &quot;dojo/dom&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;esri/tasks/RouteTask&quot;, &quot;esri/tasks/FeatureSet&quot;, &quot;esri/symbols/SimpleMarkerSymbol&quot;, &quot;esri/symbols/TextSymbol&quot;, &quot;esri/toolbars/draw&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;, &quot;esri/tasks/RouteParameters&quot;, &quot;dojo/colors&quot;, &quot;esri/graphic&quot;, &quot;dojo/domReady!&quot;], function (Map,on,dom, ArcGISDynamicMapServiceLayer, RouteTask, FeatureSet, SimpleMarkerSymbol, TextSymbol, Draw, SimpleLineSymbol, RouteParameters, Color, Graphic ) { var map = new Map(&quot;MyMapDiv&quot;); var layer = new ArcGISDynamicMapServiceLayer (&quot;http://localhost:6080/arcgis/rest/services/demo/WLFX_huanbao/MapServer&quot;); map.addLayer(layer) //创建路径分析对象 var shortestAnalyst = new RouteTask(&quot;http://localhost:6080/arcgis/rest/services/demo/WLFX_huanbao/NAServer/Route&quot;); //创建路径参数对象 var routeParas = new RouteParameters(); //障碍点，但是此时障碍点为空 routeParas.barriers = new FeatureSet(); //停靠点，但是此时停靠点为空 routeParas.stops = new FeatureSet(); //路径是否有方向 routeParas.returnDirections = false; //是否返回路径，此处必须返回 routeParas.returnRoutes = true; //空间参考 routeParas.outSpatialReference = map.SpatialReference; //定义一个标志 //selectPointID=0什么都不做 //selectPointID=1说明是添加停靠点 //selectPointID=2说明是添加障碍点 var selectPointID; //给停靠点按钮添加点击事件 on(dom.byId(&quot;stop&quot;),&quot;click&quot;,function(){ selectPointID = 1; }) //给障碍点按钮添加点击事件 on(dom.byId(&quot;barriers&quot;),&quot;click&quot;,function(){ selectPointID = 2; }) //定义停靠点的符号 var stopSymbol = new SimpleMarkerSymbol(); stopSymbol.style = SimpleMarkerSymbol.STYLE_CIRCLE; stopSymbol.setSize(8); stopSymbol.setColor(new Color(&quot;#FFFFCC&quot;)); //定义障碍点的符号 var barrierSymbol = new SimpleMarkerSymbol(); barrierSymbol.style = SimpleMarkerSymbol.STYLE_CIRCLE; barrierSymbol.setSize(8); barrierSymbol.setColor(new Color(&quot;#f1a340&quot;)); on(map, &quot;mouse-down&quot;, function(evt){ //通过selectPointID判断是添加是停靠点还是障碍点 switch (selectPointID) { case 0: break; case 1: //获得停靠点的坐标 var pointStop=evt.mapPoint; var gr=new Graphic(pointStop,stopSymbol); //构建停靠点的参数 routeParas.stops.features.push(gr); break; case 2: //获得障碍点的坐标 var pointBarrier=evt.mapPoint; var gr=new Graphic(pointBarrier,barrierSymbol); //构建障碍点的参数 routeParas.barriers.features.push(gr); break; } //如果selectPointID不等于0，将点的坐标在地图上显示出来 if (selectPointID != 0) { addTextPoint(&quot;停靠点&quot;, pointStop, stopSymbol); addTextPoint(&quot;障碍点&quot;, pointBarrier, barrierSymbol); selectPointID = 0; } }); //文本符号：文本信息，点坐标，符号 function addTextPoint(text,point,symbol) { var textSymbol = new TextSymbol(text); textSymbol.setColor(new Color([128, 0, 0])); var graphicText = Graphic(point, textSymbol); var graphicpoint = new Graphic(point, symbol); //用默认的图层添加 map.graphics.add(graphicpoint); map.graphics.add(graphicText); } //给分析按钮添加点击事件 on(dom.byId(&quot;analyse&quot;),&quot;click&quot;,function(){ //如果障碍点或者停靠点的个数有一个为0，提示用户参数输入不对 if (routeParas.stops.features.length == 0 || routeParas.barriers.features.length==0) { alert(&quot;输入参数不全，无法分析&quot;); return; } //执行路径分析函数 shortestAnalyst.solve(routeParas, showRoute) }) //处理路径分析返回的结果。 function showRoute(solveResult) { //路径分析的结果 var routeResults = solveResult.routeResults; //路径分析的长度 var res = routeResults.length; //路径的符号 routeSymbol = new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new Color([255, 0, 0]), 3); if (res &gt; 0) { for (var i = 0; i &lt; res; i++) { var graphicroute = routeResults[i]; var graphic = graphicroute.route; graphic.setSymbol(routeSymbol); map.graphics.add(graphic); } } else { alert(&quot;没有返回结果&quot;); } } }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;MyMapDiv&quot; class=&quot;MapClass&quot;&gt;&lt;/div&gt; &lt;input id=&quot;stop&quot; type=&quot;button&quot; value=&quot;停靠点&quot; /&gt; &lt;input id=&quot;barriers&quot; type=&quot;button&quot; value=&quot;障碍点&quot; /&gt; &lt;input id=&quot;analyse&quot; type=&quot;button&quot; value=&quot;分析&quot; /&gt; &lt;/body&gt; &lt;/html&gt;","tags":[]},{"title":"动态地图加载api 4.x","date":"2019-10-23T08:17:29.421Z","path":"2019/10/23/动态地图加载api 4.x/","text":"感觉3和4还是有较大改变的。从esri官方例子上看来，4的功能更加丰富，在大数据的展示和操作上体验比3要好。 4.12为例1. 不同 API调用 //API 3.x ： &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/esri/css/esri.css&quot;/&gt; &lt;script src=&quot;https://js.arcgis.com/3.28/&quot;&gt; //API 4.x ： &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/4.12/esri/css/main.css&quot;&gt; &lt;script src=&quot;https://js.arcgis.com/4.12/&quot;&gt; 动态图层的引用模块 //API 3.x ： &quot;esri/map&quot;, “esri/layers/ArcGISDynamicMapServiceLayer”， //API 4.x ： &quot;esri/Map&quot;, “esri/views/MapView” “map”改为了”Map” 显而易见从layers目录下到，到了views下，说明，地图需要放置在views中，既然多了一层，那这个views层必然是为我们封装了很多的方法和接口。 创建Map对象不在需要绑定id //API 3.x ： var map = new Map(&quot;mapDiv&quot;); //API 4.x ： var map = new Map(); 图层的创建 var layer = new MapImageLayer({ url:&quot;http://192.168.3.1:6080/arcgis/rest/services/gaofen/xianghe/MapServer&quot;, sublayers: [{id: 0,visible:true}] }); 一般为两个参数，url 和 sublayers url 为 REST URL sublayers 设置图层可见性 比3更加方便 创建MapView，需要选择容器中的 map 和绑定的 DIV 的 id new MapView({ map: map, container: &quot;viewDiv&quot; }); 2. api 3.x 代码3. api 4.x 代码&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/4.12/esri/css/main.css&quot;&gt; &lt;script src=&quot;https://js.arcgis.com/4.12/&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; require([&quot;esri/Map&quot;, &quot;esri/layers/MapImageLayer&quot;, &quot;esri/views/MapView&quot;, &quot;dojo/domReady!&quot;], function (Map, MapImageLayer, MapView) { var map = new Map(); var layer = new MapImageLayer({ url:&quot;http://192.168.3.1:6080/arcgis/rest/services/gaofen/xianghe/MapServer&quot;, }); map.add(layer); new MapView({ map: map, container: &quot;viewDiv&quot; }); }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;viewDiv&quot; style=&quot;height:800px;&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt;","tags":[]},{"title":"查询---查询+echarts交互","date":"2019-10-23T08:17:29.419Z","path":"2019/10/23/查询---查询+echarts交互/","text":"1.效果图PS:表格数据只有第一列为真实获取，剩余为写死的数据。查询的结果是一个地区的不同属性。Echarts要展示的为不同地区的同一属性，为方便测试功能，就没有重新制图。 2.注意加载模块时，只能有一种采用配置路径加载。 为什么呢？例如，ArcJS的模块加载路径是在https://js.arcgis.com/3.28/，如果echarts也采用这种方法加载模块，那么便会出现这种情况，例如加载echarts.min.js包，在浏览器开发者模式下NetWork中的该资源的下载路径是https://js.arcgis.com/3.28/echarts.min.js显然这个路径下是下载不到这个包的，就会报错，显示echarts.min.js文件下载出错。 解决：任一个的包部署在本地之后，本地加载。注意加载的顺序，先加载echarts在加载ArcJS。**因为Echarts的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边 3. 贴代码&lt;!DOCTYPE html&gt; &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;title&gt;QueryTask&lt;/title&gt; &lt;script src=&quot;../echarts.min.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/esri/css/esri.css&quot; /&gt; &lt;script type=&quot;text/Javascript&quot; src=&quot;https://js.arcgis.com/3.28/&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://code.jquery.com/jquery-1.12.4.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .MapClass { width: 100%; height: 520px; /* border:1px solid #000; */ } &lt;/style&gt; &lt;script&gt; var beijing0 = &quot;http://localhost:6080/arcgis/rest/services/ecology/beijing_2012_3/MapServer/0&quot;; var GL_pt_NL_NAME_3; var GL_pt_area_td; require([&quot;esri/map&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;dojo/dom&quot;, &quot;dojo/on&quot;, &quot;dojo/query&quot;, &quot;esri/tasks/QueryTask&quot;, &quot;esri/tasks/query&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;, &quot;esri/Color&quot;, &quot;dojo/domReady!&quot;], function (Map, ArcGISDynamicMapServiceLayer, dom, on, query, QueryTask, Query, SimpleLineSymbol, Color) { var map = new Map(&quot;mapDiv&quot;); var layer = new ArcGISDynamicMapServiceLayer(&quot;http://localhost:6080/arcgis/rest/services/ecology/beijing_2012_3/MapServer&quot;); map.addLayer(layer) //给属性查询按钮添加click事件 on(dom.byId(&quot;Btn_sx&quot;), &quot;click&quot;, function (e) { // var text = document.getElementById(&quot;te&quot;).value; var text = $(&quot;#te&quot;).val(); //定义查询对象 var queryTask = new QueryTask(beijing0); //定义查询参数对象 var query = new Query(); //查询条件，类似于sql语句的where子句 query.where = &quot;FID = &quot; + text; //返回的字段信息：*代表返回全部字段 query.outFields = [&quot;*&quot;]; //是否返回几何形状 query.returnGeometry = true; //执行属性查询 var a = queryTask.execute(query, showQueryResult); // alert(re()); }) //属性查询完成之后，用showQueryResult来处理返回的结果 function showQueryResult(queryResult) { if (queryResult.features.length &gt;= 1) { for (var i = 0; i &lt; queryResult.features.length; i++) { var graphic = queryResult.features[i]; var pt_NL_NAME_3 = graphic.attributes[&quot;NL_NAME_3&quot;]; var pt_area_td = graphic.attributes[&quot;土地面积&quot;]; GL_pt_NL_NAME_3 = pt_NL_NAME_3; GL_pt_area_td = pt_area_td; } } var x = document.getElementById(&quot;main&quot;); var myChart = echarts.init(x); var option = { tooltip: { show: true }, legend: { data: [&apos;123&apos;] }, xAxis: [{ type: &apos;category&apos;, data: [GL_pt_NL_NAME_3, &quot;朝阳区&quot;, &quot;大厂区&quot;] }], yAxis: [{ type: &apos;value&apos; }], series: [{ &quot;name&quot;: &quot;销量&quot;, &quot;type&quot;: &quot;bar&quot;, &quot;data&quot;: [pt_area_td, 1500, 1000] }] }; myChart.setOption(option); } }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;text&quot; value=&quot;在此处输入需要查询的XX&quot; id=&quot;te&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;属性查询&quot; id=&quot;Btn_sx&quot; /&gt; &lt;div id=&quot;mapDiv&quot; class=&quot;MapClass&quot;&gt;&lt;/div&gt; &lt;div id=&quot;main&quot; style=&quot;height:400px;&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt;","tags":[]},{"title":"查询---QueryTask属性查询","date":"2019-10-23T08:17:29.418Z","path":"2019/10/23/查询---QueryTask属性查询/","text":"1. 效果图查询FID为2的区域 2. FindTask和QueryTask属性查询中的不同 引入模块 FindTask：&quot;esri/tasks/FindTask&quot;,&quot;esri/tasks/FindParameters&quot;,QueryTask：&quot;esri/tasks/QueryTask&quot;,&quot;esri/tasks/query&quot;, 定义查询对象 FindTask： //动态图层 var findTask = new FindTask(http://localhost:6080/arcgis/rest/services/ecology/beijing_2012_3/MapServer); **QueryTask：** //要素图层 var queryTask = new QueryTask(&quot;http://localhost:6080/arcgis/rest/services/ecology/beijing_2012_3/MapServer/0&quot;); 查询条件 FindTask： //查询字段 findParams.searchFields=findParams.searchText findParams.searchFields = [&quot;FID&quot;]; findParams.searchText = &quot;2&quot;; **QueryTask：** //查询条件，类似于sql语句的where子句 query.where = &quot;FID = 2&quot;; //返回的字段信息：*代表返回全部字段 query.outFields = [&quot;*&quot;]; 显示 FindTask 中的 queryResult == QueryTask 中的 queryResult.features[i]; 3. 贴代码&lt;!DOCTYPE html&gt; &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt; &lt;title&gt;QueryTask&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/esri/css/esri.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/dijit/themes/tundra/tundra.css&quot;/&gt; &lt;script type=&quot;text/Javascript&quot; src=&quot;https://js.arcgis.com/3.28/&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .MapClass{ width:100%; height:800px; border:1px solid #000; } &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; require([&quot;esri/map&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;dojo/dom&quot;, &quot;dojo/on&quot;, &quot;esri/tasks/QueryTask&quot;, &quot;esri/tasks/query&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;, &quot;esri/symbols/SimpleFillSymbol&quot;, &quot;esri/graphic&quot;, &quot;dojo/domReady!&quot;], function (Map, ArcGISDynamicMapServiceLayer,dom, on, QueryTask, Query, SimpleLineSymbol,SimpleFillSymbol,Graphic) { //根据div的id属性创建地图 var map = new Map(&quot;mapDiv&quot;); //定义一个动态地图服务 var layer = new ArcGISDynamicMapServiceLayer (&quot;http://localhost:6080/arcgis/rest/services/ecology/beijing_2012_3/MapServer&quot;); //将图层添加到地图 map.addLayer(layer) //给属性查询按钮添加click事件 on(dom.byId(&quot;Btn&quot;),&quot;click&quot;,function(e){ //定义查询对象，查询参数 var queryTask = new QueryTask (&quot;http://localhost:6080/arcgis/rest/services/ecology/beijing_2012_3/MapServer/0&quot;); var query = new Query(); //是否返回几何形状 query.returnGeometry = true; //查询条件，类似于sql语句的where子句 query.where = &quot;FID = 2&quot;; //返回的字段信息：*代表返回全部字段 query.outFields = [&quot;*&quot;]; //执行属性查询 queryTask.execute(query, showQueryResult); }) //属性查询完成之后，用showQueryResult来处理返回的结果 function showQueryResult(queryResult) { //创建线符号 var lineSymbol=new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new dojo.Color([255, 0, 0]), 3); //创建面符号 var fill=new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol); if (queryResult.features.length == 0) { dom.byId(&quot;divShowResult&quot;).innerHTML = &quot;&quot;; return; } var htmls = &quot;&quot;; if (queryResult.features.length &gt;= 1) { htmls = htmls + &quot;&lt;table style=\\&quot;width: 100%\\&quot;&gt;&quot;; htmls = htmls + &quot;&lt;tr&gt;&lt;td&gt;名称&lt;/td&gt;&lt;/tr&gt;&quot;; for (var i = 0; i &lt; queryResult.features.length; i++) { //获得图形graphic var graphic = queryResult.features[i]; //赋予相应的符号 graphic.setSymbol(fill); //将graphic添加到地图中，从而实现高亮效果 map.graphics.add(graphic); //获得neirong var ptName = graphic.attributes[&quot;NL_NAME_3&quot;]; if (i % 2 == 0) htmls = htmls + &quot;&lt;tr&gt;&quot;; else htmls = htmls + &quot;&lt;tr bgcolor=\\&quot;#F0F0F0\\&quot;&gt;&quot;; htmls = htmls + &quot;&lt;td&gt;&lt;a href=\\&quot;#\\&quot; \\&quot;&gt;&quot; + ptName + &quot;&lt;/a&gt;&lt;/td&gt;&quot;; htmls = htmls + &quot;&lt;/tr&gt;&quot;; } htmls = htmls + &quot;&lt;/table&gt;&quot;; //将属性绑定在divShowResult上面 dom.byId(&quot;divShowResult&quot;).innerHTML = htmls; } } }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;mapDiv&quot; class=&quot;MapClass&quot;&gt;&lt;/div&gt; &lt;input type=&quot;button&quot; value=&quot;属性查询&quot; id=&quot;Btn&quot;/&gt; &lt;div id=&quot;divShowResult&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt;4. 拓展（JS基础） 改为选择查询参数，输入查询关键字，点击查询","tags":[]},{"title":"查询---QueryTask空间查询","date":"2019-10-23T08:17:29.417Z","path":"2019/10/23/查询---QueryTask空间查询/","text":"1. 效果图 2. QueryTask属性查询和空间查询的不同 引入模块不同空间查询多了&quot;esri/toolbars/draw&quot;,模块 条件格式 //定义一个绘图工具 var toolBar = new Draw(map); //给button绑定事件 on(dom.byId(&quot;Btn&quot;),&quot;click&quot;,function(){ //激活绘图工具，我要绘制一个面图形 toolBar.activate(Draw.POLYGON); }) on(toolBar, &quot;draw-complete&quot;, function (result) { //获得绘图得到的面 var geometry=result.geometry; //关闭绘图工具 toolBar.deactivate(); queryGraphic(geometry); }); 查询条件 属性查询 //查询条件，类似于sql语句的where子句 query.where = &quot;FID = 2&quot;; **空间查询** //空间查询的几何对象 query.geometry = geometry;3. 贴代码&lt;!DOCTYPE html&gt; &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt; &lt;title&gt;QueryTask&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/esri/css/esri.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/dijit/themes/tundra/tundra.css&quot;/&gt; &lt;script type=&quot;text/Javascript&quot; src=&quot;https://js.arcgis.com/3.28/&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .MapClass{ width:100%; height:800px; border:1px solid #000; } &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; require([&quot;esri/map&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;dojo/dom&quot;, &quot;dojo/on&quot;, &quot;esri/tasks/QueryTask&quot;, &quot;esri/toolbars/draw&quot;, &quot;esri/tasks/query&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;, &quot;esri/symbols/SimpleFillSymbol&quot;, &quot;esri/graphic&quot;, &quot;dojo/domReady!&quot;], function (Map, ArcGISDynamicMapServiceLayer,dom, on, QueryTask, Draw, Query, SimpleLineSymbol,SimpleFillSymbol,Graphic) { var map = new Map(&quot;mapdiv&quot;); var layer = new ArcGISDynamicMapServiceLayer (&quot;http://localhost:6080/arcgis/rest/services/ecology/beijing_2012_3/MapServer&quot;); map.addLayer(layer) //定义一个绘图工具 var toolBar = new Draw(map); //给button绑定事件 on(dom.byId(&quot;Btn&quot;),&quot;click&quot;,function(){ //激活绘图工具，我要绘制一个面图形 toolBar.activate(Draw.POLYGON); }) on(toolBar, &quot;draw-complete&quot;, function (result) { //获得绘图得到的面 var geometry=result.geometry; //关闭绘图工具 toolBar.deactivate(); queryGraphic(geometry); }); function queryGraphic(geometry) { //创建查询对象 var queryTask = new QueryTask( &quot;http://localhost:6080/arcgis/rest/services/ecology/beijing_2012_3/MapServer/0&quot;); //创建查询参数对象 var query = new Query(); //是否返回几何形状 query.returnGeometry = true; //空间查询的几何对象 query.geometry = geometry; //服务器给我们返回的字段信息，*代表返回所有字段 query.outFields = [&quot;*&quot;]; //空间参考信息 query.outSpatialReference = map.spatialReference; //查询的标准，此处代表和geometry相交的图形都要返回 query.spatialRelationship = Query.SPATIAL_REL_INTERSECTS; //执行空间查询 queryTask.execute(query, showQueryResult); } function showQueryResult(queryResult) { //创建线符号 var lineSymbol=new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new dojo.Color([255, 0, 0]), 3); //创建面符号 var fill=new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol); if (queryResult.features.length == 0) { dom.byId(&quot;divShowResult&quot;).innerHTML = &quot;&quot;; return; } var htmls = &quot;&quot;; if (queryResult.features.length &gt;= 1) { htmls = htmls + &quot;&lt;table style=\\&quot;width: 100%\\&quot;&gt;&quot;; htmls = htmls + &quot;&lt;tr&gt;&lt;td&gt;名称&lt;/td&gt;&lt;/tr&gt;&quot;; for (var i = 0; i &lt; queryResult.features.length; i++) { //得到graphic var graphic = queryResult.features[i]; //给图形赋予符号 graphic.setSymbol(fill); //添加到地图从而实现高亮效果 map.graphics.add(graphic); ////获得内容，对应属性表 var ptName = graphic.attributes[&quot;NL_NAME_3&quot;]; if (i % 2 == 0) htmls = htmls + &quot;&lt;tr&gt;&quot;; else htmls = htmls + &quot;&lt;tr bgcolor=\\&quot;#F0F0F0\\&quot;&gt;&quot;; htmls = htmls + &quot;&lt;td&gt;&lt;a href=\\&quot;#\\&quot;\\&quot;&gt;&quot; + ptName + &quot;&lt;/a&gt;&lt;/td&gt;&quot;; htmls = htmls + &quot;&lt;/tr&gt;&quot;; } htmls = htmls + &quot;&lt;/table&gt;&quot;; //将教学楼的名称信息和divShowResult绑定 dom.byId(&quot;divShowResult&quot;).innerHTML = htmls; } } }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;mapdiv&quot; class=&quot;MapClass&quot;&gt;&lt;/div&gt; &lt;input type=&quot;button&quot; value=&quot;空间查询&quot; id=&quot;Btn&quot;/&gt; &lt;div id=&quot;divShowResult&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt;","tags":[]},{"title":"查询---QueryTask空间+属性查询","date":"2019-10-23T08:17:29.415Z","path":"2019/10/23/查询---QueryTask空间+属性查询/","text":"1.效果图将上面两片结合起来就OK，代码容易，但是高亮过的图层怎么消除？（扩展） 2. 贴代码&lt;!DOCTYPE html&gt; &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt; &lt;title&gt;QueryTask&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/esri/css/esri.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/dijit/themes/tundra/tundra.css&quot;/&gt; &lt;script type=&quot;text/Javascript&quot; src=&quot;https://js.arcgis.com/3.28/&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .MapClass{ width:100%; height:800px; border:1px solid #000; } &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; require([&quot;esri/map&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;dojo/dom&quot;, &quot;dojo/on&quot;, &quot;esri/tasks/QueryTask&quot;, &quot;esri/toolbars/draw&quot;, &quot;esri/tasks/query&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;, &quot;esri/symbols/SimpleFillSymbol&quot;, &quot;esri/graphic&quot;, &quot;dojo/domReady!&quot;], function (Map, ArcGISDynamicMapServiceLayer,dom, on, QueryTask, Draw, Query, SimpleLineSymbol,SimpleFillSymbol,Graphic) { var map = new Map(&quot;mapDiv&quot;); var layer = new ArcGISDynamicMapServiceLayer (&quot;http://localhost:6080/arcgis/rest/services/ecology/beijing_2012_3/MapServer&quot;); //将图层添加到地图 map.addLayer(layer) //给属性查询按钮添加click事件 on(dom.byId(&quot;Btn_sx&quot;),&quot;click&quot;,function(e){ var queryTask = new QueryTask (&quot;http://localhost:6080/arcgis/rest/services/ecology/beijing_2012_3/MapServer/0&quot;); var query = new Query(); query.where = &quot;FID = 2&quot;; query.outFields = [&quot;*&quot;]; query.returnGeometry = true; queryTask.execute(query, showQueryResult); }) var toolBar = new Draw(map); on(dom.byId(&quot;Btn_kj&quot;),&quot;click&quot;,function(){ toolBar.activate(Draw.POLYGON); }) on(toolBar, &quot;draw-complete&quot;, function (result) { var geometry=result.geometry; toolBar.deactivate(); queryGraphic(geometry); }); function queryGraphic(geometry) { var queryTask = new QueryTask( &quot;http://localhost:6080/arcgis/rest/services/ecology/beijing_2012_3/MapServer/0&quot;); var query = new Query(); query.geometry = geometry; query.outFields = [&quot;*&quot;]; query.returnGeometry = true; queryTask.execute(query, showQueryResult); } function showQueryResult(queryResult) { var lineSymbol=new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new dojo.Color([255, 0, 0]), 3); var fill=new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol); if (queryResult.features.length == 0) { dom.byId(&quot;divShowResult&quot;).innerHTML = &quot;&quot;; return; } var htmls = &quot;&quot;; if (queryResult.features.length &gt;= 1) { htmls = htmls + &quot;&lt;table style=\\&quot;width: 100%\\&quot;&gt;&quot;; htmls = htmls + &quot;&lt;tr&gt;&lt;td&gt;名称&lt;/td&gt;&lt;/tr&gt;&quot;; for (var i = 0; i &lt; queryResult.features.length; i++) { var graphic = queryResult.features[i]; graphic.setSymbol(fill); map.graphics.add(graphic); var ptName = graphic.attributes[&quot;NL_NAME_3&quot;]; if (i % 2 == 0) htmls = htmls + &quot;&lt;tr&gt;&quot;; else htmls = htmls + &quot;&lt;tr bgcolor=\\&quot;#F0F0F0\\&quot;&gt;&quot;; htmls = htmls + &quot;&lt;td&gt;&lt;a href=\\&quot;#\\&quot; \\&quot;&gt;&quot; + ptName + &quot;&lt;/a&gt;&lt;/td&gt;&quot;; htmls = htmls + &quot;&lt;/tr&gt;&quot;; } htmls = htmls + &quot;&lt;/table&gt;&quot;; dom.byId(&quot;divShowResult&quot;).innerHTML = htmls; } } }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;mapDiv&quot; class=&quot;MapClass&quot;&gt;&lt;/div&gt; &lt;input type=&quot;button&quot; value=&quot;属性查询&quot; id=&quot;Btn_sx&quot;/&gt; &lt;input type=&quot;button&quot; value=&quot;空间查询&quot; id=&quot;Btn_kj&quot;/&gt; &lt;div id=&quot;divShowResult&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt;","tags":[]},{"title":"查询---GraphicsLayer的属性查询","date":"2019-10-23T08:17:29.413Z","path":"2019/10/23/查询---GraphicsLayer的属性查询/","text":"这个查询方法，学习过还没有在开发中真正的使用过。感觉没有上述的三种好用。例子： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Graphic&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/esri/css/esri.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/dijit/themes/tundra/tundra.css&quot;/&gt; &lt;script type=&quot;text/Javascript&quot; src=&quot;https://js.arcgis.com/3.28/&quot;&gt;&lt;/script&gt; &lt;style&gt; .MapClass{ width:100%; height:800px; border:1px solid #000; } &lt;/style&gt; &lt;script&gt; require([&quot;esri/map&quot;,&quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;esri/layers/GraphicsLayer&quot;, &quot;dojo/on&quot;,&quot;dojo/query&quot;,&quot;dojo/colors&quot;, &quot;esri/graphic&quot;,&quot;esri/symbols/SimpleMarkerSymbol&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;, &quot;esri/geometry/Point&quot;, &quot;dojo/domReady!&quot;], function(Map,ArcGISDynamicMapServiceLayer, GraphicsLayer,on,query,Color,Graphic, SimpleMarkerSymbol,SimpleLineSymbol,Point){ var map = new Map(&quot;mapDiv&quot;); var layer = new ArcGISDynamicMapServiceLayer (&quot;http://localhost:6080/arcgis/rest/services/ecology/beijing_2012_3/MapServer&quot;); map.addLayer(layer); //创建客户端图层 var graphicsLayer=new GraphicsLayer(); //将客户端图层添加到地图中 map.addLayer(graphicsLayer); //添加点图形的函数 function addGraphic() { var lineSymbol=new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new Color([255, 0, 0]), 3); var pSymbol=new SimpleMarkerSymbol(SimpleMarkerSymbol.STYLE_CIRCLE,10, lineSymbol, new Color([255, 0, 0])); var geometry; var graphic; //添加第一个点 geometry=new Point({ &quot;x&quot;:510706, &quot;y&quot;:3986100, &quot;spatialReference&quot;:map.spatialReference, attributes:{ &quot;h&quot;:100, } }); graphic=new Graphic(geometry,pSymbol); graphicsLayer.add(graphic); //添加第二个点图形 geometry=new Point({ &quot;x&quot;:510326, &quot;y&quot;:3985702, &quot;spatialReference&quot;:map.spatialReference, attributes:{ &quot;h&quot;:200, } }); graphic=new Graphic(geometry,pSymbol); graphicsLayer.add(graphic); //添加第三个点 geometry=new Point({ &quot;x&quot;:510275, &quot;y&quot;:3986100, &quot;spatialReference&quot;:map.spatialReference, attributes:{ &quot;h&quot;:300, } }); graphic=new Graphic(geometry,pSymbol); graphicsLayer.add(graphic); } addGraphic(); //绑定事件 on(graphicsLayer,&quot;click&quot;,function(event){ var graphic=event.graphic; alert(graphic.attributes[&quot;h&quot;]); }) }) &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;mapDiv&quot; class=&quot;MapClass&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt;","tags":[]},{"title":"String类","date":"2019-10-23T08:17:29.410Z","path":"2019/10/23/String类/","text":"(Scanner的概述和方法介绍)(掌握) A:Scanner的概述 B:Scanner的构造方法原理 Scanner(InputStream source) System类下有一个静态的字段： public static final InputStream in; 标准的输入流，对应着键盘录入。 C:一般方法 hasNextXxx() 判断是否还有下一个输入项,其中Xxx可以是Int,Double等。如果需要判断是否包含下一个字符串，则可以省略Xxx nextXxx() 获取下一个输入项。Xxx的含义和上个方法中的Xxx相同,默认情况下，Scanner使用空格，回车等作为分隔符 (Scanner获取数据出现的小问题及解决方案)(掌握) A:两个常用的方法： public int nextInt():获取一个int类型的值 public String nextLine():获取一个String类型的值 B:案例演示 a:先演示获取多个int值，多个String值的情况 b:再演示先获取int值，然后获取String值出现问题 c:问题解决方案 第一种：先获取一个数值后，在创建一个新的键盘录入对象获取字符串。 第二种：把所有的数据都先按照字符串获取，然后要什么，你就对应的转换为什么。(后面讲) (String类的概述)(掌握) A:String类的概述 通过JDK提供的API，查看String类的说明 可以看到这样的两句话。 a:字符串字面值”abc”也可以看成是一个字符串对象。 b:字符串是常量，一旦被赋值，就不能被改变。 (String类的构造方法)(掌握) A:常见构造方法 public String():空构造 public String(byte[] bytes):把字节数组转成字符串 public String(byte[] bytes,int index,int length):把字节数组的一部分转成字符串 public String(char[] value):把字符数组转成字符串 public String(char[] value,int index,int count):把字符数组的一部分转成字符串 public String(String original):把字符串常量值转成字符串 B:案例演示 演示String类的常见构造方法 (String类的常见面试题)(掌握) 1.判断定义为String类型的s1和s2是否相等 String s1 = “abc”; String s2 = “abc”; System.out.println(s1 == s2); System.out.println(s1.equals(s2)); 2.下面这句话在内存中创建了几个对象? String s1 = new String(“abc”); 3.判断定义为String类型的s1和s2是否相等 String s1 = new String(“abc”); String s2 = “abc”; System.out.println(s1 == s2); System.out.println(s1.equals(s2)); 4.判断定义为String类型的s1和s2是否相等 String s1 = “a” + “b” + “c”; String s2 = “abc”; System.out.println(s1 == s2); System.out.println(s1.equals(s2)); 5.判断定义为String类型的s1和s2是否相等 String s1 = “ab”; String s2 = “abc”; String s3 = s1 + “c”; System.out.println(s3 == s2); System.out.println(s3.equals(s2)); (String类的判断功能)(掌握) A:String类的判断功能 boolean equals(Object obj):比较字符串的内容是否相同,区分大小写 boolean equalsIgnoreCase(String str):比较字符串的内容是否相同,忽略大小写 boolean contains(String str):判断大字符串中是否包含小字符串 boolean startsWith(String str):判断字符串是否以某个指定的字符串开头 boolean endsWith(String str):判断字符串是否以某个指定的字符串结尾 boolean isEmpty():判断字符串是否为空。 (模拟用户登录)(掌握) A:案例演示 需求：模拟登录,给三次机会,并提示还有几次。 用户名和密码都是admin (String类的获取功能)(掌握) A:String类的获取功能 int length():获取字符串的长度。 char charAt(int index):获取指定索引位置的字符 int indexOf(int ch):返回指定字符在此字符串中第一次出现处的索引。 int indexOf(String str):返回指定字符串在此字符串中第一次出现处的索引。 int indexOf(int ch,int fromIndex):返回指定字符在此字符串中从指定位置后第一次出现处的索引。 int indexOf(String str,int fromIndex):返回指定字符串在此字符串中从指定位置后第一次出现处的索引。 lastIndexOf String substring(int start):从指定位置开始截取字符串,默认到末尾。 String substring(int start,int end):从指定位置开始到指定位置结束截取字符串。 (字符串的遍历)(掌握) A:案例演示 需求：遍历字符串 (统计不同类型字符个数)(掌握) A:案例演示 需求：统计一个字符串中大写字母字符，小写字母字符，数字字符出现的次数,其他字符出现的次数。 ABCDEabcd123456!@#$%^ (String类的转换功能)(掌握) A:String的转换功能： byte[] getBytes():把字符串转换为字节数组。 char[] toCharArray():把字符串转换为字符数组。 static String valueOf(char[] chs):把字符数组转成字符串。 static String valueOf(int i):把int类型的数据转成字符串。 注意：String类的valueOf方法可以把任意类型的数据转成字符串 String toLowerCase():把字符串转成小写。(了解) String toUpperCase():把字符串转成大写。 String concat(String str):把字符串拼接。 (按要求转换字符)(链式编程掌握) A:案例演示 需求：把一个字符串的首字母转成大写，其余为小写。(只考虑英文大小写字母字符) (把数组转成字符串) A:案例演示 需求：把数组中的数据按照指定个格式拼接成一个字符串 举例： int[] arr = {1,2,3}; 输出结果： “[1, 2, 3]”(String类的其他功能) A:String的替换功能及案例演示 String replace(char old,char new) String replace(String old,String new) B:String的去除字符串两空格及案例演示 String trim() C:String的按字典顺序比较两个字符串及案例演示 int compareTo(String str)(暂时不用掌握) int compareToIgnoreCase(String str)(了解) (字符串反转) A:案例演示 需求：把字符串反转 举例：键盘录入”abc” 输出结果：”cba” (在大串中查找小串出现的次数思路图解) A:画图演示 需求：统计大串中小串出现的次数 这里的大串和小串可以自己根据情况给出 (在大串中查找小串出现的次数代码实现) A:案例演示 统计大串中小串出现的次数","tags":[]},{"title":"查询---FindTask属性查询","date":"2019-10-23T08:17:29.410Z","path":"2019/10/23/查询---FindTask属性查询/","text":"1. 效果图查询FID为2的区域 2. 引入模块//查询对象 &quot;esri/tasks/FindTask&quot;, //查询参数 &quot;esri/tasks/FindParameters&quot;, //线符号对象 &quot;esri/symbols/SimpleLineSymbol&quot;, //面符号对象 &quot;esri/symbols/SimpleFillSymbol&quot;, //图形对象 &quot;esri/graphic&quot;,3. 步骤 查询 显示 查询 创建属性查询对象、查询参数 var findTask = new FindTask(MapServer); var findParams = new FindParameters(); 绑定触发事件 on(dom.byId(&quot;Btn&quot;),&quot;click&quot;,function(){}) 返回几何信息 决定高亮等结果显示 findParams.returnGeometry = true; 查询图层 findParams.layerIds = [1]; 查询字段 findParams.searchFields=findParams.searchText findParams.searchFields = [&quot;FID&quot;]; findParams.searchText = &quot;2&quot;; 执行查询对象 //ShowFindResult是显示方法 findTask.execute(findParams, ShowFindResult);显示 创建线符号 var lineSymbol=new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new dojo.Color([255, 0, 0]), 3); 创建面符号 var fill=new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol); 如果查询结果等于0，结束。 if (queryResult.length == 0) { dom.byId(&quot;divShowResult&quot;).innerHTML = &quot;&quot;; return; } 查询结果大于等于1 if (queryResult.length &gt;= 1) {} 获得图形，设置符号，添加在地图中，高亮 //获得图形 var graphic = queryResult[i].feature; //设置符号 graphic.setSymbol(fill); //将graphic添加到地图中 //实现高亮 map.graphics.add(graphic); 获取对应属性表的内容，并修改显示div的html为获取到的内容 var ptName = graphic.attributes[&quot;FID&quot;]; if (i % 2 == 0) htmls = htmls + &quot;&lt;tr&gt;&quot;; else htmls = htmls + &quot;&lt;tr bgcolor=\\&quot;#F0F0F0\\&quot;&gt;&quot;; htmls = htmls + &quot;&lt;td&gt;&lt;a href=\\&quot;#\\&quot; \\&quot;&gt;&quot; + ptName + &quot;&lt;/a&gt;&lt;/td&gt;&quot;; htmls = htmls + &quot;&lt;/tr&gt;&quot;; dom.byId(&quot;divShowResult&quot;).innerHTML = htmls; 修改显示div的html dom.byId(&quot;divShowResult&quot;).innerHTML = htmls; 4.完整代码&lt;!DOCTYPE html&gt; &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt; &lt;title&gt;FindTask&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/esri/css/esri.css&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://js.arcgis.com/3.28/dijit/themes/tundra/tundra.css&quot;/&gt; &lt;script type=&quot;text/Javascript&quot; src=&quot;https://js.arcgis.com/3.28/&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; .MapClass{ width:100%; height:800px; border:1px solid #000; } &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; require([&quot;esri/map&quot;, &quot;esri/layers/ArcGISDynamicMapServiceLayer&quot;, &quot;dojo/on&quot;, &quot;dojo/dom&quot;, &quot;esri/tasks/FindTask&quot;, &quot;esri/tasks/FindParameters&quot;, &quot;esri/symbols/SimpleLineSymbol&quot;, &quot;esri/symbols/SimpleFillSymbol&quot;, &quot;esri/graphic&quot;, &quot;dojo/domReady!&quot;], function (Map, ArcGISDynamicMapServiceLayer,on,dom, FindTask, FindParameters, SimpleLineSymbol,SimpleFillSymbol,Graphic) { var map = new esri.Map(&quot;mapDiv&quot;); var MapServer = &quot;http://localhost:6080/arcgis/rest/services/ecology/beijing_2012_3/MapServer&quot;; var layer = new esri.layers.ArcGISDynamicMapServiceLayer(MapServer); map.addLayer(layer) //创建属性查询对象、查询参数 var findTask = new FindTask(MapServer); var findParams = new FindParameters(); //绑定触发事件 on(dom.byId(&quot;Btn&quot;),&quot;click&quot;,function(){ //是否返回几何信息 决定高亮等结果显示 findParams.returnGeometry = true; //查询图层 findParams.layerIds = [1]; //查询字段 findParams.searchFields=findParams.searchText findParams.searchFields = [&quot;FID&quot;]; findParams.searchText = &quot;2&quot;; //执行查询对象 findTask.execute(findParams, ShowFindResult); }) function ShowFindResult(queryResult) { //创建线符号 var lineSymbol=new SimpleLineSymbol(SimpleLineSymbol.STYLE_DASH, new dojo.Color([255, 0, 0]), 3); //创建面符号 var fill=new SimpleFillSymbol(SimpleFillSymbol.STYLE_SOLID, lineSymbol); if (queryResult.length == 0) { dom.byId(&quot;divShowResult&quot;).innerHTML = &quot;&quot;; return; } var htmls = &quot;&quot;; if (queryResult.length &gt;= 1) { htmls = htmls + &quot;&lt;table style=\\&quot;width: 100%\\&quot;&gt;&quot;; htmls = htmls + &quot;&lt;tr&gt;&lt;td&gt;名称&lt;/td&gt;&lt;/tr&gt;&quot;; for (var i = 0; i &lt; queryResult.length; i++) { //获得图形 var graphic = queryResult[i].feature; //赋予相应的符号 graphic.setSymbol(fill); //将graphic添加到地图中 //实现高亮 map.graphics.add(graphic); //获得内容 注意对应属性表 var ptName = graphic.attributes[&quot;FID&quot;]; if (i % 2 == 0) htmls = htmls + &quot;&lt;tr&gt;&quot;; else htmls = htmls + &quot;&lt;tr bgcolor=\\&quot;#F0F0F0\\&quot;&gt;&quot;; htmls = htmls + &quot;&lt;td&gt;&lt;a href=\\&quot;#\\&quot; \\&quot;&gt;&quot; + ptName + &quot;&lt;/a&gt;&lt;/td&gt;&quot;; htmls = htmls + &quot;&lt;/tr&gt;&quot;; } htmls = htmls + &quot;&lt;/table&gt;&quot;; //dom操作修改div的html dom.byId(&quot;divShowResult&quot;).innerHTML = htmls; } } }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;mapDiv&quot; class=&quot;MapClass&quot;&gt;&lt;/div&gt; &lt;input type=&quot;button&quot; value=&quot;属性查询&quot; id=&quot;Btn&quot;/&gt; &lt;div id=&quot;divShowResult&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt;5. 拓展（JS基础） 改为选择查询参数，输入查询关键字，点击查询","tags":[]},{"title":"Nodejs爬虫实战","date":"2019-10-23T08:17:29.408Z","path":"2019/10/23/Nodejs爬虫实战/","text":"Nodejs爬虫实战（一） Nodejs爬虫实战（二） Nodejs爬虫实战（三） Nodejs爬虫实战（四） Nodejs爬虫实战（五） Nodejs爬虫实战（六） Nodejs爬虫实战（七）数据可视化","tags":[]},{"title":"Nodejs爬虫实战（一）","date":"2019-10-23T08:17:29.406Z","path":"2019/10/23/Nodejs爬虫实战（一）/","text":"1. 搭建本地服务器 const为ES6新增量，可以理解为常量，一旦赋值初始化，遍不能修改 引入http模块 创建server，request为发送的请求，response为返回的数据 response.write(‘pachong’);屏幕打印 实质上是node帮我们创建的HTML标签 response.end();让响应的代码结束（不可缺） 完整代码 指定9000端口 const http = require(&apos;http&apos;); http.createServer((request,response)=&gt;{ response.write(&apos;pachong&apos;); response.end(); }).listen(9000);","tags":[]},{"title":"Nodejs爬虫实战（五）","date":"2019-10-23T08:17:29.405Z","path":"2019/10/23/Nodejs爬虫实战（五）/","text":"1. 抓取标签内容 引入模块 新模块jsdom中的JSDOM 创建对象 let DOM = new JSDOM(html); let document = DOM.window.document; dom操作 document.querySelector(&apos;.tm-count&apos;).innerHTML ###### 完整代码 var index = 0; const fs = require(&apos;fs&apos;); const url = require(&apos;url&apos;); const gbk = require(&apos;gbk&apos;); const JSDOM = require(&apos;jsdom&apos;).JSDOM; GetUrl(&apos;https://detail.tmall.com/item.htm?id=548466958386&amp;ali_refid=a3_430583_1006:1103419234:N:%E5%8D%8E%E4%B8%BA:bb84ee4c8f67c7b202d725187b7ad429&amp;ali_trackid=1_bb84ee4c8f67c7b202d725187b7ad429&amp;spm=a230r.1.14.1&amp;sku_properties=5919063:6536025;12304035:116177&apos;,(data)=&gt;{ var html = gbk.toString(&apos;utf-8&apos;,data); let DOM = new JSDOM(html); let document = DOM.window.document; console.log(document.querySelector(&apos;.tm-count&apos;).innerHTML) }) function GetUrl(sUrl,success){ index++; var urlObj = url.parse(sUrl); var http =&apos;&apos;; if(urlObj.protocol == &apos;http:&apos;){ http = require(&apos;http&apos;); } else{ http = require(&apos;https&apos;); } let req = http.request({ &apos;hostname&apos;:urlObj.hostname, &apos;path&apos;:urlObj.path },res=&gt;{ if(res.statusCode == 200){ var arr = []; var str = &apos;&apos;; res.on(&apos;data&apos;,buffer=&gt;{ arr.push(buffer); //str +=buffer; }); res.on(&apos;end&apos;,()=&gt;{ let b = Buffer.concat(arr); success &amp;&amp; success(b); }) } else if(res.statusCode == 302 || res.statusCode == 301){ console.log(`第${index}次重定向`,res.headers.location); GetUrl(res.headers.location,success) } }); req.end(); req.on(&apos;error&apos;,()=&gt;{ console.log(&apos;404&apos;); }) }","tags":[]},{"title":"Nodejs爬虫实战（四）","date":"2019-10-23T08:17:29.403Z","path":"2019/10/23/Nodejs爬虫实战（四）/","text":"1. 淘宝天猫页面重定向 尝试抓取淘宝页面 打印res.statusCode,res.headers.location res.statusCode返回的状态码; res.headers.location返回的地址 发现状态码为302，百度HTTP状态码 302 Move Temporarily 请求的资源临时从不同的 URI响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 如果这不是一个 GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用 GET 方式访问在 Location 中规定的 URI，而无视原先请求的方法。状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。 淘宝返回给我们的只是一个临时的html页面，并不是真正的还有数据的页面。 判断是否重定向，递归寻找真页面 if(res.statusCode == 302 || res.statusCode == 301){ console.log(`第${index}次重定向`,res.headers.location); GetUrl(res.headers.location,success) } 2. 转码 拿到了真实页面之后，打开发现有编码错误的问题 引用gbk模块 gbk提供了编码转换的方法 gbk.toString(&#39;utf-8&#39;,data); 结束 ###### 完整代码 var index = 0; const fs = require(&apos;fs&apos;); const url = require(&apos;url&apos;); const gbk = require(&apos;gbk&apos;); GetUrl(&apos;https://detail.tmall.com/item.htm?spm=a230r.1.14.6.68624507tWuF7E&amp;id=560257961625&amp;cm_id=140105335569ed55e27b&amp;abbucket=18&amp;sku_properties=10004:709990523&apos;,(data)=&gt;{ var html = gbk.toString(&apos;utf-8&apos;,data); console.log(html) //console.log(&apos;终于我走出来了&apos;) //fs.writeFile(&apos;iponex.html&apos;,data); //console.log(str) }) function GetUrl(sUrl,success){ index++; var urlObj = url.parse(sUrl); var http =&apos;&apos;; if(urlObj.protocol == &apos;http:&apos;){ http = require(&apos;http&apos;); } else{ http = require(&apos;https&apos;); } let req = http.request({ &apos;hostname&apos;:urlObj.hostname, &apos;path&apos;:urlObj.path },res=&gt;{ if(res.statusCode == 200){ var arr = []; var str = &apos;&apos;; res.on(&apos;data&apos;,buffer=&gt;{ arr.push(buffer); //str +=buffer; }); res.on(&apos;end&apos;,()=&gt;{ let b = Buffer.concat(arr); success &amp;&amp; success(b); }) } else if(res.statusCode == 302 || res.statusCode == 301){ console.log(`第${index}次重定向`,res.headers.location); GetUrl(res.headers.location,success) } //console.log(res.statusCode,res.headers.location) }); req.end(); req.on(&apos;error&apos;,()=&gt;{ console.log(&apos;404了，哥们&apos;); }) }","tags":[]},{"title":"Nodejs爬虫实战（三）","date":"2019-10-23T08:17:29.401Z","path":"2019/10/23/Nodejs爬虫实战（三）/","text":"1. 抽取函数处理 引入模块 http协议和https协议两种，既有不同，那么模块引入创建的变量自然不同 url对象的parse方法能获得http或者https协议的信息。以http://example.com:8080/one?a为例打印。 { protocol : &apos;http:&apos; , auth : null , host : &apos;example.com:8080&apos; , port : &apos;8080&apos; , hostname : &apos;example.com&apos; , hash : null , search : &apos;?a=index&amp;t=article&amp;m=default&apos;, query : &apos;a=index&amp;t=article&amp;m=default&apos;, pathname : &apos;/one&apos;, path : &apos;/one?a=index&amp;t=article&amp;m=default&apos;, href : &apos;http://example.com:8080/one?a=index&amp;t=article&amp;m=default&apos; } protocol属性保存了协议 if(urlObj.protocol == &apos;http:&apos;){ http = require(&apos;http&apos;); } else{ http = require(&apos;https&apos;); } 处理error页面 req.on(&apos;error&apos;,()=&gt;{ console.log(&apos;404&apos;); }) ###### 完整代码 const fs = require(&apos;fs&apos;); const url = require(&apos;url&apos;) GetUrl(&apos;https://detail.tmall.com/item.htm?spm=a230r.1.14.6.68624507tWuF7E&amp;id=560257961625&amp;cm_id=140105335569ed55e27b&amp;abbucket=18&amp;sku_properties=10004:709990523&apos;,data=&gt;{ fs.writeFile(&apos;iponex.html&apos;,data); }) function GetUrl(sUrl,success){ var urlObj = url.parse(sUrl); var http =&apos;&apos;; if(urlObj.protocol == &apos;http:&apos;){ http = require(&apos;http&apos;); } else{ http = require(&apos;https&apos;); } let req = http.request({ &apos;hostname&apos;:urlObj.hostname, &apos;path&apos;:urlObj.path },res=&gt;{ console.log(res) var arr = []; res.on(&apos;data&apos;,buffer=&gt;{ arr.push(buffer); }); res.on(&apos;end&apos;,()=&gt;{ let b = Buffer.concat(arr); success &amp;&amp; success(b); }) }); req.end(); req.on(&apos;error&apos;,()=&gt;{ console.log(&apos;404&apos;); }) }","tags":[]},{"title":"Nodejs爬虫实战（七）数据可视化","date":"2019-10-23T08:17:29.400Z","path":"2019/10/23/Nodejs爬虫实战（七）数据可视化/","text":"1. HTML部分 创建一个输入框，确定按钮 数据可视化的盒子 引入echarts.min.js和ajax.js 完整代码&lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&apos;ajax.js&apos;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&apos;echarts.min.js&apos;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&apos;echarts_show.js&apos;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; 请输入网址:&lt;input type=&apos;text&apos; id=&apos;ipt&apos;&gt;&lt;br&gt; &lt;button id=&apos;btn&apos;&gt;确定&lt;/button&gt; &lt;br&gt; &lt;div id=&quot;main&quot; style=&quot;width: 1700px;height:1500px;&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 2. NodeJS部分 创建本地服务器，端口9000 引入express模块，框架搭建 完整代码const express = require(&apos;express&apos;); const server = express(); server.listen(9000); var index = 0; const fs = require(&apos;fs&apos;); const url = require(&apos;url&apos;); const gbk = require(&apos;gbk&apos;); const JSDOM = require(&apos;jsdom&apos;).JSDOM; const Segment = require(&apos;segment&apos;); let seg = new Segment(); seg.useDefault(); server.use(&apos;/getMsg&apos;,(req,res)=&gt;{ console.log(req.query); GetUrl(req.query.str,(data)=&gt;{ let DOM = new JSDOM(data); let document = DOM.window.document; var myHtml = document.querySelector(&apos;.read-content&apos;).innerHTML.replace(/&lt;[^&gt;]+&gt;/g,&apos;&apos;) var arr = seg.doSegment(myHtml); //去掉没用的 var myarr = []; arr.forEach(data=&gt;{ if(data.p !=2048){ myarr.push(data.w) } }); var myJson = {}; myarr.forEach(data=&gt;{ if(!myJson[data]){ myJson[data] = 1; } else{ myJson[data]++; } }); let arr2 = []; for(let word in myJson){ if(myJson[word]&lt;=1){ continue; } arr2.push({ w:word, c:myJson[word] }) }; arr2.sort((json1,json2)=&gt;json2.c-json1.c); res.send({&apos;need&apos;:arr2}); }) }) function GetUrl(sUrl,success){ index++; var urlObj = url.parse(sUrl); var http =&apos;&apos;; if(urlObj.protocol == &apos;http:&apos;){ http = require(&apos;http&apos;); } else{ http = require(&apos;https&apos;); } let req = http.request({ &apos;hostname&apos;:urlObj.hostname, &apos;path&apos;:urlObj.path },res=&gt;{ if(res.statusCode == 200){ //var arr = []; var str = &apos;&apos;; res.on(&apos;data&apos;,buffer=&gt;{ //arr.push(buffer); str +=buffer; }); res.on(&apos;end&apos;,()=&gt;{ //let b = Buffer.concat(arr); success &amp;&amp; success(str); }) } else if(res.statusCode == 302 || res.statusCode == 301){ console.log(`第${index}次重定向`,res.headers.location); GetUrl(res.headers.location,success) } //console.log(res.statusCode,res.headers.location) }); req.end(); req.on(&apos;error&apos;,()=&gt;{ console.log(&apos;404了，哥们&apos;); }) } server.use(express.static(&apos;./&apos;))3. echarts_show.js btn的点击事件 btn[&apos;onclick&apos;] = x =&gt; {} ajax发送get请求 将数据处理为echarts图表的表达 var json = eval(&apos;(&apos; + data + &apos;)&apos;).need; var arr = [] json.forEach(data =&gt; { arr.push({ name: data.w, value: data.c }) });完整代码var myChart = echarts.init(document.getElementById(&apos;main&apos;)); btn[&apos;onclick&apos;] = x =&gt; { ajax({ url: &apos;http://localhost:9000/getMsg&apos;, type: &apos;get&apos;, data: { str: ipt.value }, success(data) { var json = eval(&apos;(&apos; + data + &apos;)&apos;).need; var arr = [] json.forEach(data =&gt; { arr.push({ name: data.w, value: data.c }) }); //console.log(arr) option = { title: { text: &apos;该小说网站的数据&apos;, subtext: &apos;纯属虚构&apos;, x: &apos;center&apos; }, tooltip: { trigger: &apos;item&apos;, formatter: &quot;{a} &lt;br/&gt;{b} : {c} ({d}%)&quot; }, series: [ { name: &apos;访问来源&apos;, type: &apos;pie&apos;, radius: &apos;55%&apos;, center: [&apos;50%&apos;, &apos;60%&apos;], data: arr, itemStyle: { emphasis: { shadowBlur: 10, shadowOffsetX: 0, shadowColor: &apos;rgba(0, 0, 0, 0.5)&apos; } } } ] }; myChart.setOption(option); } }) } 4. ajax.js部分 引入封装好的js文件function ajax(option){ // console.log(option.data) //{user:leo,pass:123456} //user=leo&amp;pass=123456 // var ajax = new XMLHttpRequest(); if(window.XMLHttpRequest){ var ajax = new XMLHttpRequest(); } else{ var ajax = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); }; if(option.type == &apos;get&apos;){ ajax.open(option.type,option.url+&apos;?&apos;+JsonToString(option.data),true); ajax.send(); } else if(option.type=&apos;post&apos;){ ajax.open(option.type,option.url,true); ajax.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;); ajax.send(JsonToString(option.data)); } ajax.onreadystatechange=function(){ //console.log(ajax.readyState) if(ajax.readyState == 4){ if(ajax.status&gt;=200&amp;&amp;ajax.status&lt;300||ajax.status==304){ option.success(ajax.responseText) //console.log() } else{ option.error &amp;&amp; option.error(); // console.log(&apos;服务器错误-&apos;) } //console.log(ajax.status) //console.log(ajax.responseText) } } function JsonToString(json){ var arr = []; for(var i in json){ //console.log(i+option.data[i]) arr.push(i+&apos;=&apos;+json[i]) }; //console.log(arr.join(&apos;&amp;&apos;)); return arr.join(&apos;&amp;&apos;); } }","tags":[]},{"title":"Nodejs爬虫实战（六）","date":"2019-10-23T08:17:29.398Z","path":"2019/10/23/Nodejs爬虫实战（六）/","text":"1. 处理数据 上一步获取结果中含有p标签，用正则筛选，去掉标签，只留下文本。 var myHtml = document.querySelector(&apos;.read-content&apos;).innerHTML.replace(/&lt;[^&gt;]+&gt;/g,&apos;&apos;) 统计词的个数首先需要文本分词 分词模块segment(盘古分词组件)，实例化，使用默认的识别模块及字典，载入字典文件需要1秒，仅初始化时执行一次即可 let seg = new Segment(); seg.useDefault(); 开始分词。 var arr = seg.doSegment(myHtml); 结果其中w表示内容，p表示词性，词性收录 [ { w: &apos;这是&apos;, p: 0 }, { w: &apos;一个&apos;, p: 2097152 }, { w: &apos;基于&apos;, p: 262144 }, { w: &apos;Node.js&apos;, p: 8 }, { w: &apos;的&apos;, p: 8192 }, { w: &apos;中文&apos;, p: 1048576 }, { w: &apos;分词&apos;, p: 4096 }, { w: &apos;模块&apos;, p: 1048576 }, { w: &apos;。&apos;, p: 2048 } ] 去掉词性为2048的标点 var myarr = []; arr.forEach(data=&gt;{ if(data.p !=2048){ myarr.push(data.w) } }); JSON格式统计词内容 var myJson = {}; myarr.forEach(data=&gt;{ if(!myJson[data]){ myJson[data] = 1; } else{ myJson[data]++; } }); 去掉其中只出现一次的 let arr2 = []; for(let word in myJson){ if(myJson[word]&lt;=1){ continue; } arr2.push({ w:word, c:myJson[word] }) }; 结果排序 arr2.sort((json1,json2)=&gt;json2.c-json1.c); ###### 完整代码 var index = 0; const fs = require(&apos;fs&apos;); const url = require(&apos;url&apos;); const gbk = require(&apos;gbk&apos;); const JSDOM = require(&apos;jsdom&apos;).JSDOM; const Segment = require(&apos;segment&apos;); let seg = new Segment(); seg.useDefault(); GetUrl(&apos;https://www.xs8.cn/chapter/7373911103301701/19794192502339694&apos;,(data)=&gt;{ let DOM = new JSDOM(data); let document = DOM.window.document; var myHtml = document.querySelector(&apos;.read-content&apos;).innerHTML.replace(/&lt;[^&gt;]+&gt;/g,&apos;&apos;) var arr = seg.doSegment(myHtml); //去掉没用的 var myarr = []; arr.forEach(data=&gt;{ if(data.p !=2048){ myarr.push(data.w) } }); //计算个数，存为json格式 var myJson = {}; myarr.forEach(data=&gt;{ if(!myJson[data]){ myJson[data] = 1; } else{ myJson[data]++; } }); //去掉只出现1次的 let arr2 = []; for(let word in myJson){ if(myJson[word]&lt;=1){ continue; } arr2.push({ w:word, c:myJson[word] }) }; arr2.sort((json1,json2)=&gt;json2.c-json1.c); console.log(arr2); }) function GetUrl(sUrl,success){ index++; var urlObj = url.parse(sUrl); var http =&apos;&apos;; if(urlObj.protocol == &apos;http:&apos;){ http = require(&apos;http&apos;); } else{ http = require(&apos;https&apos;); } let req = http.request({ &apos;hostname&apos;:urlObj.hostname, &apos;path&apos;:urlObj.path },res=&gt;{ if(res.statusCode == 200){ var str = &apos;&apos;; res.on(&apos;data&apos;,buffer=&gt;{ str +=buffer; }); res.on(&apos;end&apos;,()=&gt;{ success &amp;&amp; success(str); }) } else if(res.statusCode == 302 || res.statusCode == 301){ console.log(`第${index}次重定向`,res.headers.location); GetUrl(res.headers.location,success) } }); req.end(); req.on(&apos;error&apos;,()=&gt;{ console.log(&apos;404了，哥们&apos;); }) }","tags":[]},{"title":"Nodejs爬虫实战（二）","date":"2019-10-23T08:17:29.396Z","path":"2019/10/23/Nodejs爬虫实战（二）/","text":"1. 尝试抓取数据 引入模块http和fs，fs为文件操作模块 let 声明的变量只在 let 命令所在的代码块内有效 在ES6之前没有块级概念，let在所在区域内有效，和c语言中的变量作用域相同。 var变量，函数内声明的变量作用域是局部的，外部就是全局的。 request中包含很多信息，其中的hostname指域名，path指域名后的路径。 抓取数据必然是要在request请求发送后进行，防止数据阻塞导致 函数提前执行抛异常出现，将操作放在回调函数中。 箭头函数 (ES6语法) 更简短的函数 ES3/5： elements.map(function(element) { return element.length; }); ES6： elements.map((e) =&gt; { return e.length; }); // 当只有一个参数时，可以省略括号 elements.map(e =&gt; { return e.length; }); // 当函数体只有一个 `return` 语句时， //可以省略 `return` 关键字和方法体的花括号 elements.map(e =&gt; e.length); 不绑定this this:面向对象的标志 //ES3/5 //通过将this值分配给封闭的变量，可以解决this问题。 function Person() { //构造函数定义`this`作为自己的实例. this.age = 0; setInterval(function growUp() { // 非严格模式, growUp()定义`this`作为全局对象, // 与在 Person()构造函数中定义的 `this`并不相同. this.age++; }, 1000); } //ES6 //箭头函数不会创建自己的this,只从自己的作用域链的上一层继承this。 function Person(){ this.age = 0; setInterval(() =&gt; { this.age++; // |this| 正确地指向 p 实例 }, 1000); } var p = new Person(); 取数据，通过on将data做buffer操作，将读取的结果依此push到数组arr中，通过end回调写文件fs.writeFile，写文件成功打印success var arr =[]; res.on(&apos;data&apos;,buffer=&gt;{ arr.push(buffer) }); res.on(&apos;end&apos;,()=&gt;{ fs.writeFile(&apos;1.jpg&apos;,b,()=&gt;{ console.log(&apos;success&apos;) }) }); 结果发现照片打不开，为什么呢？ 这里存在一个转换的问题，它必须将我们读取到的data转换为二进制流，（将一个.jpg拖进文本编辑器会自动解析为二进制文本） buffer对象已经提供了concat方法帮我们转换为二进制流。 let b = Buffer.concat(arr); 别忘了最后的end() ###### 完整代码 const http = require(&apos;http&apos;); const fs = require(&apos;fs&apos;); let req = http.request({ &apos;hostname&apos;:&apos;img.alicdn.com&apos;, &apos;path&apos;:&apos;/tps/i4/TB1_1BLMXXXXXb3XXXXlkjU.VXX-346-200.jpg_350x1000q90.jpg_.webp&apos; },res=&gt;{ var arr =[]; res.on(&apos;data&apos;,buffer=&gt;{ arr.push(buffer) }); res.on(&apos;end&apos;,()=&gt;{ let b = Buffer.concat(arr); fs.writeFile(&apos;1.jpg&apos;,b,()=&gt;{ console.log(&apos;success&apos;) }) }); }); req.end();","tags":[]},{"title":"jQuery集合","date":"2019-10-23T08:17:29.393Z","path":"2019/10/23/jQuery集合/","text":"目录：01 - jQuery的Hello World 02 - jQuery获取元素，属性，加载，入口函数 03 -jQuery入口函数写法 04 - jQuery冲突，核心函数，对象 05 - jQuery静态方法，实例方法 06 - 静态方法（each，map） 07 - 静态方法（trim，isWindow，isArray，isFunction） 08 - 内容选择器 09 - 属性和属性节点 10 - jQuery的attr和prop 11 - jQuery操作类，文本值 操作方法 12 - jQuery操作CSS，位置尺寸，scrollTop 13 - 绑定，移除事件 14 - 冒泡，默认行为，自动触发，自定义事件 15 - 命名空间，委托，移入移出 16 - 动画合集（显示隐藏，展开收起，淡入淡出，自定义） 17 - 折叠菜单练习，下拉菜单练习 18 - 对联广告，弹窗广告练习 19 - jQuery的stop和delay方法 20 - 图标特效，无限滚动循环练习 21 - 节点操作集合（添加，删除，替换，复制）","tags":[]},{"title":"JDBC_DAO模式","date":"2019-10-23T08:17:29.391Z","path":"2019/10/23/JDBC_DAO模式/","text":"包结构 src dao UserDao.java dao.impl UserDaoimpl.java util JDBCUtil.java test Test.java jdbc.properties.txt lib mysql-connector-java-bin.jar 完整代码jdbc.properties #mysql driverClass = com.mysql.jdbc.Driver url = jdbc:mysql://localhost:3306/emp user = root password = 1230 #oracl #driver = oracle.jdbc.driver.OracleDriver #jdbcUrl = jdbc:oracle:thin:@localhost:1521:orcl #user = root #password = 1230JDBCUtil.java package util; import java.io.IOException; import java.io.InputStream; import java.sql.Connection; import java.sql.DriverManager; import java.sql.ResultSet; import java.sql.SQLException; import java.sql.Statement; import java.util.Properties; public class JDBCUtil { static String driverClass= null; static String url = null; static String user = null; static String password = null; static { try { //创建一个属性配置对象 Properties properties = new Properties(); //根工程目录 // InputStream in = new FileInputStream(&quot;jdbc.properties&quot;); //src路径 //使用类加载器，读取配置文件 InputStream in = JDBCUtil.class.getClassLoader().getResourceAsStream(&quot;jdbc.properties&quot;); //输入流 properties.load(in); driverClass = properties.getProperty(&quot;driverClass&quot;); url = properties.getProperty(&quot;url&quot;); user = properties.getProperty(&quot;user&quot;); password = properties.getProperty(&quot;password&quot;); } catch (IOException e) { e.printStackTrace(); } } public static Connection getConn() { Connection conn = null; try { //4.0以上版本不用注册驱动 //Class.forName(driverClass); conn = DriverManager.getConnection(url, user, password); } catch (Exception e) { // TODO Auto-generated catch block e.printStackTrace(); } return conn; } /** * 释放资源 * @param conn * @param st */ public static void release(Connection conn, Statement st, ResultSet rs) { closeRs(rs); closeSt(st); closeConn(conn); } public static void release(Connection conn, Statement st) { closeSt(st); closeConn(conn); } public static void closeRs(ResultSet rs) { try { if(rs != null) { rs.close(); } } catch (SQLException e) { e.printStackTrace(); }finally { rs=null; } } public static void closeSt(Statement st) { try { if(st != null) { st.close(); } } catch (SQLException e) { e.printStackTrace(); }finally { st=null; } } public static void closeConn(Connection conn) { try { if(conn != null) { conn.close(); } } catch (SQLException e) { e.printStackTrace(); }finally { conn=null; } } }UserDao.java package dao; public interface UserDao { /** * 根据id去更新具体的用户名 * @param id * @param name */ void update(int id , String name); void delete(int id); /** * 执行添加 * @param userName * @param password */ void insert(String userName , String password); /** * 查询所有 */ void findAll(); /** * 登录方法 * @param username * @param password */ void login(String username , String password); }UserDaoImpl.java package dao.impl; import java.sql.Connection; import java.sql.ResultSet; import java.sql.SQLException; import java.sql.Statement; import java.sql.PreparedStatement; import dao.UserDao; import util.JDBCUtil; public class UserDaoImpl implements UserDao{ /** * 查询所有 */ @Override public void findAll() { Connection conn = null; Statement st = null; ResultSet rs = null; try { //1. 创建连接对象 conn = JDBCUtil.getConn(); //2. 创建statement对象 st = conn.createStatement(); String sql=&quot;select * from tt&quot;; rs = st.executeQuery(sql); while(rs.next()){ String name = rs.getString(&quot;name&quot;); String age = rs.getString(&quot;age&quot;); System.out.println(name+&quot;:&quot;+age); } } catch (SQLException e) { e.printStackTrace(); }finally { JDBCUtil.release(conn, st, rs); } } /** * 登陆校验 */ /*@Override public void login(String username, String password) { Connection conn = null; Statement st = null; ResultSet rs = null; try { //1. 获取连接对象 conn = JDBCUtil.getConn(); //2. 创建statement对象 st = conn.createStatement(); // SELECT * FROM t_user WHERE username=&apos;admin&apos; AND PASSWORD=&apos;10086&apos; String sql = &quot;select * from t_user where username=&apos;&quot;+ username +&quot;&apos; and password=&apos;&quot;+ or +&quot;&apos;&quot;; rs = st.executeQuery(sql); if(rs.next()){ System.out.println(&quot;登录成功&quot;); }else{ System.out.println(&quot;登录失败&quot;); } } catch (Exception e) { e.printStackTrace(); }finally { JDBCUtil.release(conn, st, rs); } }*/ /** * 登陆校验 */ @Override public void login(String username,String password) { Connection conn = null; Statement st = null; ResultSet rs = null; PreparedStatement ps = null; String sql = &quot;&quot;; try { conn = JDBCUtil.getConn(); // st = conn.createStatement(); //2.预先对sql语句执行语法校验， ？ 对应的内容，后面不管什么传递进来，都当做字符串 sql = &quot;select * from login where username=? and password=?&quot;; ps = conn.prepareStatement(sql); // ? 索引从1开始 ps.setString(1, username); ps.setString(2, password); rs = ps.executeQuery(); if(rs.next()) { System.out.println(&quot;登陆成功&quot;); }else { System.out.println(&quot;登陆失败&quot;); } } catch (SQLException e) { e.printStackTrace(); }finally { JDBCUtil.release(conn, st, rs); } } /** * 插入 */ @Override public void insert(String username, String password) { Connection conn = null; Statement st = null; PreparedStatement ps = null; String sql = &quot;&quot;; try { conn = JDBCUtil.getConn(); sql = &quot;insert into tt values(4 , ? , ?)&quot;; // st = conn.createStatement(); //2.预先对sql语句执行语法校验， ？ 对应的内容，后面不管什么传递进来，都当做字符串 ps = conn.prepareStatement(sql); //?索引从1开始 ps.setString(1, username); ps.setString(2, password); int result = ps.executeUpdate(); if(result&gt;0) { System.out.println(&quot;插入成功&quot;); }else { System.out.println(&quot;插入失败&quot;); } } catch (SQLException e) { e.printStackTrace(); }finally { JDBCUtil.release(conn, ps); } } /** * 删除 */ @Override public void delete(int id) { Connection conn = null; PreparedStatement ps = null; String sql = &quot;&quot;; try { conn = JDBCUtil.getConn(); sql = &quot;delete from tt where id=?&quot;; // st = conn.createStatement(); //2.预先对sql语句执行语法校验， ？ 对应的内容，后面不管什么传递进来，都当做字符串 ps = conn.prepareStatement(sql); //?索引从 1 开始 ps.setInt(1, id); int result = ps.executeUpdate(); if(result&gt;0) { System.out.println(&quot;删除成功&quot;); }else { System.out.println(&quot;删除失败&quot;); } } catch (SQLException e) { e.printStackTrace(); }finally { JDBCUtil.release(conn, ps); } } /** * 更新 */ @Override public void update(int id, String name) { Connection conn = null; PreparedStatement ps = null; String sql = &quot;&quot;; try { conn = JDBCUtil.getConn(); sql = &quot;update tt set id=? where name=?&quot;; // st = conn.createStatement(); //2.预先对sql语句执行语法校验， ？ 对应的内容，后面不管什么传递进来，都当做字符串 ps = conn.prepareStatement(sql); //?索引从1开始 ps.setInt(1, id); ps.setString(2, name); int result = ps.executeUpdate(); if(result&gt;0) { System.out.println(&quot;更新成功&quot;); }else { System.out.println(&quot;更新失败&quot;); } } catch (SQLException e) { e.printStackTrace(); }finally { JDBCUtil.release(conn, ps); } } }Test.java package test; import org.junit.Test; import dao.UserDao; import dao.impl.UserDaoImpl; public class TestUserDaoImpl { @Test public void testFindAll(){ UserDao dao = new UserDaoImpl(); dao.findAll(); } @Test public void testlogin(){ UserDao dao = new UserDaoImpl(); dao.login(&quot;lishishi&quot;, &quot;45612213321&quot;); } @Test public void testInsert(){ UserDao dao = new UserDaoImpl(); dao.insert(&quot;wangwuwu&quot;,&quot;789&quot;); } @Test public void testDelete(){ UserDao dao = new UserDaoImpl(); dao.delete(4); } @Test public void testUpdate(){ UserDao dao = new UserDaoImpl(); dao.update(99, &quot;gengxin&quot;); } }","tags":[]},{"title":"Java文件的读(写)汇总[ InputStream（Reader）、BufferedInputStream 、BufferedReader、FileInputStream、FileReader ]","date":"2019-10-23T08:17:29.389Z","path":"2019/10/23/Java文件的读(写)汇总[ InputStream（Reader）、BufferedInputStream 、BufferedReader、FileInputStream、FileReader ]/","text":"[ InputStream 、InputStreamReader、BufferedInputStream 、BufferedReader、FileInputStream、FileReader ]&amp;&amp;[ OutputStream、OutputStreamWriter、BufferedOutputStream、BufferedWriter、FileOutputStream、FileWriter ] InputStream &amp;&amp; OutputStream： 是老大！！！ 将字节流转换成字符流 InputStreamReader&amp;&amp; OutputStreamWriter： 将字节流转换成字符流 —&gt; 创建字符流缓冲区 BufferedInputStream &amp;&amp; BufferedOutputStream： 数据流的缓存，没有缓冲的操作 读一个字节，写一个。磁盘的IO比内存的操作慢 所以不带缓冲的额流会比带缓冲的流慢 BufferedReader &amp;&amp; BufferedWriter 高效读取 从字符输入流中读取文本，缓冲各个字符 FileInputStream &amp;&amp; FileOutputStream 老大InputSream的子类 一般用来读取二进制文件 文本文件使用read(byte[] b)方法读取整个文件，再byte数组转换为String FileReader &amp;&amp; FileWriter InputStreamReader的子类 按字符读取流中数据 还有很多。。。更新中。。。 InputStream &amp;&amp; OutputStreamprivate static void rwIOStream() throws Exception { InputStream in =new FileInputStream(&quot;fileIn\\\\txt1&quot;); OutputStream out = new FileOutputStream(&quot;fileOut\\\\txt1&quot;); int len; long begin = System.currentTimeMillis(); while((len=in.read())!=-1) { out.write(len); } long end = System.currentTimeMillis(); System.out.println(end-begin); in.close(); out.close(); } InputStreamReader&amp;&amp; OutputStreamWriterprivate static void rwIOStreamRW() throws Exception { InputStreamReader inReader =new InputStreamReader(new FileInputStream(&quot;fileIn\\\\txt1&quot;)); OutputStreamWriter outWriter =new OutputStreamWriter(new FileOutputStream(&quot;fileIn\\\\txt1&quot;)); int len; long begin = System.currentTimeMillis(); while((len=inReader.read())!=-1) { outWriter.write(len); } long end = System.currentTimeMillis(); System.out.println(end-begin); inReader.close(); outWriter.close(); } BufferedInputStream &amp;&amp; BufferedOutputStreamprivate static void rwBufferedIOStram() throws Exception { BufferedInputStream in = new BufferedInputStream(new FileInputStream(&quot;fileIn\\\\txt1&quot;)); BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(&quot;fileOut\\\\txt1&quot;)); long begin = System.currentTimeMillis(); int len; while((len=in.read())!=-1) { out.write(len); //System.out.print((char)len); // 字符打印 } long end = System.currentTimeMillis(); System.out.println(end-begin); in.close(); out.close(); } BufferedReader &amp;&amp; BufferedWriterprivate static void rwBufferedRWr() throws Exception { BufferedReader reader = new BufferedReader(new FileReader(&quot;fileIn\\\\txt1&quot;)); BufferedWriter writer = new BufferedWriter(new FileWriter(&quot;fileIn\\\\txt1&quot;)); int len; long begin = System.currentTimeMillis(); while((len = reader.read())!=-1) { writer.write(len); //System.out.print((char)len); } long end = System.currentTimeMillis(); System.out.println(end-begin); reader.close(); writer.close(); } FileInputStream &amp;&amp; FileOutputStreamprivate static void rwFileIOStream() throws Exception { FileInputStream reader = new FileInputStream(&quot;fileIn\\\\txt1&quot;); FileOutputStream writer = new FileOutputStream(&quot;fileIn\\\\txt1&quot;); int len; long begin = System.currentTimeMillis(); while((len = reader.read())!=-1) { writer.write(len); //System.out.print((char)len); } long end = System.currentTimeMillis(); System.out.println(end-begin); reader.close(); writer.close(); } FileReader &amp;&amp; FileWriterprivate static void rwFile() throws Exception { FileReader reader = new FileReader(&quot;fileIn\\\\txt1&quot;); FileWriter writer = new FileWriter(&quot;fileOut\\\\txt1&quot;); int len; long begin = System.currentTimeMillis(); while((len = reader.read())!=-1) { writer.write(len); //System.out.print((char)len); } long end = System.currentTimeMillis(); System.out.println(end-begin); reader.close(); writer.close(); } 程序package file; import java.io.BufferedInputStream; import java.io.BufferedOutputStream; import java.io.BufferedReader; import java.io.BufferedWriter; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.FileReader; import java.io.FileWriter; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.io.OutputStream; import java.io.OutputStreamWriter; public class filecopy { public static void main(String[] avg) throws Exception { try { //复制例 song(); //字符读写 切割处理 rwFileSplitEnglish(); //InputStream &amp;&amp; OutputStream rwIOStream(); //InputStreamReader &amp;&amp; OutputStreamWriter rwIOStreamRW(); //BufferedInputStream &amp;&amp; BufferedOutputStream rwBufferedIOStram(); //BufferedReader &amp;&amp; BufferedWriter rwBufferedRWr(); //FileInputStream &amp;&amp; FileOutputStream rwFileIOStream(); //FileReader &amp;&amp; FileWriter rwFile(); } catch (Exception e) { e.printStackTrace(); } } private static void rwIOStream() throws Exception { InputStream in =new FileInputStream(&quot;fileIn\\\\txt1&quot;); OutputStream out = new FileOutputStream(&quot;fileOut\\\\txt1&quot;); int len; long begin = System.currentTimeMillis(); while((len=in.read())!=-1) { out.write(len); } long end = System.currentTimeMillis(); System.out.println(end-begin); in.close(); out.close(); } private static void rwIOStreamRW() throws Exception { InputStreamReader inReader =new InputStreamReader(new FileInputStream(&quot;fileIn\\\\txt1&quot;)); OutputStreamWriter outWriter =new OutputStreamWriter(new FileOutputStream(&quot;fileIn\\\\txt1&quot;)); int len; long begin = System.currentTimeMillis(); while((len=inReader.read())!=-1) { outWriter.write(len); } long end = System.currentTimeMillis(); System.out.println(end-begin); inReader.close(); outWriter.close(); } private static void rwBufferedIOStram() throws Exception { BufferedInputStream in = new BufferedInputStream(new FileInputStream(&quot;fileIn\\\\txt1&quot;)); BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(&quot;fileOut\\\\txt1&quot;)); long begin = System.currentTimeMillis(); int len; while((len=in.read())!=-1) { out.write(len); //System.out.print((char)len); // 字符打印 } long end = System.currentTimeMillis(); System.out.println(end-begin); in.close(); out.close(); } private static void rwBufferedRWr() throws Exception { BufferedReader reader = new BufferedReader(new FileReader(&quot;fileIn\\\\txt1&quot;)); BufferedWriter writer = new BufferedWriter(new FileWriter(&quot;fileIn\\\\txt1&quot;)); int len; long begin = System.currentTimeMillis(); while((len = reader.read())!=-1) { writer.write(len); //System.out.print((char)len); } long end = System.currentTimeMillis(); System.out.println(end-begin); reader.close(); writer.close(); } private static void rwFileIOStream() throws Exception { FileInputStream reader = new FileInputStream(&quot;fileIn\\\\txt1&quot;); FileOutputStream writer = new FileOutputStream(&quot;fileIn\\\\txt1&quot;); int len; long begin = System.currentTimeMillis(); while((len = reader.read())!=-1) { writer.write(len); //System.out.print((char)len); } long end = System.currentTimeMillis(); System.out.println(end-begin); reader.close(); writer.close(); } private static void rwFile() throws Exception { FileReader reader = new FileReader(&quot;fileIn\\\\txt1&quot;); FileWriter writer = new FileWriter(&quot;fileOut\\\\txt1&quot;); int len; long begin = System.currentTimeMillis(); while((len = reader.read())!=-1) { writer.write(len); //System.out.print((char)len); } long end = System.currentTimeMillis(); System.out.println(end-begin); reader.close(); writer.close(); } private static void rwFileSplitEnglish() throws Exception { String str = &quot;&quot;; FileReader reader = new FileReader(&quot;fileIn\\\\txt1&quot;); int len; while((len = reader.read())!=-1) str +=(char)len; reader.close(); System.out.println(str); String re = &quot; &quot;; String s[] = str.split(re); for (int i = 0; i &lt; s.length; i++) { System.out.print(s[i]); } System.out.println(str.length()); } private static void song() throws Exception { InputStream in = new FileInputStream(&quot;fileIn\\\\你一生的故事.mp3&quot;); OutputStream out = new FileOutputStream(&quot;fileOut\\\\你一生的故事2.mp3&quot;); int len; long begintime = System.currentTimeMillis(); while((len=in.read())!=-1) { out.write(len); } long endtime = System.currentTimeMillis(); System.out.println(endtime-begintime); in.close(); out.close(); } }","tags":[]},{"title":"Java程序设计复习总结","date":"2019-10-23T08:17:29.387Z","path":"2019/10/23/Java程序设计复习总结/","text":"Java程序设计期中复习总结第一章 概述1. 应用程序的结构：package import class2. 源文件的扩展名.java，字节文件的扩展名：.class3. Java语言的工作原理：先编译后解释4. 一个源文件中最多可以有一个public类，并且文件名与public类名相同。5. 常用命令javac编译，java运行。6. 一个应用程序最少有一个main方法。 第二章 Java基础1. 标识符命名规则，能够区分合法标识符标识符命名规则 1. 标识符由26个英文字符大小写（a~zA~Z）、数字(0~9)、下划线(_)和美元符号($)组成。 2. 不能以数字开头，不能是关键字。 3. 严格区分大小写。 4. 标识符的可以为任意长度。2. 所有关键字都是小写3. 基本数据类型的名称、长度和默认值，注意float类型的定义方法：float f=3.14F；float f=3.14f；没有大写或者小写f是错误的。4. while和do-while的区别 do-while语句 后测试循环语句，即只有在循环体中的代码执行之后，才会测试出口条件。 while语句 前测试循环语句，即在循环体内的代码被执行之前，就会对出口条件求值。 5. 数组使用length属性获得长度int[] arr={&quot;11&quot;,&quot;22&quot;,33&quot;}; arr.length;//36. int [] a,b,c是定义了3个数组，int a[],b,c是定义了一个数组a，两个变量b，c7. 掌握基本数据类型的名称、长度、默认值和数据类型对应的封装类 8. 字符串转基本类型的方法 字符串转换为基本类型 Integer包装类的parseXxx静态方法 Integer包装类的valueOf()方法[自动拆箱] String str = “123”; int a = Integer.parseInt(str); int b = Integer.valueOf(str); 基本类型转换为字符串 Integer包装类的toString()方法 String类的valueOf()方法 n + “” int n = 6; String str = Integer.toString(n); String str = String.valueOf(n); String str = n + “”; 第三章 类和对象1. 什么是方法的重载 名字相同，参数列表不同的两个（或多个）方法 参数类型不同 参数个数不同 重载方法的依据方法参数列表的不同，是编译器用来区分调用哪一个 2. 构造方法是用来进行成员变量初始化的3. 构造方法的名字和类名相同4. 构造方法可以有也可以没有，没有系统会自动添加一个无参的方法，也可以有多个构造方法，构造方法可重载5. static关键字可以修饰变量和方法，可以使用类名直接调用，也可以使用对象调用6. public、private、默认、peorected修饰符可以修饰什么？作用范围分别是什么 public：public表明该数据成员、成员函数是对所有用户开放的，所有用户都可以直接进行调用 private：私有.就是除了class自己之外，任何人都不可以直接使用，即便是子女，朋友，都不可以使用。 protected：对于子女、朋友来说，是public可以自由使用，没有限制，而对于其他的外部class，protected就变成private。 默认(无修饰词)，同一个包内可以访问，包级访问权限； 权限修饰符用来修饰类、接口、方法、变量。 修饰类：public、默认（default）。 修饰接口：public、默认（default）。 修饰方法：private、默认、protected、public 修饰变量：private、默认、protected、public 7. 类、方法和变量等可以使用多个修饰符修饰8. 所有类的直接或者间接父类是Object类 第四章 继承1. 类之间使用extends关键字继承2. 子类继承父类成员后，在子类中定义与父类相同的成员叫重写（覆盖）3. final修饰类、变量和方法，不能被继承和改写4. Java所有的类都是java.lang.Object类的子类 第五章 抽象类、接口1. 定义接口使用interface，实现接口implements2. abstract修饰的类为抽象类，方法为抽象方法，抽象方法没有方法体3. 抽象类可以没有抽象方法，有抽象方法的类必定是抽象类4. 使用interface关键字定义接口，类使用implements实现（继承）接口5. 接口中只有常量和抽象方法，并且都是public abstract的抽象方法，都是public static final的常量6. 接口可以实现多重继承，定义类的模板7. 多态有两种体现重载和重写（覆盖），重载称为编译时多态，重写为运行时多态 第六章 字符串1. 字符串分为静态字符串（String）和动态字符串（StringBuffer）2. 使用length（）方法获得字符串的长度String str=&quot;asdfghjkl&quot;; str.length();//93. 其他常用方法chatAt（）、equals（） chatAt（） 返回位于字符串的指定索引处的字符 equals（） 所有的对象都拥有标识(内存地址)和状态(数据)，“==”比较两个对象的的内存地址，使用Object的equals()方法是比较两个对象的内存地址是否相等，即若object1.equals(object2)为true，则表示equals1和equals2实际上是引用同一个对象。 String、Math等封装类都对equals()方法进行了重写。比较的是两个对象的状态 第七章 异常处理1. 什么是异常异常是程序中的一些错误，但并不是所有的错误都是异常，并且错误有时候是可以避免的。 在程序执行期间发生的事件，它中断正在执行的程序的正常指令流。2. 为什么要进行异常处理为了能够及时有效地处理程序中的运行错误，必须使用异常类。 用户输入了非法数据。 要打开的文件不存在。 网络通信时连接中断，或者JVM内存溢出。 3. 所有异常的父类是Throwable类，它有两个直接子类为Error和Exception Error:程序无法处理的错误，表示运行应用程序中较严重问题。恢复不是不可能但很困难的情况下的一种严重问题。 例如，内存溢出，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。 Exception:是程序本身可以处理的异常。 exception 设计或实现问题。也就是说，它表示如果程序运行正常，从不会发生的情况 4. 异常分为运行时异常和非运行时异常unchecked exception 非检查异常 运行时异常（RuntimeException） Error 对于运行时异常，java编译器不要求必须进行异常捕获处理或者抛出声明，由程序员自行决定。 checked exception 非运行时异常（运行时异常以外的异常就是非运行时异常） java编译器强制程序员必须进行捕获处理，比如IOExeption和SQLException。 对于非运行时异常如果不进行捕获或者抛出声明处理，编译都不会通过。 5. 异常的处理过程是先抛弃后捕获6. 处理方法有三种： 运行时异常可回避 throws可回避交给上级调用模块处理 try-catch-finally自行处理 7. 进行异常捕获时，先发生的放在前面，后发生的放后面；子类异常放前面，父类放后面8. 使用throw制造异常throw 抛出的只能够是可抛出类Throwable 或者其子类的实例对象 第八章 输入输出1. 输入输出需要引入java.io包2. 文件和目录使用File类3. InputStream和OutputStream是字节输入输出流父接口，Reader和Writer是字符输入输出流父接口4. 完成文件内容拷贝练习题第九章 JDBC1. 需要引入的包是java.sql第十章 事件处理1. 事件处理模型是授权处理模型2. 常用的五种布局管理器是哪些？ FlowLayout 流式布局 BorderLayout 边框式布局 GridLayout 网格布局 CardLayout 卡片布局 BoxLayout 盒式布局 3.JFrame的默认布局管理器是BorderLayout4. JPanel是FlowLayout，FlowLayout的控件大小不随容器大小变化而改变第十章 多线程1 .线程的状态：初始状态、就绪状态、运行状态、阻塞状态、终止状态；新建的线程不能立即运行2. 启动线程需要调用start（）方法，不需要调用run（）方法3. 在定义Thread类时，run（）方法必须要重写4. 线程提供了wait、notify和notifyAll方法实现线程的同步 start()：启动线程 wait()：将当前线程置入休眠状态 notify()：唤醒在此对象监视器上等待的单个线程。 notifyAll()：唤醒在此对象监视器上等待的所有线程。 setPriority()：更改线程的优先级。 join()：使其他线程等待当前线程终止 interrupt()：中断线程 isAlive()：测试线程是否处于活动状态。static： sleep()：线程休眠 yield()：暂停当前正在执行的线程对象，并执行其他线程。 currentThread()：返回对当前正在执行的线程对象的引用。 5. 线程的优先级从1到10，程序员可以在编程时定义6. 创建线程的方法继承Thread类和实现Runnable方法第十一章 网络编程1. TCP编程使用ServerSocket和Socket，采用流式进行通讯，Socket代表客户端，ServerSocket代表服务器端2. 与网络通讯相关的类都封装在java.net包下 编程题1、评委打分12345678910111213141516171819202122232425package dafen;import java.util.Arrays;import java.util.Scanner;public class a1 &#123; public static void main(String[] args) &#123; //评委打分 Scanner scanner = new Scanner(System.in); int N=scanner.nextInt(); int[] arr = new int[N]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = scanner.nextInt(); &#125; Arrays.sort(arr); int score=0; for (int i = 1; i &lt; arr.length-1; i++) &#123; score += arr[i]; &#125; System.out.println(\"最终得分：\"+score/(arr.length-2)); &#125; &#125; 2、工厂零件//Area.java package area; import java.util.Scanner; import area.JieKou.Jiekou; public class Area { public static void main(String[] arg) { //工厂零件求面积 Scanner scanner = new Scanner(System.in); double r; r=scanner.nextDouble(); Jiekou jk = new Yuan(r); System.out.println(jk.getArea()+&quot; &quot;+jk.getZhouchang()); h=scanner.nextDouble(); Jiekou jk = new YuanZhu(r,h); System.out.println(jk.getArea()+&quot; &quot;); } } //JieKou.java package area; public class JieKou { public interface Jiekou { double getArea(); double getZhouchang(); } } //Yuan.java package area; import area.JieKou.Jiekou; public class Yuan implements Jiekou{ private final double PI = 3.14; private double r; public Yuan() {} public Yuan(double r) { this.r = r; } public double getArea() { return PI*r*r; } public double getZhouchang() { return 2*PI*r; } } //YuanZhu.java package area; public class YuanZhu extends Yuan{ private double h; public YuanZhu(double r,double h) { super(r); this.h=h; } public double getArea() { return (super.getArea()*h); } }3、文件copy操作package file; import java.io.*; public class filecopy { public static void main(String[] avg) throws Exception { try { //复制 song(); //字符读写 切割处理 rwFileSplitEnglish(); } catch (Exception e) { e.printStackTrace(); } } private static void rwFileSplitEnglish() throws Exception { String str = &quot;&quot;; //FileReader reader = new FileReader(&quot;fileIn\\\\txt1&quot;); BufferedReader reader = new BufferedReader(new FileReader(&quot;fileIn\\\\txt1&quot;)); int len; while((len = reader.read())!=-1) str +=(char)len; reader.close(); System.out.println(str); String re = &quot; &quot;; String s[] = str.split(re); for (int i = 0; i &lt; s.length; i++) { System.out.print(s[i]); } System.out.println(str.length()); } private static void song() throws Exception { InputStream in = new FileInputStream(&quot;fileIn\\\\你一生的故事.mp3&quot;); OutputStream out = new FileOutputStream(&quot;fileOut\\\\你一生的故事2.mp3&quot;); int len; long begintime = System.currentTimeMillis(); while((len=in.read())!=-1) { out.write(len); } long endtime = System.currentTimeMillis(); System.out.println(endtime-begintime); in.close(); out.close(); } }4、JDBCDao模式","tags":[]},{"title":"JavaSE实战——网络编程【客户端上传文件到服务端】","date":"2019-10-23T08:17:29.386Z","path":"2019/10/23/JavaSE实战——网络编程【客户端上传文件到服务端】/","text":"步骤 UpdateClient 客户端1.提示输入要上传的文件路径, 验证路径是否存在以及是否是文件夹1234567891011121314151617// 1.提示输入要上传的文件路径, 验证路径是否存在以及是否是文件夹File file = getFile();private static File getFile() &#123; Scanner scanner = new Scanner(System.in); System.out.println(\"请输入一个人文件路径\"); while(true) &#123; String line = scanner.nextLine(); File file = new File(line); if(!file.exists()) System.out.println(\"文件路径不存在，请重新录入：\"); else if (file.isDirectory()) System.out.println(\"录入为文件夹路径，非文件路径，请重新录入：\"); else return file; &#125; 2.发送文件名到服务端12345// 2.发送文件名到服务端Socket socket = new Socket(\"127.0.0.1\", 54321);BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()));PrintStream ps = new PrintStream(socket.getOutputStream());ps.println(file.getName()); 6.接收结果, 如果存在给予提示, 程序直接退出1234567// 6.接收结果, 如果存在给予提示, 程序直接退出String result = br.readLine();if(\"存在\".equals(result)) &#123; System.out.println(\"上传的文件已经存在\"); socket.close(); return;&#125; 7.如果不存在, 定义FileInputStream读取文件, 写出到网络1234567// 7.如果不存在, 定义FileInputStream读取文件, 写出到网络FileInputStream fis = new FileInputStream(file);int len;byte[] arr = new byte[8192];while((len=fis.read())!=-1)&#123; ps.write(arr,0,len);&#125; UpdateServer 服务端3.建立多线程的服务器123//3.建立多线程的服务器ServerSocket server = new ServerSocket(54321);System.out.println(\"服务器启动，绑定端口号54321\"); 4.读取文件名123456789//4.读取文件名final Socket socket = server.accept(); //接受请求 new Thread() &#123; public void run() &#123; InputStream is = socket.getInputStream(); BufferedReader br = new BufferedReader(new InputStreamReader(is)); PrintStream ps = new PrintStream(socket.getOutputStream()); String fileName = br.readLine(); &#125;.start(); 5.判断文件是否存在, 将结果发回客户端12345678910//5.判断文件是否存在, 将结果发回客户端File dir = new File(\"update\"); //创建上传文件夹的file对象dir.mkdir(); //创建文件夹File file = new File(dir,fileName); //封装成File对象if(file.exists()) &#123; //服务器已经存在需要上传的文件 ps.println(\"存在\"); socket.close(); return; &#125;else ps.println(\"不存在\"); 8.定义FileOutputStream, 从网络读取数据, 存储到本地1234567//8.定义FileOutputStream, 从网络读取数据, 存储到本地FileOutputStream fos = new FileOutputStream(file);byte[] arr = new byte[8192];int len;while((len=is.read(arr))!=-1) &#123; fos.write(arr,0,len);&#125; JavaSE实战源码客户端上传文件到服务端GUIChatBank项目","tags":[]},{"title":"Java_面向对象04(权限修饰符&匿名内部类)【面向对象笔记】","date":"2019-10-23T08:17:29.384Z","path":"2019/10/23/Java_面向对象04(权限修饰符&匿名内部类)【面向对象笔记】/","text":"(package关键字的概述及作用)(了解) A:为什么要有包 将字节码(.class)进行分类存放 包其实就是文件夹 B:包的概述 举例： 学生：增加，删除，修改，查询 老师：增加，删除，修改，查询 ... 方案1：按照功能分 com.heima.add AddStudent AddTeacher com.heima.delete DeleteStudent DeleteTeacher com.heima.update UpdateStudent UpdateTeacher com.heima.find FindStudent FindTeacher 方案2：按照模块分 com.heima.teacher AddTeacher DeleteTeacher UpdateTeacher FindTeacher com.heima.student AddStudent DeleteStudent UpdateStudent FindStudent(包的定义及注意事项)(掌握) A:定义包的格式 package 包名; 多级包用.分开即可 B:定义包的注意事项 A:package语句必须是程序的第一条可执行的代码 B:package语句在一个java文件中只能有一个 C:如果没有package，默认表示无包名 C:案例演示 包的定义及注意事项 (带包的类编译和运行)(掌握) A:如何编译运行带包的类 a:javac编译的时候带上-d即可 javac -d . HelloWorld.java b:通过java命令执行。 java 包名.HellWord(不同包下类之间的访问)(掌握) A:案例演示 不同包下类之间的访问 (import关键字的概述和使用)(掌握) A:案例演示 为什么要有import 其实就是让有包的类对调用者可见,不用写全类名了 B:导包格式 import 包名; 注意： 这种方式导入是到类的名称。 虽然可以最后写*，但是不建议。 C:package,import,class有没有顺序关系(面试题) ###10.06_面向对象(四种权限修饰符的测试)(掌握) A:案例演示 四种权限修饰符 B:结论 本类 同一个包下(子类和无关类) 不同包下(子类) 不同包下(无关类) private Y 默认 Y Y protected Y Y Y public Y Y Y Y 10.07_面向对象(类及其组成所使用的常见修饰符)(掌握) A:修饰符： 权限修饰符：private，默认的，protected，public 状态修饰符：static，final 抽象修饰符：abstract B:类： 权限修饰符：默认修饰符，public 状态修饰符：final 抽象修饰符：abstract 用的最多的就是：public C:成员变量： 权限修饰符：private，默认的，protected，public 状态修饰符：static，final 用的最多的就是：private D:构造方法： 权限修饰符：private，默认的，protected，public 用的最多的就是：public E:成员方法： 权限修饰符：private，默认的，protected，public 状态修饰符：static，final 抽象修饰符：abstract 用的最多的就是：public F:除此以外的组合规则： 成员变量：public static final 接口 成员方法： public static public abstract public final (内部类概述和访问特点)(了解) A:内部类概述 B:内部类访问特点 a:内部类可以直接访问外部类的成员，包括私有。 b:外部类要访问内部类的成员，必须创建对象。 外部类名.内部类名 对象名 = 外部类对象.内部类对象; C:案例演示 内部类极其访问特点 (成员内部类私有使用)(了解) private (静态成员内部类)(了解) static B:成员内部类被静态修饰后的访问方式是: 外部类名.内部类名 对象名 = 外部类名.内部类对象; (成员内部类的面试题)(掌握) A:面试题 要求：使用已知的变量，在控制台输出30，20，10。 class Outer { public int num = 10; class Inner { public int num = 20; public void show() { int num = 30; System.out.println(?); System.out.println(??); System.out.println(???); } } } class InnerClassTest { public static void main(String[] args) { Outer.Inner oi = new Outer().new Inner(); oi.show(); } } (局部内部类访问局部变量的问题)(掌握) A:案例演示 局部内部类访问局部变量必须用final修饰 局部内部类在访问他所在方法中的局部变量必须用final修饰,为什么? 因为当调用这个方法时,局部变量如果没有用final修饰,他的生命周期和方法的生命周期是一样的,当方法弹栈,这个局部变量也会消失,那么如果局部内部类对象还没有马上消失想用这个局部变量,就没有了,如果用final修饰会在类加载的时候进入常量池,即使方法弹栈,常量池的常量还在,也可以继续使用 但是jdk1.8取消了这个事情,所以我认为这是个bug,虽然取消,如果在书写代码时候,没有手动添加,系统底层也会默给你final (匿名内部类的格式和理解) A:匿名内部类 就是内部类的简化写法。 B:前提：存在一个类或者接口 这里的类可以是具体类也可以是抽象类。 C:格式： new 类名或者接口名(){ 重写方法; } D:本质是什么呢? 是一个继承了该类或者实现了该接口的子类匿名对象。 E:案例演示 按照要求来一个匿名内部类 (匿名内部类重写多个方法调用) A:案例演示 匿名内部类的方法调用 (匿名内部类在开发中的应用) A:代码如下 //这里写抽象类，接口都行 abstract class Person { public abstract void show(); } class PersonDemo { public void method(Person p) { p.show(); } } class PersonTest { public static void main(String[] args) { //如何调用PersonDemo中的method方法呢? PersonDemo pd = new PersonDemo (); } } (匿名内部类的面试题) A:面试题 按照要求，补齐代码 interface Inter { void show(); } class Outer { //补齐代码 } class OuterDemo { public static void main(String[] args) { Outer.method().show(); } } 要求在控制台输出”HelloWorld”","tags":[]},{"title":"Java_面向对象03（ 多态&抽象类&接口 ）【面向对象笔记】","date":"2019-10-23T08:17:29.382Z","path":"2019/10/23/Java_面向对象03（ 多态&抽象类&接口 ）【面向对象笔记】/","text":"(多态的概述及其代码体现) A:多态(polymorphic)概述 事物存在的多种形态 B:多态前提 a:要有继承关系。 b:要有方法重写。 c:要有父类引用指向子类对象。 C:案例演示 代码体现多态 (多态中的成员访问特点之成员变量) 成员变量 编译看左边(父类)，运行看左边(父类)。 (多态中的成员访问特点之成员方法) 成员方法 编译看左边(父类)，运行看右边(子类)。 (多态中的成员访问特点之静态成员方法) 静态方法 编译看左边(父类)，运行看左边(父类)。 (静态和类相关，算不上重写，所以，访问还是左边的) 只有非静态的成员方法,编译看左边,运行看右边 (多态中向上转型和向下转型) A:案例演示 详细讲解多态中向上转型和向下转型Person p = new SuperMan();向上转型SuperMan sm = (SuperMan)p;向下转型(多态的好处和弊端) A:多态的好处 a:提高了代码的维护性(继承保证) b:提高了代码的扩展性(由多态保证) B:案例演示 多态的好处 可以当作形式参数,可以接收任意子类对象 C:多态的弊端 不能使用子类的特有属性和行为。 (抽象类的概述及其特点) A:抽象类概述 抽象就是看不懂的 B:抽象类特点 a:抽象类和抽象方法必须用abstract关键字修饰 abstract class 类名 {} public abstract void eat(); b:抽象类不一定有抽象方法，有抽象方法的类一定是抽象类或者是接口 c:抽象类不能实例化那么，抽象类如何实例化呢? 按照多态的方式，由具体的子类实例化。其实这也是多态的一种，抽象类多态。 d:抽象类的子类 要么是抽象类 要么重写抽象类中的所有抽象方法 C:案例演示 抽象类特点B:抽象类特点 a:抽象类和抽象方法必须用abstract关键字修饰 abstract class 类名 {} public abstract void eat(); b:抽象类不一定有抽象方法，有抽象方法的类一定是抽象类或者是接口 c:抽象类不能实例化那么，抽象类如何实例化呢? 按照多态的方式，由具体的子类实例化。其实这也是多态的一种，抽象类多态。 d:抽象类的子类 要么是抽象类 要么重写抽象类中的所有抽象方法 (抽象类的成员特点) A:抽象类的成员特点 a:成员变量：既可以是变量，也可以是常量。abstract是否可以修饰成员变量?不能修饰成员变量 b:构造方法：有。 用于子类访问父类数据的初始化。 c:成员方法：既可以是抽象的，也可以是非抽象的。 B:案例演示 抽象类的成员特点 C:抽象类的成员方法特性： a:抽象方法 强制要求子类做的事情。 b:非抽象方法 子类继承的事情，提高代码复用性。 (接口的概述及其特点) A:接口概述 从狭义的角度讲就是指java中的interface 从广义的角度讲对外提供规则的都是接口 B:接口特点 a:接口用关键字interface表示 interface 接口名 {} b:类实现接口用implements表示 class 类名 implements 接口名 {} c:接口不能实例化 那么，接口如何实例化呢? 按照多态的方式来实例化。 d:接口的子类 a:可以是抽象类。但是意义不大。 b:可以是具体类。要重写接口中的所有抽象方法。(推荐方案) C:案例演示 接口特点面试题 一个抽象类如果没有抽象方法，可不可以定义为抽象类?如果可以，有什么意义? 可以 这么做目的只有一个,就是不让其他类创建本类对象,交给子类完成 abstract不能和哪些关键字共存？ abstract和static 被abstract修饰的方法没有方法体 被static修饰的可以用类名.调用,但是类名.调用抽象方法是没有意义的 abstract和final 被abstract修饰的方法强制子类重写 被final修饰的不让子类重写,所以他俩是矛盾 abstract和private 被abstract修饰的是为了让子类看到并强制重写 被private修饰不让子类访问,所以他俩是矛盾的(接口的成员特点) A:接口成员特点 成员变量；只能是常量，并且是静态的并公共的。* 默认修饰符：public static final * 建议：自己手动给出。 构造方法：接口没有构造方法。 成员方法：只能是抽象方法。* 默认修饰符：public abstract * 建议：自己手动给出。 B:案例演示 接口成员特点 (类与类,类与接口,接口与接口的关系) A:类与类,类与接口,接口与接口的关系 a:类与类： 继承关系,只能单继承,可以多层继承。 b:类与接口： 实现关系,可以单实现,也可以多实现。 并且还可以在继承一个类的同时实现多个接口。 c:接口与接口： 继承关系,可以单继承,也可以多继承。 B:案例演示 类与类,类与接口,接口与接口的关系 (抽象类和接口的区别) A:成员区别 抽象类： 成员变量：可以变量，也可以常量 构造方法：有 成员方法：可以抽象，也可以非抽象 接口： 成员变量：只可以常量 成员方法：只可以抽象 B:关系区别 类与类 继承，单继承 类与接口 实现，单实现，多实现 接口与接口 继承，单继承，多继承 C:设计理念区别 抽象类 被继承体现的是：”is a”的关系。抽象类中定义的是该继承体系的共性功能。 接口 被实现体现的是：”like a”的关系。接口中定义的是该继承体系的扩展功能。","tags":[]},{"title":"Java_面向对象02（ 继承&方法&final) ）【面向对象笔记】","date":"2019-10-23T08:17:29.380Z","path":"2019/10/23/Java_面向对象02（ 继承&方法&final) ）【面向对象笔记】/","text":"(代码块的概述和分类)(了解)(面试的时候会问,开发不用或者很少用) A:代码块概述 在Java中，使用{}括起来的代码被称为代码块。 B:代码块分类 根据其位置和声明的不同，可以分为局部代码块，构造代码块，静态代码块，同步代码块(多线程讲解)。 C:常见代码块的应用 a:局部代码块 在方法中出现；限定变量生命周期，及早释放，提高内存利用率 b:构造代码块 (初始化块) 在类中方法外出现；多个构造方法方法中相同的代码存放到一起，每次调用构造都执行，并且在构造方法前执行 c:静态代码块 在类中方法外出现，并加上static修饰；用于给类进行初始化，在加载的时候就执行，并且只执行一次。 一般用于加载驱动 (继承的好处和弊端)(掌握) A:继承的好处 a:提高了代码的复用性 b:提高了代码的维护性 c:让类与类之间产生了关系，是多态的前提 B:继承的弊端 类的耦合性增强了。 开发的原则：高内聚，低耦合。 耦合：类与类的关系 内聚：就是自己完成某件事情的能力 (Java中类的继承特点)(掌握) A:Java中类的继承特点 a:Java只支持单继承，不支持多继承。(一个儿子只能有一个爹) 有些语言是支持多继承，格式：extends 类1,类2,… b:Java支持多层继承(继承体系) B:案例演示 Java中类的继承特点 如果想用这个体系的所有功能用最底层的类创建对象 如果想看这个体系的共性功能,看最顶层的类 (继承的注意事项和什么时候使用继承)(掌握) A:继承的注意事项 a:子类只能继承父类所有非私有的成员(成员方法和成员变量) b:子类不能继承父类的构造方法，但是可以通过super(马上讲)关键字去访问父类构造方法。 c:不要为了部分功能而去继承 项目经理 姓名 工号 工资 奖金 程序员 姓名 工号 工资 B:什么时候使用继承 继承其实体现的是一种关系：”is a”。 Person Student Teacher 水果 苹果 香蕉 橘子采用假设法。 如果有两个类A,B。只有他们符合A是B的一种，或者B是A的一种，就可以考虑使用继承。 (继承中成员变量的关系)(掌握) A:案例演示 a:不同名的变量 b:同名的变量(this和super的区别和应用)(掌握) A:this和super都代表什么 this:代表当前对象的引用,谁来调用我,我就代表谁 super:代表当前对象父类的引用 B:this和super的使用区别 a:调用成员变量 this.成员变量 调用本类的成员变量,也可以调用父类的成员变量 super.成员变量 调用父类的成员变量 b:调用构造方法 this(…) 调用本类的构造方法 super(…) 调用父类的构造方法 c:调用成员方法 this.成员方法 调用本类的成员方法,也可以调用父类的方法 super.成员方法 调用父类的成员方法 (继承中构造方法的关系)(掌握) A:案例演示 子类中所有的构造方法默认都会访问父类中空参数的构造方法 B:为什么呢? 因为子类会继承父类中的数据，可能还会使用父类的数据。 所以，子类初始化之前，一定要先完成父类数据的初始化。 其实： 每一个构造方法的第一条语句默认都是：super() Object类最顶层的父类。 (继承中构造方法的注意事项)(掌握) A:案例演示 父类没有无参构造方法,子类怎么办? super解决 this解决 B:注意事项 super(…)或者this(….)必须出现在构造方法的第一条语句上 (继承中成员方法关系)(掌握) A:案例演示 a:不同名的方法 b:同名的方法 (方法重写概述及其应用)(掌握) A:什么是方法重写 重写:子父类出现了一模一样的方法(注意:返回值类型可以是子父类,这个我们学完面向对象讲) B:方法重写的应用： 当子类需要父类的功能，而功能主体子类有自己特有内容时，可以重写父类中的方法。这样，即沿袭了父类的功能，又定义了子类特有的内容。 C:案例演示 a:定义一个手机类。 (方法重写的注意事项)(掌握) A:方法重写注意事项 a:父类中私有方法不能被重写 因为父类私有方法子类根本就无法继承 b:子类重写父类方法时，访问权限不能更低 最好就一致 c:父类静态方法，子类也必须通过静态方法进行重写 其实这个算不上方法重写，但是现象确实如此，至于为什么算不上方法重写，多态中我会讲解(静态只能覆盖静态) 子类重写父类方法的时候，最好声明一模一样。 B:案例演示 方法重写注意事项 (方法重写的面试题)(掌握) A:方法重写的面试题 Override和Overload的区别?Overload能改变返回值类型吗? overload可以改变返回值类型,只看参数列表 方法重写：子类中出现了和父类中方法声明一模一样的方法。与返回值类型有关,返回值是一致(或者是子父类)的 方法重载：本类中出现的方法名一样，参数列表不同的方法。与返回值类型无关。 子类对象调用方法的时候： 先找子类本身，再找父类。 (final关键字修饰类,方法以及变量的特点)(掌握) A:final概述 B:final修饰特点 修饰类，类不能被继承 修饰变量，变量就变成了常量，只能被赋值一次 修饰方法，方法不能被重写 C:案例演示 final修饰特点 (final关键字修饰局部变量)(掌握) A:案例演示 方法内部或者方法声明上都演示一下(了解) 基本类型，是值不能被改变 引用类型，是地址值不能被改变,对象中的属性可以改变 (final修饰变量的初始化时机)(掌握) A:final修饰变量的初始化时机 显示初始化 在对象构造完毕前即可","tags":[]},{"title":"Java_面向对象01（ 构造方法、静态static ）【面向对象笔记】","date":"2019-10-23T08:17:29.378Z","path":"2019/10/23/Java_面向对象01（ 构造方法、静态static ）【面向对象笔记】/","text":"(构造方法Constructor概述和格式)(掌握) A:构造方法概述和作用 给对象的数据(属性)进行初始化 B:构造方法格式特点 a:方法名与类名相同(大小也要与类名一致) b:没有返回值类型，连void都没有 c:没有具体的返回值return; (构造方法的重载及注意事项)(掌握) A:案例演示 构造方法的重载 重载:方法名相同,与返回值类型无关(构造方法没有返回值),只看参数列表 B:构造方法注意事项 a:如果我们没有给出构造方法，系统将自动提供一个无参构造方法。 b:如果我们给出了构造方法，系统将不再提供默认的无参构造方法。 注意：这个时候，如果我们还想使用无参构造方法，就必须自己给出。建议永远自己给出无参构造方法 (给成员变量赋值的两种方式的区别) A:setXxx()方法 修改属性值 B:构造方法 给对象中属性进行初始化 (创建一个对象的步骤)(掌握) A:画图演示 画图说明一个对象的创建过程做了哪些事情? Student s = new Student(); 1,Student.class加载进内存 2,声明一个Student类型引用s 3,在堆内存创建对象, 4,给对象中属性默认初始化值 5,属性进行显示初始化 6,构造方法进栈,对对象中的属性赋值,构造方法弹栈 7,将对象的地址值赋值给s (长方形案例练习)(掌握) A:案例演示 需求： 定义一个长方形类,定义 求周长和面积的方法， 然后定义一个测试类进行测试。 (员工类案例练习)(掌握) A:案例演示 需求：定义一个员工类Employee 自己分析出几个成员，然后给出成员变量 姓名name,工号id,工资salary 构造方法， 空参和有参的 getXxx()setXxx()方法， 以及一个显示所有成员信息的方法。并测试。 work (static关键字的特点)(掌握) A:static关键字的特点 a:随着类的加载而加载 b:优先于对象存在 c:被类的所有对象共享 举例：咱们班级的学生应该共用同一个班级编号。 其实这个特点也是在告诉我们什么时候使用静态? 如果某个成员变量是被所有对象共享的，那么它就应该定义为静态的。 举例： 饮水机(用静态修饰) 水杯(不能用静态修饰) 共性用静态,特性用非静态 d:可以通过类名调用 其实它本身也可以通过对象名调用。 推荐使用类名调用。 静态修饰的内容一般我们称其为：与类相关的，类成员 B:案例演示 static关键字的特点 (static的注意事项)(掌握) A:static的注意事项 a:在静态方法中是没有this关键字的 如何理解呢? 静态是随着类的加载而加载，this是随着对象的创建而存在。 静态比对象先存在。 b:静态方法只能访问静态的成员变量和静态的成员方法 静态方法： 成员变量：只能访问静态变量 成员方法：只能访问静态成员方法 非静态方法： 成员变量：可以是静态的，也可以是非静态的 成员方法：可是是静态的成员方法，也可以是非静态的成员方法。 简单记： 静态只能访问静态。 B:案例演示 static的注意事项 (静态变量和成员变量的区别)(掌握) 静态变量也叫类变量 成员变量也叫对象变量 A:所属不同 静态变量属于类，所以也称为为类变量 成员变量属于对象，所以也称为实例变量(对象变量) B:内存中位置不同 静态变量存储于方法区的静态区 成员变量存储于堆内存 C:内存出现时间不同 静态变量随着类的加载而加载，随着类的消失而消失 成员变量随着对象的创建而存在，随着对象的消失而消失 D:调用不同 静态变量可以通过类名调用，也可以通过对象调用 成员变量只能通过对 象名调用 (main方法的格式详细解释)(了解) A:格式 public static void main(String[] args) {} B:针对格式的解释 public 被jvm调用，访问权限足够大。 static 被jvm调用，不用创建对象，直接类名访问 void被jvm调用，不需要给jvm返回值 main 一个通用的名称，虽然不是关键字，但是被jvm识别 String[] args 以前用于接收键盘录入的 C:演示案例 通过args接收键盘例如数据 (工具类中使用静态)(了解) A:制作一个工具类 ArrayTool 1,获取最大值 2,数组的遍历 3,数组的反转 (说明书的制作过程)(了解) A:对工具类加入文档注释 B:通过javadoc命令生成说明书 @author(提取作者内容) @version(提取版本内容) javadoc -d 指定的文件目录 -author -version ArrayTool.java @param 参数名称//形式参数的变量名称@return 函数运行完返回的数据 (使用JDK提供的帮助文档)(了解) A:找到文档，打开文档 B:点击显示，找到索引，出现输入框 C:你应该知道你找谁?举例：Scanner D:看这个类的结构(需不需要导包) 成员变量 字段 构造方法 构造方法 成员方法 方法 (Math类的随机数功能)(了解) 打开JDK提供的帮助文档学习 A:Math类概述 类包含用于执行基本数学运算的方法 B:Math类特点 由于Math类在java.lang包下，所以不需要导包。 因为它的成员全部是静态的,所以私有了构造方法 C:获取随机数的方法 public static double random():返回带正号的 double 值，该值大于等于 0.0 且小于 1.0。 D:我要获取一个1-100之间的随机数 int number = (int)(Math.random()*100)+1;","tags":[]},{"title":"IO流 【超完整】","date":"2019-10-23T08:17:29.376Z","path":"2019/10/23/IO流 【超完整】/","text":"文章较长，建议从目录选取感兴趣内容，然后Ctry+F搜索、跳转 目录01_IO流(IO流概述及其分类)02_IO流(FileInputStream)03_IO流(read()方法返回值为什么是int)04_IO流(FileOutputStream)05_IO流(FileOutputStream追加)06_IO流(拷贝图片)07_IO流(拷贝音频文件画原理图)08_IO流(字节数组拷贝之available()方法)09_IO流(定义小数组)10_IO流(定义小数组的标准格式)11_IO流(BufferedInputStream和BufferOutputStream拷贝)12_IO流(flush和close方法的区别)13_IO流(字节流读写中文)14_IO流(流的标准处理异常代码1.6版本及其以前)15_IO流(流的标准处理异常代码1.7版本)16_IO流(图片加密)17_IO流(拷贝文件)18_IO流(录入数据拷贝到文件)19_IO流(字符流FileReader)20_IO流(字符流FileWriter)21_IO流(什么情况下使用字符流)22_IO流(自定义字符数组的拷贝)23_IO流(带缓冲的字符流)24_IO流(readLine()和newLine()方法)25_IO流(将文本反转)26_IO流(装饰设计模式)27_IO流(使用指定的码表读写字符)28_IO流(转换流图解)29_IO流(获取文本上字符出现的次数)&amp;&amp;(试用版软件)30_File类(练习)31_IO流(总结)32_IO流(序列流)(了解)33_IO流(序列流整合多个)(了解)34_IO流(内存输出流)(掌握)35_IO流(内存输出流之黑马面试题)(掌握)36_IO流(随机访问流概述和读写数据)(了解)37_IO流(对象操作流ObjecOutputStream)(了解)38_IO流(对象操作流ObjectInputStream)(了解)39_IO流(对象操作流优化)(了解)40_IO流(加上id号)(了解)41_IO流(数据输入输出流)(了解)42_IO流(打印流的概述和特点)(掌握)43_IO流(标准输入输出流概述和输出语句)44_IO流(修改标准输入输出流拷贝图片)(了解)45_IO流(两种方式实现键盘录入)(了解)46_IO流(Properties的特殊功能使用)(了解)47_IO流(Properties的load()和store()功能)(了解)——————————————————–正文—————————————————————- 01_IO流(IO流概述及其分类) 1.概念 IO流用来处理设备之间的数据传输 Java对数据的操作是通过流的方式 Java用于操作流的类都在IO包中 流按流向分为两种：输入流，输出流。 流按操作类型分为两种： 字节流 : 字节流可以操作任何数据,因为在计算机中任何数据都是以字节的形式存储的 字符流 : 字符流只能操作纯字符数据，比较方便。 2.IO流常用父类 字节流的抽象父类： InputStream OutputStream 字符流的抽象父类： Reader Writer 3.IO程序书写 使用前，导入IO包中的类 使用时，进行IO异常处理 使用后，释放资源 02_IO流(FileInputStream) read()一次读取一个字节 FileInputStream fis = new FileInputStream(&quot;aaa.txt&quot;); //创建一个文件输入流对象,并关联aaa.txt int b; //定义变量,记录每次读到的字节 while((b = fis.read()) != -1) { //将每次读到的字节赋值给b并判断是否是-1 System.out.println(b); //打印每一个字节 } fis.close(); //关闭流释放资源03_IO流(read()方法返回值为什么是int) read()方法读取的是一个字节,为什么返回是int,而不是byte 因为字节输入流可以操作任意类型的文件,比如图片音频等,这些文件底层都是以二进制形式的存储的,如果每次读取都返回byte,有可能在读到中间的时候遇到111111111 那么这11111111是byte类型的-1,我们的程序是遇到-1就会停止不读了,后面的数据就读不到了,所以在读取的时候用int类型接收,如果11111111会在其前面补上 24个0凑足4个字节,那么byte类型的-1就变成int类型的255了这样可以保证整个数据读完,而结束标记的-1就是int类型04_IO流(FileOutputStream) write()一次写出一个字节 FileOutputStream fos = new FileOutputStream(&quot;bbb.txt&quot;); //如果没有bbb.txt,会创建出一个 //fos.write(97); //虽然写出的是一个int数,但是在写出的时候会将前面的24个0去掉,所以写出的是一个byte fos.write(98); fos.write(99); fos.close();05_IO流(FileOutputStream追加) A:案例演示 FileOutputStream的构造方法写出数据如何实现数据的追加写入 FileOutputStream fos = new FileOutputStream(&quot;bbb.txt&quot;,true); //如果没有bbb.txt,会创建出一个 //fos.write(97); //虽然写出的是一个int数,但是在写出的时候会将前面的24个0去掉,所以写出的一个byte fos.write(98); fos.write(99); fos.close(); 06_IO流(拷贝图片) FileInputStream读取 FileOutputStream写出 FileInputStream fis = new FileInputStream(&quot;致青春.mp3&quot;); //创建输入流对象,关联致青春.mp3 FileOutputStream fos = new FileOutputStream(&quot;copy.mp3&quot;);//创建输出流对象,关联copy.mp3 int b; while((b = fis.read()) != -1) { fos.write(b); } fis.close(); fos.close(); 07_IO流(拷贝音频文件画原理图) A:案例演示 字节流一次读写一个字节复制音频 弊端:效率太低 08_IO流(字节数组拷贝之available()方法) A:案例演示 int read(byte[] b):一次读取一个字节数组 write(byte[] b):一次写出一个字节数组 available()获取读的文件所有的字节个数 弊端:有可能会内存溢出 FileInputStream fis = new FileInputStream(&quot;致青春.mp3&quot;); FileOutputStream fos = new FileOutputStream(&quot;copy.mp3&quot;); byte[] arr = new byte[fis.available()]; //根据文件大小做一个字节数组 fis.read(arr); //将文件上的所有字节读取到数组中 fos.write(arr); //将数组中的所有字节一次写到了文件上 fis.close(); fos.close(); 09_IO流(定义小数组) write(byte[] b) write(byte[] b, int off, int len)写出有效的字节个数 10_IO流(定义小数组的标准格式) A:案例演示 字节流一次读写一个字节数组复制图片和视频 FileInputStream fis = new FileInputStream(“致青春.mp3”); FileOutputStream fos = new FileOutputStream(“copy.mp3”); int len; byte[] arr = new byte[1024 * 8]; //自定义字节数组 while((len = fis.read(arr)) != -1) { //fos.write(arr); fos.write(arr, 0, len); //写出字节数组写出有效个字节个数 } fis.close(); fos.close(); 11_IO流(BufferedInputStream和BufferOutputStream拷贝) A:缓冲思想 字节流一次读写一个数组的速度明显比一次读写一个字节的速度快很多， 这是加入了数组这样的缓冲区效果，java本身在设计的时候， 也考虑到了这样的设计思想(装饰设计模式后面讲解)，所以提供了字节缓冲区流 B.BufferedInputStream BufferedInputStream内置了一个缓冲区(数组) 从BufferedInputStream中读取一个字节时 BufferedInputStream会一次性从文件中读取8192个, 存在缓冲区中, 返回给程序一个 程序再次读取时, 就不用找文件了, 直接从缓冲区中获取 直到缓冲区中所有的都被使用过, 才重新从文件中读取8192个 C.BufferedOutputStream BufferedOutputStream也内置了一个缓冲区(数组) 程序向流中写出字节时, 不会直接写到文件, 先写到缓冲区中 直到缓冲区写满, BufferedOutputStream才会把缓冲区中的数据一次性写到文件里 D.拷贝的代码 FileInputStream fis = new FileInputStream(&quot;致青春.mp3&quot;); //创建文件输入流对象,关联致青春.mp3 BufferedInputStream bis = new BufferedInputStream(fis); //创建缓冲区对fis装饰 FileOutputStream fos = new FileOutputStream(&quot;copy.mp3&quot;); //创建输出流对象,关联copy.mp3 BufferedOutputStream bos = new BufferedOutputStream(fos); //创建缓冲区对fos装饰 int b; while((b = bis.read()) != -1) { bos.write(b); } bis.close(); //只关装饰后的对象即可 bos.close(); E.小数组的读写和带Buffered的读取哪个更快? 定义小数组如果是8192个字节大小和Buffered比较的话 定义小数组会略胜一筹,因为读和写操作的是同一个数组 而Buffered操作的是两个数组 12_IO流(flush和close方法的区别) flush()方法 用来刷新缓冲区的,刷新后可以再次写出 close()方法 用来关闭流释放资源的的,如果是带缓冲区的流对象的close()方法,不但会关闭流,还会再关闭流之前刷新缓冲区,关闭后不能再写出 13_IO流(字节流读写中文) 字节流读取中文的问题 字节流在读中文的时候有可能会读到半个中文,造成乱码 字节流写出中文的问题 字节流直接操作的字节,所以写出中文必须将字符串转换成字节数组 写出回车换行 write(“\\r\\n”.getBytes()); 14_IO流(流的标准处理异常代码1.6版本及其以前) try finally嵌套 FileInputStream fis = null; FileOutputStream fos = null; try { fis = new FileInputStream(&quot;aaa.txt&quot;); fos = new FileOutputStream(&quot;bbb.txt&quot;); int b; while((b = fis.read()) != -1) { fos.write(b); } } finally { try { if(fis != null) fis.close(); }finally { if(fos != null) fos.close(); } } 15_IO流(流的标准处理异常代码1.7版本) try close try( FileInputStream fis = new FileInputStream(&quot;aaa.txt&quot;); FileOutputStream fos = new FileOutputStream(&quot;bbb.txt&quot;); MyClose mc = new MyClose(); ){ int b; while((b = fis.read()) != -1) { fos.write(b); } } 原理 在try()中创建的流对象必须实现了AutoCloseable这个接口,如果实现了,在try后面的{}(读写代码)执行后就会自动调用,流对象的close方法将流关掉 16_IO流(图片加密) 给图片加密 BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;a.jpg&quot;)); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;b.jpg&quot;)); int b; while((b = bis.read()) != -1) { bos.write(b ^ 123); } bis.close(); bos.close(); 17_IO流(拷贝文件) 在控制台录入文件的路径,将文件拷贝到当前项目下 Scanner sc = new Scanner(System.in); System.out.println(&quot;请输入一个文件路径&quot;); String line = sc.nextLine(); //将键盘录入的文件路径存储在line中 File file = new File(line); //封装成File对象 FileInputStream fis = new FileInputStream(file); FileOutputStream fos = new FileOutputStream(file.getName()); int len; byte[] arr = new byte[8192]; //定义缓冲区 while((len = fis.read(arr)) != -1) { fos.write(arr,0,len); } fis.close(); fos.close(); 18_IO流(录入数据拷贝到文件) 将键盘录入的数据拷贝到当前项目下的text.txt文件中,键盘录入数据当遇到quit时就退出 Scanner sc = new Scanner(System.in); FileOutputStream fos = new FileOutputStream(&quot;text.txt&quot;); System.out.println(&quot;请输入:&quot;); while(true) { String line = sc.nextLine(); if(&quot;quit&quot;.equals(line)) break; fos.write(line.getBytes()); fos.write(&quot;\\r\\n&quot;.getBytes()); } fos.close(); 19_IO流(字符流FileReader) 1.字符流是什么 字符流是可以直接读写字符的IO流 字符流读取字符, 就要先读取到字节数据, 然后转为字符. 如果要写出字符, 需要把字符转为字节再写出. 2.FileReader FileReader类的read()方法可以按照字符大小读取 FileReader fr = new FileReader(&quot;aaa.txt&quot;); //创建输入流对象,关联aaa.txt int ch; while((ch = fr.read()) != -1) { //将读到的字符赋值给ch System.out.println((char)ch); //将读到的字符强转后打印 } fr.close(); //关流 20_IO流(字符流FileWriter) FileWriter类的write()方法可以自动把字符转为字节写出 FileWriter fw = new FileWriter(&quot;aaa.txt&quot;); fw.write(&quot;aaa&quot;); fw.close(); ###21.03_IO流(字符流的拷贝) FileReader fr = new FileReader(“a.txt”); FileWriter fw = new FileWriter(“b.txt”); int ch; while((ch = fr.read()) != -1) { fw.write(ch); } fr.close(); fw.close();21_IO流(什么情况下使用字符流) 字符流也可以拷贝文本文件, 但不推荐使用. 因为读取时会把字节转为字符, 写出时还要把字符转回字节. 程序需要读取一段文本, 或者需要写出一段文本的时候可以使用字符流 读取的时候是按照字符的大小读取的,不会出现半个中文 写出的时候可以直接将字符串写出,不用转换为字节数组 ###21.05_IO流(字符流是否可以拷贝非纯文本的文件) 不可以拷贝非纯文本的文件 因为在读的时候会将字节转换为字符,在转换过程中,可能找不到对应的字符,就会用?代替,写出的时候会将字符转换成字节写出去 如果是?,直接写出,这样写出之后的文件就乱了,看不了了 22_IO流(自定义字符数组的拷贝) FileReader fr = new FileReader(“aaa.txt”); //创建字符输入流,关联aaa.txt FileWriter fw = new FileWriter(“bbb.txt”); //创建字符输出流,关联bbb.txt int len; char[] arr = new char[1024*8]; //创建字符数组 while((len = fr.read(arr)) != -1) { //将数据读到字符数组中 fw.write(arr, 0, len); //从字符数组将数据写到文件上 } fr.close(); //关流释放资源 fw.close(); 23_IO流(带缓冲的字符流) BufferedReader的read()方法读取字符时会一次读取若干字符到缓冲区, 然后逐个返回给程序, 降低读取文件的次数, 提高效率 BufferedWriter的write()方法写出字符时会先写到缓冲区, 缓冲区写满时才会写到文件, 降低写文件的次数, 提高效率 BufferedReader br = new BufferedReader(new FileReader(&quot;aaa.txt&quot;)); //创建字符输入流对象,关联aaa.txt BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;bbb.txt&quot;)); //创建字符输出流对象,关联bbb.txt int ch; while((ch = br.read()) != -1) { //read一次,会先将缓冲区读满,从缓冲去中一个一个的返给临时变量ch bw.write(ch); //write一次,是将数据装到字符数组,装满后再一起写出去 } br.close(); //关流 bw.close(); 24_IO流(readLine()和newLine()方法) BufferedReader的readLine()方法可以读取一行字符(不包含换行符号) BufferedWriter的newLine()可以输出一个跨平台的换行符号”\\r\\n” BufferedReader br = new BufferedReader(new FileReader(&quot;aaa.txt&quot;)); BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;bbb.txt&quot;)); String line; while((line = br.readLine()) != null) { bw.write(line); //bw.write(&quot;\\r\\n&quot;); //只支持windows系统 bw.newLine(); //跨平台的 } br.close(); bw.close(); 25_IO流(将文本反转) 将一个文本文档上的文本反转,第一行和倒数第一行交换,第二行和倒数第二行交换 ###21.10_IO流(LineNumberReader) LineNumberReader是BufferedReader的子类, 具有相同的功能, 并且可以统计行号 调用getLineNumber()方法可以获取当前行号 调用setLineNumber()方法可以设置当前行号 LineNumberReader lnr = new LineNumberReader(new FileReader(&quot;aaa.txt&quot;)); String line; lnr.setLineNumber(100); //设置行号 while((line = lnr.readLine()) != null) { System.out.println(lnr.getLineNumber() + &quot;:&quot; + line);//获取行号 } lnr.close(); 26_IO流(装饰设计模式) interface Coder { public void code(); } class Student implements Coder { @Override public void code() { System.out.println(&quot;javase&quot;); System.out.println(&quot;javaweb&quot;); } } class HeiMaStudent implements Coder { private Student s; //获取到被包装的类的引用 public HeiMaStudent(Student s) { //通过构造函数创建对象的时候,传入被包装的对象 this.s = s; } @Override public void code() { //对其原有功能进行升级 s.code(); System.out.println(&quot;数据库&quot;); System.out.println(&quot;ssh&quot;); System.out.println(&quot;安卓&quot;); System.out.println(&quot;.....&quot;); } } 27_IO流(使用指定的码表读写字符) FileReader是使用默认码表读取文件, 如果需要使用指定码表读取, 那么可以使用InputStreamReader(字节流,编码表) FileWriter是使用默认码表写出文件, 如果需要使用指定码表写出, 那么可以使用OutputStreamWriter(字节流,编码表) BufferedReader br = //高效的用指定的编码表读 new BufferedReader(new InputStreamReader(new FileInputStream(&quot;UTF-8.txt&quot;), &quot;UTF-8&quot;)); BufferedWriter bw = //高效的用指定的编码表写 new BufferedWriter(new OutputStreamWriter(new FileOutputStream(&quot;GBK.txt&quot;), &quot;GBK&quot;)); int ch; while((ch = br.read()) != -1) { bw.write(ch); } br.close(); bw.close();28_IO流(转换流图解) 29_IO流(获取文本上字符出现的次数)&amp;&amp;(试用版软件) 获取一个文本上每个字符出现的次数,将结果写在times.txt上 当我们下载一个试用版软件,没有购买正版的时候,每执行一次就会提醒我们还有多少次使用机会用学过的IO流知识,模拟试用版软件,试用10次机会,执行一次就提示一次您还有几次机会,如果次数到了提示请购买正版 30_File类(练习) 需求:从键盘输入接收一个文件夹路径,打印出该文件夹下所有的.java文件名 31_IO流(总结) 1.会用BufferedReader读取GBK码表和UTF-8码表的字符 2.会用BufferedWriter写出字符到GBK码表和UTF-8码表的文件中 3.会使用BufferedReader从键盘读取一行 32_IO流(序列流)(了解) 1.什么是序列流 序列流可以把多个字节输入流整合成一个, 从序列流中读取数据时, 将从被整合的第一个流开始读, 读完一个之后继续读第二个, 以此类推. 2.使用方式 整合两个: SequenceInputStream(InputStream, InputStream) FileInputStream fis1 = new FileInputStream(&quot;a.txt&quot;); //创建输入流对象,关联a.txt FileInputStream fis2 = new FileInputStream(&quot;b.txt&quot;); //创建输入流对象,关联b.txt SequenceInputStream sis = new SequenceInputStream(fis1, fis2); //将两个流整合成一个流 FileOutputStream fos = new FileOutputStream(&quot;c.txt&quot;); //创建输出流对象,关联c.txt int b; while((b = sis.read()) != -1) { //用整合后的读 fos.write(b); //写到指定文件上 } sis.close(); fos.close(); 33_IO流(序列流整合多个)(了解) 整合多个: SequenceInputStream(Enumeration) FileInputStream fis1 = new FileInputStream(&quot;a.txt&quot;); //创建输入流对象,关联a.txt FileInputStream fis2 = new FileInputStream(&quot;b.txt&quot;); //创建输入流对象,关联b.txt FileInputStream fis3 = new FileInputStream(&quot;c.txt&quot;); //创建输入流对象,关联c.txt Vector&lt;InputStream&gt; v = new Vector&lt;&gt;(); //创建vector集合对象 v.add(fis1); //将流对象添加 v.add(fis2); v.add(fis3); Enumeration&lt;InputStream&gt; en = v.elements(); //获取枚举引用 SequenceInputStream sis = new SequenceInputStream(en); //传递给SequenceInputStream构造 FileOutputStream fos = new FileOutputStream(&quot;d.txt&quot;); int b; while((b = sis.read()) != -1) { fos.write(b); } sis.close(); fos.close(); 34_IO流(内存输出流*****)(掌握) 1.什么是内存输出流 该输出流可以向内存中写数据, 把内存当作一个缓冲区, 写出之后可以一次性获取出所有数据 2.使用方式 创建对象: new ByteArrayOutputStream() 写出数据: write(int), write(byte[]) 获取数据: toByteArray() FileInputStream fis = new FileInputStream(&quot;a.txt&quot;); ByteArrayOutputStream baos = new ByteArrayOutputStream(); int b; while((b = fis.read()) != -1) { baos.write(b); } //byte[] newArr = baos.toByteArray(); //将内存缓冲区中所有的字节存储在newArr中 //System.out.println(new String(newArr)); System.out.println(baos); fis.close();35_IO流(内存输出流之黑马面试题)(掌握) 定义一个文件输入流,调用read(byte[] b)方法,将a.txt文件中的内容打印出来(byte数组大小限制为5) FileInputStream fis = new FileInputStream(&quot;a.txt&quot;); //创建字节输入流,关联a.txt ByteArrayOutputStream baos = new ByteArrayOutputStream(); //创建内存输出流 byte[] arr = new byte[5]; //创建字节数组,大小为5 int len; while((len = fis.read(arr)) != -1) { //将文件上的数据读到字节数组中 baos.write(arr, 0, len); //将字节数组的数据写到内存缓冲区中 } System.out.println(baos); //将内存缓冲区的内容转换为字符串打印 fis.close();36_IO流(随机访问流概述和读写数据)(了解) A:随机访问流概述 RandomAccessFile概述 RandomAccessFile类不属于流，是Object类的子类。但它融合了InputStream和OutputStream的功能。 支持对随机访问文件的读取和写入。 B:read(),write(),seek() 37_IO流(对象操作流ObjecOutputStream)(了解) 1.什么是对象操作流 该流可以将一个对象写出, 或者读取一个对象到程序中. 也就是执行了序列化和反序列化的操作. 2.使用方式 写出: new ObjectOutputStream(OutputStream), writeObject() public class Demo3_ObjectOutputStream { /** * @param args * @throws IOException * 将对象写出,序列化 */ public static void main(String[] args) throws IOException { Person p1 = new Person(&quot;张三&quot;, 23); Person p2 = new Person(&quot;李四&quot;, 24); // FileOutputStream fos = new FileOutputStream(&quot;e.txt&quot;); // fos.write(p1); // FileWriter fw = new FileWriter(&quot;e.txt&quot;); // fw.write(p1); //无论是字节输出流,还是字符输出流都不能直接写出对象 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;e.txt&quot;));//创建对象输出流 oos.writeObject(p1); oos.writeObject(p2); oos.close(); } }38_IO流(对象操作流ObjectInputStream)(了解) 读取: new ObjectInputStream(InputStream), readObject() public class Demo3_ObjectInputStream { /** * @param args * @throws IOException * @throws ClassNotFoundException * @throws FileNotFoundException * 读取对象,反序列化 */ public static void main(String[] args) throws IOException, ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;e.txt&quot;)); Person p1 = (Person) ois.readObject(); Person p2 = (Person) ois.readObject(); System.out.println(p1); System.out.println(p2); ois.close(); } } 39_IO流(对象操作流优化)(了解)* 将对象存储在集合中写出 Person p1 = new Person(&quot;张三&quot;, 23); Person p2 = new Person(&quot;李四&quot;, 24); Person p3 = new Person(&quot;马哥&quot;, 18); Person p4 = new Person(&quot;辉哥&quot;, 20); ArrayList&lt;Person&gt; list = new ArrayList&lt;&gt;(); list.add(p1); list.add(p2); list.add(p3); list.add(p4); ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;f.txt&quot;)); oos.writeObject(list); //写出集合对象 oos.close(); 读取到的是一个集合对象 ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;f.txt&quot;)); ArrayList&lt;Person&gt; list = (ArrayList&lt;Person&gt;)ois.readObject(); //泛型在运行期会被擦除,索引运行期相当于没有泛型 //想去掉黄色可以加注解 @SuppressWarnings(&quot;unchecked&quot;) for (Person person : list) { System.out.println(person); } ois.close();40_IO流(加上id号)(了解) 注意 要写出的对象必须实现Serializable接口才能被序列化 不用必须加id号 41_IO流(数据输入输出流)(了解) 1.什么是数据输入输出流 DataInputStream, DataOutputStream可以按照基本数据类型大小读写数据 例如按Long大小写出一个数字, 写出时该数据占8字节. 读取的时候也可以按照Long类型读取, 一次读取8个字节. 2.使用方式 DataOutputStream(OutputStream), writeInt(), writeLong() DataOutputStream dos = new DataOutputStream(new FileOutputStream(&quot;b.txt&quot;)); dos.writeInt(997); dos.writeInt(998); dos.writeInt(999); dos.close(); DataInputStream(InputStream), readInt(), readLong() DataInputStream dis = new DataInputStream(new FileInputStream(&quot;b.txt&quot;)); int x = dis.readInt(); int y = dis.readInt(); int z = dis.readInt(); System.out.println(x); System.out.println(y); System.out.println(z); dis.close(); 42_IO流(打印流的概述和特点)(掌握) 1.什么是打印流 该流可以很方便的将对象的toString()结果输出, 并且自动加上换行, 而且可以使用自动刷出的模式 System.out就是一个PrintStream, 其默认向控制台输出信息 PrintStream ps = System.out; ps.println(97); //其实底层用的是Integer.toString(x),将x转换为数字字符串打印 ps.println(&quot;xxx&quot;); ps.println(new Person(&quot;张三&quot;, 23)); Person p = null; ps.println(p); //如果是null,就返回null,如果不是null,就调用对象的toString() 2.使用方式 打印: print(), println() 自动刷出: PrintWriter(OutputStream out, boolean autoFlush, String encoding) 打印流只操作数据目的 PrintWriter pw = new PrintWriter(new FileOutputStream(&quot;g.txt&quot;), true); pw.write(97); pw.print(&quot;大家好&quot;); pw.println(&quot;你好&quot;); //自动刷出,只针对的是println方法 pw.close(); 43_IO流(标准输入输出流概述和输出语句) 1.什么是标准输入输出流(掌握) System.in是InputStream, 标准输入流, 默认可以从键盘输入读取字节数据 System.out是PrintStream, 标准输出流, 默认可以向Console中输出字符和字节数据 2.修改标准输入输出流(了解) 修改输入流: System.setIn(InputStream) 修改输出流: System.setOut(PrintStream) System.setIn(new FileInputStream(&quot;a.txt&quot;)); //修改标准输入流 System.setOut(new PrintStream(&quot;b.txt&quot;)); //修改标准输出流 InputStream in = System.in; //获取标准输入流 PrintStream ps = System.out; //获取标准输出流 int b; while((b = in.read()) != -1) { //从a.txt上读取数据 ps.write(b); //将数据写到b.txt上 } in.close(); ps.close(); 44_IO流(修改标准输入输出流拷贝图片)(了解)System.setIn(new FileInputStream(&quot;IO图片.png&quot;)); //改变标准输入流 System.setOut(new PrintStream(&quot;copy.png&quot;)); //改变标准输出流 InputStream is = System.in; //获取标准输入流 PrintStream ps = System.out; //获取标准输出流 int len; byte[] arr = new byte[1024 * 8]; while((len = is.read(arr)) != -1) { ps.write(arr, 0, len); } is.close(); ps.close();45_IO流(两种方式实现键盘录入)(了解) A:BufferedReader的readLine方法。 BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); B:Scanner ###22.15_IO流(Properties的概述和作为Map集合的使用)(了解) A:Properties的概述 Properties 类表示了一个持久的属性集。 Properties 可保存在流中或从流中加载。 属性列表中每个键及其对应值都是一个字符串。 B:案例演示 Properties作为Map集合的使用 46_IO流(Properties的特殊功能使用)(了解) A:Properties的特殊功能 public Object setProperty(String key,String value) public String getProperty(String key) public Enumeration stringPropertyNames() B:案例演示 Properties的特殊功能 47_IO流(Properties的load()和store()功能)(了解) A:Properties的load()和store()功能 B:案例演示 Properties的load()和store()功能","tags":[]},{"title":"GIS复习【VI】","date":"2019-10-23T08:17:29.370Z","path":"2019/10/23/GIS复习【VI】/","text":"文章较长，建议从目录选取感兴趣内容，然后Ctry+F搜索、跳转 目录13、数据库与空间数据库14、数据库的数据模型15、空间数据的组织方式16、ArcGIS中的数据方式 ——————————————————正文——————————————————- 13、数据库与空间数据库 数据库概述 数据管理技术的发展过程 人工管理阶段–&gt;文件管理阶段–&gt;数据库管理阶段 建立数据库的目的 保存数据 管理和控制与这些数据相关联的事物。 数据库定义： 为了一定的目的，在计算机系统中以特定的结构组织、存储、管理和应用的相关联的数据集合。 数据组织层次 数据项(元素/基本项/字段)：定义数据的最小单位 记录：由若干相关联的数据项组成 文件：一给定类型的记录的全部具体值的集合 数据库：若干文件的集合。 5. 逻辑关系 - 1：1 - 1：N - M：N 空间数据的特征 空间分布特征 空间对象隐含了空间分布特征,需要按照位置进行空间对象的检索 非结构化特征 用一条记录表达一个空间对象，它的数据项可能是很长的，例如，1条弧段的坐标，它可能是2对坐标，也可能是10万对坐标。 非结构化是空间数据难以直接采用通用的关系型 数据库管理系统的主要原因。 空间关系特征 空间数据库中记录的拓扑信息表达了多种空间关系 分类编码特征 基础地理信息要素分类与代码 海量数据特征 多尺度与多态性 X 空间数据库 定义 应用于地理空间数据处理与信息分析领域的具有工程性质的数据库。 是存取、管理空间信息的数据库。 特点： 数据量特别大 属性数据和空间数据联合管理 数据应用范围广泛 2. 数据库与空间数据库的比较 ![](https://img-blog.csdnimg.cn/20190420141933619.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70) 3. 一般组成 ![](https://img-blog.csdnimg.cn/20190420141947749.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70) 1. 栅格数据库 - 遥感影像数据 - DEM数据 2. 矢量数据库 - 各种空间实体数据（图形和属性数据） 14、数据库的数据模型 传统数据库的数据模型 层次模型（1:n） ![](https://img-blog.csdnimg.cn/20190420142005598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70) 结点代表数据记录，连线描述位于不同结点数据间的从属关系 2. 网状模型（m:n） ![](https://img-blog.csdnimg.cn/2019042014204620.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70) 没有明确的从属关系 3. 关系模型 ![](https://img-blog.csdnimg.cn/20190420142056423.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70) - 实体本身的信息以及实体之间的联系均表现为二维表，这种表就称为关系 - 一个实体由若干个关系组成，而关系表的集合就构成为关系模型。 - 关系模型用关系代数和关系运算来操纵数据 面向对象的数据模型 定义 以对象作为最基本的元素 面向对象的几何抽象类型 面向对象的属性数据模型 面向对象数据库系统的实现方式 特点：有效地表达空间数据的拓扑关系。表达和处理属性数据时，具有独特的优越性。 练习 4.1 数据管理技术发展的三个阶段？答：人工管理阶段–&gt;文件管理阶段–&gt;数据库管理阶段 空间数据的五大特征？答：分布特征、非结构化特征、空间关系特征、分类编码特征、海量数据特征。 空间数据库的定义与一般构成？答：定义：应用于地理空间数据处理于信息分析领域的具有工程性质，存取、管理空间信息的数据库。一般构成：矢量数据库（图形和属性）、栅格数据库（影响和高程模型） 传统数据库的数据模型有哪三种？答：层次模型（1：n）、网状模型（m：n）、关系模型 15、空间数据的组织方式 矢量数据组织 位置数据和属性数据通常是分开组织 文件与关系数据库混合管理 两个子系统分别存储和检索空间数据和属性数据，使用一种标识符将两者联系起来。缺点： 查询运算，模型操作运算速度慢； 数据分布和共享困难； 数据的安全性、一致性、完整性、并发控制以及数据损坏后的恢复方面 全关系型空间数据库管理 图形数据与属性数据都采用关系型数据库存储。 本质：将图形数据的变长部分（坐标数据）当作一个二进制块，交由关系数据库管理系统进行存贮和管理。 特点：不必进行烦琐的连接 对象-关系数据库管理 对现有的关系数据库进行扩展，增加空间数据类型 解决了空间数据的变长记录的管理 它仍然没有解决对象的嵌套问题，空间数据结构也不能由用户任意定义 扩展方式： 加一个空间数据管理引擎 由数据库管理系统的软件商在关系数据库管理系统中进行空间数据管理的专用模块扩展，定义操纵点、线、面、圆、长方形等空间对象的API（Application Programming Interface）函数。 栅格数据组织 影像数据和数字高程模型 基于文件的影像数据库管理 目前大部分GIS软件和遥感图像处理软件都是采用文件方式来管理遥感影像数据。 2. 文件结合数据库管理 影像数据仍按照文件方式组织管理；在关系数据库中，每个文件都有唯一的标识号（ID）对应影像信息，如文件名称、存储路径等 3. 关系数据库管理 将影像数据存储在二进制变长字段中，影像数据的元数据信息也存放在关系数据库的表中，二者可以进行无缝管理。 **特点：** - 易于共享 - 方便管理多数据源和多时态的数据 - 数据的一致性和完整性控制 - 影像数据和元数据集成到一起，能方便的进行交互式查询。 - 不同操作系统平台下运行16、ArcGIS中的数据方式 Coverage ：与shapefile不同的是shapefile文件不存储拓扑信息，因此相对其它数据格式要较少地占用存储空间，在显示和访问效率上要快许多。 Shapefile ：基于文件的存储，不能存储拓扑关系。 Geodatabase ：基于数据库的存储，可以存储拓扑关系。 个人地理数据库 Microsoft Access 数据文件 (.mdb)，2GB数据量限制，单用户数据库，仅适用于 Windows。 文件地理数据库 文件系统的文件夹中保存的ArcGIS所支持类型的 GIS 数据集的集合，单个数据集的大小限制为1TB，单用户数据库，跨平台。 ArcSDE地理数据库 在关系数据库中以表的形式保存的ArcGIS所支持类型的GIS 数据集的集合，可建立在服务器端的网络数据库连接。使用 ArcSDE 技术，数据库大小取决于所关联的DBMS。 练习 4.2 矢量数据的三种组织方式？ 栅格数据组织的三种方式 ArcGIS中文件组织方式？Geodatabase的三种类型？","tags":[]},{"title":"GIS复习【V】","date":"2019-10-23T08:17:29.368Z","path":"2019/10/23/GIS复习【V】/","text":"文章较长，建议从目录选取感兴趣内容，然后Ctry+F搜索、跳转 目录17、空间数据源18、空间数据采集19、空间数据的编辑与处理20、空间数据质量及其精度分析————————————————-正文———————————————————- 17、空间数据源 数据源的分类 图形图像数据： 地图 、工程图、规划图 遥感影像、包括卫星、航空、地面遥感影像等 文本资料数据： 实测数据、野外调查的原始记录 共享数据（可能包含图形图像数据） 其他数据、如调查报告、立法文件等 ![](https://img-blog.csdnimg.cn/20190420151010764.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70) 数据源特征 地图数据 具有共同参考坐标系统的点、线、面的二维平面形式的表示，分为普通地图和专题地图。 在应用地图数据时应注意以下几点： 地图存储介质的缺陷 地图现势性较差 地图投影的转换 遥感影像数据 特征： 能够提供大范围的瞬间静态图像； 能够进行大面积的重复性观测； 大大加宽了人眼所能观察的光谱范围； 空间详细程度高。 实测数据 GPS点位数据、地籍测量数据、观测站点监测数据等通常具有较高的精度和较好的现势性 统计数据 统计数据一般都是和一定范围内的统计单元或观测点联系在一起。 共享数据 多媒体数据 文本资料数据 空间数据采集与处理的基本流程 18、空间数据采集 空间（图形）数据的采集 野外数据采集：平板测量、全野外数字测图、空间定位测量 地图数字化：手扶跟踪数字化、扫描矢量化 摄影测量方法：航空摄影测量、地面摄影测量 遥感图像处理 流程： 观测数据的输入 再生、矫正处理 变化处理 分类处理 处理结果输出 **选择采集方法：** - 数字化设备：数字化仪、扫描仪、遥感与摄影测量设备 - 特点：范围大，速度快 - 使用范围：大面积GIS数据采集、资源普查等 **** - 野外测量：大平板、全站仪、GPS、移动测绘系统 - 特点：精度高、效率较低 - 适合范围：小范围GIS数据采集或局部数据更新 属性数据的采集 属性数据的来源与分类 社会环境 自然环境 资源与能源 2. 属性数据的编码 编码的直接产物就是代码，而分类分级则是编码的基础。 **编码原则：** - 系统性和科学性 - 一致性 - 标准化和通用性 - 编码的简捷性 - 编码的可扩展性 3. 常用的编码分类方法 1. 层次分类编码法：按分类对象的从属和层次关系为排列顺序 2. 多源分类编码法：不同的分类依据分别编码，数字之间没隶属关系。 属性数据和图形数据的连接 19、空间数据的编辑与处理20、空间数据质量及其精度分析","tags":[]},{"title":"GIS复习【III】","date":"2019-10-23T08:17:29.367Z","path":"2019/10/23/GIS复习【III】/","text":"文章较长，建议从目录选取感兴趣内容，然后Ctry+F搜索、跳转 目录6、空间数据模型+7、栅格数据结构++8、矢量数据结构++9、矢量与栅格的比较与选择++10、矢栅一体化11、镶嵌数据结构12、三维数据结构+ ——————————————————–正文—————————————————————- 6、空间数据模型*数据模型是对现实世界进行认知、简化和抽象表达 空间实体抽象的三个层次 空间数据模型概念 对象模型 场模型 网络模型 空间逻辑数据模型 矢量数据模型 栅格数据模型 矢量-栅格一体化数据模型 镶嵌数据模型 面向对象数据模型 7、栅格数据结构** 概念 定义：将地表划分成为紧密相邻的网格阵列。每个网格的位置由行列号定义，并包含一个代码，以表示该网格的属性。 注意：栅格数据模型是将连续空间离散化，即用二维铺盖或划分覆盖整个连续空间。 特点 属性明显，定位隐含； 数据结构简单； 面向位置的数据结构，难以建立空间对象之间的关系； 比例尺大小为栅格(像元)的大小与地表相应单元的大小之比；存在几何和属性偏差。 属性值的确定 x 中心点法：取位于栅格中心的属性值为该栅格的属性值。 面积占优法：栅格单元属性值为面积最大者。 重要性法：取重要的属性值为栅格属性值。 长度占优法：每个栅格单元的值由该栅格中线段最长的实体的属性来确定。 栅格结构数据获取的途径 手工获取 扫描仪扫描 遥感影像数据 由矢量数据转换而来 栅格数据编码方法** 直接栅格编码 优点：简单、直观，无压缩 缺点：存在大量冗余，精度提高有限制。 完全栅格数据的组织：基于层（波段）、基于行、基于像元。 游程编码长度 数据结构：（A，P），A表示属性值，P代表该游程相同代码重复的个数。 属性变化越少，压缩比例越大，适合于类型区域面积较大的栅格。 - 优点： 1. 栅格加密时，数据量不会明显增加，压缩效率高，最大限度保留原始栅格结构， 2. 编码解码运算简单，且易于检索、叠加、合并等操作，得到广泛应用。 - 缺点：不适合于类型连续变化或类型区域分散的数据。 3. 块状编码 ![](https://img-blog.csdnimg.cn/20190420112711673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70) 对大而简单的多边形更为有效，在合并、插入、检查延伸性、计算面积等操作时有明显的优越性 4. 四叉树编码 **莫顿码** 十进制莫顿码产生过程：十进制的行、列坐标表示为二进制，按位交错，得到二进制再转化为十进制。 1. 四叉树编码 ![](https://img-blog.csdnimg.cn/20190420112725786.png) ![](https://img-blog.csdnimg.cn/20190420112759775.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70) - 图形必须为2n×2n的栅格阵列。 - n 为极限分割次数 - n＋1是四叉树最大层数或最大高度 2. 线性四叉树编码 ![](https://img-blog.csdnimg.cn/2019042011281168.png) ![](https://img-blog.csdnimg.cn/20190420112822376.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70) 3. 二维行程编码 ![](https://img-blog.csdnimg.cn/20190420112836674.png) 4. 带指针的二维行程编码 ![](https://img-blog.csdnimg.cn/20190420112849656.png) ![](https://img-blog.csdnimg.cn/20190420112900448.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70) 优点：有效地计算多边形的数量特征 缺点： - 矢/栅正反变换还不理想 - 建立四叉树耗时 - 修改麻烦 - 不直接体现物体之间的拓扑关系 - 滑动变异 - 失去了内在的相关性 5. 链式编码 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190420112915384.png) ![](https://img-blog.csdnimg.cn/20190420112924164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70) ![](https://img-blog.csdnimg.cn/20190420112940480.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70)8、矢量数据结构** 地理实体 点实体：具有特定的位置而没有长度的实体 线实体：具有长度的实体 特征： 长度：从起点到终点的总长； 弯曲度：用于表示像道路拐弯时弯曲的程度。 方向性：如水流方向,上下游; 公路,单双向之分。 面状实体：又称为多边形、区域等，水对湖泊、岛屿、地块等一类现象的描述 地理实体需要描述的内容： 编码 位置 类型 行为 属性 说明 时间维描述 关系 矢量数据结构定义 通过记录坐标的方式尽可能精确地理实体，坐标空间设为连续，允许任意位置、长度和面积的精确定义。特点：定位明显，属性隐含 获取方式 外业测量 栅格数据转换 跟踪数字化 组织方式 多边形矢量编码 实体式数据结构 只记录空间对象的位置坐标和属性信息，不记录拓扑关系 优点： 结构简单、直观、易实现 缺点： 相邻多边形的公共边界被数字化并存储两次 缺少多边形的邻接信息 处理岛或洞等嵌套问题较麻烦 区别于矢量的简单数据结构,矢量的拓扑空间数据结构的特点是： 点是相互独立的，点连成线，线构成面； 每条线始于起始结点，止于终止结点，并与左右多边形相邻接。 矢量的拓扑空间数据结构主要有： 索引式 双重独立编码结构 链状双重独立编码结构等。 2. 索引式数据结构 将坐标对以顺序方式存储，由点索引与边界线号相联系，以线索引与各多边形相联系，形成树状索引结构 ![](https://img-blog.csdnimg.cn/20190420113037878.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70) ![](https://img-blog.csdnimg.cn/20190420113047593.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70) - 优点： 1. 消除数据的冗余和不一致 2. 邻接信息、岛信息可通过查找公共弧段号查询 - 缺点： 1. 表达拓扑关系繁琐 2. 以人工建立编码表，工作量大，易出错 3. 双重独立式（DIME） 美国人口统计局研制用来进行人口普查分析和制图的，以城市街道为编码的主体 ![](https://img-blog.csdnimg.cn/20190420113058805.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70) - 结点与结点或面域与面域之间是邻接关系。 - 节点与线段或面域与线段之间为关联关系。 4. 链式双重独立式 将若干直线段合为一个弧段(或链段)，每个弧段可以有许多中间点。 ![](https://img-blog.csdnimg.cn/20190420113109643.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70) 特点：拓扑关系明确，也能表达岛信息，而且以弧段为记录单位，满足实际应用需要。 9、矢量与栅格的比较与选择** 选择的原则： 要素还是位置 可获取的数据 定位要素的必要精度 需要什么类型的要素 需要什么类型的拓扑关系 所需空间分析类型 生产地图类型 栅格结构：大范围小比例尺的自然资源、环境、农林业等区域问题的研究。 矢量结构：城市分区或详细规划、土地管理、公用事业管理等方面的应用。 10、矢栅一体化 概念 将矢量面向目标的方法和栅格象元充填的方法结合起来， 采用填满线状目标路径和充填面状目标空间的方法 作为一体化数据结构的基础 点、线、面状地物均采用面向目标的描述方法，因此它保持了矢量的特性，而象元空间充填表达建立了位置与地物的联系，使之具有栅格的性质。 以矢量的方式来组织栅格数据的数据结构。 三个约定 点状地物仅有空间位置，没有形状和面积，在计算机内部仅有一个位置数据。 线状地物有形状但没有面积，在计算机内部需要用一组象元填满整个路径。 面状地物具有形状和面积，在平面上的投影是由边界包围的空间和一组填满路径的象元表达的边界组成。 细分网格法 一体化数据结构是基于栅格的，表达目标的精度受栅格尺寸的限制，可利用细分格网法提高数据的表达精度。 矢栅一体化数据结构设计 ** 线性四叉树(Morton)是基本数据格式 三个约定作为设计点、线、面数据结构的基本依据 细分格网法保证足够精度。 11、镶嵌数据结构**.采用规则或不规则的小面块集合来逼近自然界不规则的地理单元，适合于对连续变化场景的地理现象进行抽象。 **.小面块之间不重叠且能完整铺满整个地理空间。 **.分为规则镶嵌数据模型和不规则镶嵌数据模型。 规则镶嵌数据模型* 用规则的小面块集合来逼近自然界不规则的地理单元。 在实际应用中，普遍采用正方形或矩形进行地理空间的划分。此时的规则镶嵌数据模型就转化为栅格数据模型。 不规则镶嵌数据模型 有限离散的观测样点来表示某地理现象的空间分布规律时，适合于采用不规则镶嵌数据模型。 最典型的不规则镶嵌数据模型有Voronoi图（也称Thiessen多边形）和不规则三角网（Triangular IrregularNetwork，简称TIN）模型。 Thiessen多边形构造** 样本点之间最近样本点的连线。 最邻近的点 外接圆范围内不含有其它离散点 凸四边形 对每个三角形作中垂线。 相邻三角形外心（外接圆圆心）的连线或三角形边垂直平分线与图廓线构成泰森多边形。泰森多边形和Delaunay三角网互为偶图。 特征 每个泰森多边形内仅含有一个离散点； 组成多边形的边总是与两相邻样点的连线垂直，泰森多边形内的点到相应离散点的距离最近； 泰森多边形边上的点到其两边的离散点的距离相等。 2. 不规则三角网 - 三角形大小随样点密度的变化自动变化，所有样点都称为三角形的顶点，当样点密集时生成的三角形小，而样点较稀时则三角形较大。 - 任何一个Delaunay三角形的外接圆不能包含其他任何点在该包围的内部。12、三维数据结构*栅格：将地理实体的三维空间分成细小单元——体元。普遍用八叉树 **矢量：x，y，z，抽象为点、线、面、体，面构成体。 **常用三维边界表示 八叉树结构 依次递归运算，直到每个子区域均为单一值为止。 三维边界表示法 顶点表： 用来表示多面体各顶点的坐标 边表：指出构成多面体某边的两个顶点","tags":[]},{"title":"GIS复习【II】","date":"2019-10-23T08:17:29.365Z","path":"2019/10/23/GIS复习【II】/","text":"目录3、地理空间信息描述4、地理信息数字化描述方法5、空间数据的类型和关系 ————————————————————正文—————————————————————- 3、地理空间信息描述1、地球空间模型 地球的自然表面 地球是一个近似球体，自然表面是一个极其复杂的不规则曲面。 水准面 假设当海水处于完全静止的平衡状态时，从海平面延伸到所有大陆下部，而与地球重力方向处处正交的一个连续、闭合的曲面 海水有潮汐，时高时低，所以水准面有无数个。 水准面的特性是处处与铅垂线相垂直。 不能用数学公式表达 大地体 被大地水准面所包围的形体 大地水准面：通过平均海水面的一个水准面 地球椭球体 起伏是微小的，且形状接近一个扁率极小的椭圆绕短轴旋转所形成的规则椭球体 说明： 视为球体：在制作小比例尺地图时（小于1:500万），因缩小程度很大，可以把地球视为球体，忽略地球扁率。计算更简单，半径约为6371千米。 视为椭球体：制作大比例尺地图时（大于1:100万），为保证精度，必须将地球视为椭球体。 参考椭球体 在某一局部，与大地水准面符合得最好的一个地球椭球体 基准面 地心基准面：使用地球的质心作为原点，使用最广泛的是 WGS 1984 区域基准面：特定区域内与地球表面吻合，大地原点是参考椭球与大地水准面相切的点，例如Beijing54、Xian80 总结 练习题2.1相对同一地理位置，不同的大地基准面，它们的经纬度坐标一样吗？地球椭球体与大地基准面之间的关系是一对一还是一对多？ 答：相对同一地理位置，不同的大地基准面，它们的经纬度坐标是有差异的。椭球体与大地基准面之间的关系是一对多的关系。因为基准面是在椭球体的基础上建立的，但椭球体不能代表基准面，同样的椭球体能定义不同的基准面。 2、地理空间坐标系 球面坐标系统 天文地理坐标系 大地地理坐标系 意义：GIS中的空间数据是地球表层的数据，即使把地球表面看成是一个椭球面，球面坐标也难以计算距离、方向、面积等参数，需将球面坐标转换成平面坐标，形成平面直角坐标 大地地理坐标系 大地测量中以参考椭球面为基准面建立起来的坐标系。 地心大地坐标系 参心大地坐标系 平面直角坐标系统 3、地图投影 定义（什么是） 将地球椭球面上的点映射到平面上的方法 过程（怎么进行） 投影的实质：经纬度坐标 —&gt; 笛卡儿平面直角坐标系 分类（有哪些） 投影面形状 方位 圆锥 圆柱 投影面位置 正轴 斜轴 横轴 投影变形 长度 面积 角度 等距投影：沿某一特定方向上的距离不变。 等角投影：投影前后角度不变。 等积投影：投影前后面积不变。 选择（哪个合适） 各国家的地理信息系统投影—-与该国基本地图系列所用的投影系统一致 各比例尺GIS投影—-与相应比例尺的主要信息源地图所用的投影一致 各地区GIS投影—-与所在区域适用的投影一致 所用投影以等角投影为宜（形状不失真） 各种地理信息系统一般以一种或两种（至多三种）投影系统为其投影坐标系统，以保证地理定位框架的统一 常用投影 高斯—克吕格投影（横轴等角切椭圆柱投影）： 1：50万、 1：25万、1：10万、1：5万、1：2.5万、1：1万、1：5000 兰勃特Lambert投影（正轴等角割圆锥投影） 1：100万 4、地图对地理空间的描述 空间对象 点：有位置，无宽度和长度；抽象的点线：有长度，但无宽度和高度；用来描述线状实体 面：具有长和宽的目标；通常用来表示自然或人工的封闭多边形；一般分为连续面和不连续面 连续面：等值线表示。可以根据等值线的疏密，判断制图对象的变化趋势和分布特征 不连续面：用面状符号表示，符号的轮廓线表示其分布位置和范围，轮廓线内的颜色、网纹、或说明符号表示其质量特征。 2.地图的分类 内容：普通、专题 比例尺 大：&gt; 1:10万 中：1:100万 &lt; &amp;&amp; &lt;1:10万 小：&lt; 1:100万 5、遥感影像对地理空间的描述 卫星遥感可以覆盖全球的每一个角落，航空遥感可以快速获取小范围的详细资料。 遥感影像对空间信息的描述主要是通过不同的颜色和灰度来表示的。 地物的结构、成分、分布等不同，其反射光谱特性和放射光谱特性也各不相同，传感器记录的个种地物在某一波段的电磁辐射发射能量也各不相同，在遥感影像上表现为不同的颜色和灰度信息。 综上，通过遥感影像可以获取大量的空间地物的特征信息。 4、地理信息数字化描述方法对地理信息进行数字化描述，就是要使计算机能够识别地理事物的形状。 计算机显式描述空间实体（栅格数据结构） 河流：栅格中的一系列像元。这些像元都给予相同的编码值或者用相同的颜色、符号、数字、灰度值来表示。 PS：每一个地理实体的形态都是由栅格中的一组像元来构成。 计算机隐式描述空间实体（矢量数据结构） 河流：定义了始点和终点的线及某种连接关系来描述 PS：地理实体的形状和位置由一组坐标对所确定。 5、空间数据的类型和关系 空间数据的分类 空间数据按数据结构分类：矢量数据、栅格数据等 按属性分为： 空间定位数据、非空间属性数据 按几何特征分为：点、线、面、体 空间数据的基本特征 空间：空间对象的位置及与相邻对象的空间关系或拓扑关系 属性：空间对象的专题属性 时间：空间对象随着时间变化引起的空间、属性的变化 空间数据的拓扑关系 拓扑性质：图形保持连续状态下变形，但图形关系不变 拓扑变换：任意拉伸，压缩，但不能扭转或折叠 拓扑元素 点：孤立点、线的端点、面的首尾点、链的连接点。 线：两结点之间的有序弧段，包括链、弧段和线段。 面：若干弧段组成的闭合多边形。 关系分类 拓扑邻接：同类元素之间的拓扑关系 拓扑关联：不同类元素之间的拓扑关系 拓扑包含：空间中不同类或同类但不同级元素之间的拓扑关系（一般只谈面状要素的包含关系） 拓扑连通：空间图形中弧段之间的拓扑关系。 拓扑关系表 ![](https://img-blog.csdnimg.cn/20190420092802745.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbkJvX0M=,size_16,color_FFFFFF,t_70) 点、线、面三种要素之间的拓扑关系 拓扑关系的意义 可以确定一种地理实体相对于另一种地理实体的空间位置关系，这种空间关系不随地图投影而变化； 有利于空间要素的查询 作为工具，重建地理实体。 练习题2.1 如何为地理实体建立可用于确定特定位置的坐标系？ 答： 如何建立地球表面的几何模型？基于地球表面模型，怎么逐步建立坐标系？为什么要进行地图投影？ 答：地球表面是曲面，地图是平面的，他们之间需要映射。这种映射就是投影 地理空间实体的三要素有什么？他们之间的拓扑关系是怎么样的？ 答：点、线、面。关系：邻接、关联、包含、连通 空间数据的基本特征？地理信息的数字化描述方法是什么？ 答：空间特征、属性特征、时间特性。显性描述（栅格）和隐性描述（矢量） 什么是拓扑性质；拓扑变形包括什么? 答：性质：图形保持连续状态下变形，但图形关系不变。变形：任意拉伸，压缩，但不能扭转或折叠 拓扑邻接、拓扑关联； 答：拓扑邻接：同类元素之间的拓扑关系。拓扑关联：不同类元素之间的拓扑关系 空间实体抽象三个层次。 答：空间概念数据模型、空间逻辑数据模型、物理数据模型","tags":[]},{"title":"GIS复习【I】","date":"2019-10-23T08:17:29.363Z","path":"2019/10/23/GIS复习【I】/","text":"文章较长，建议从目录选取感兴趣内容，然后Ctry+F搜索、跳转 目录1、GIS概念2、GIS构成3、GIS的功能及应用 —————————————————-正文—————————————————— 1、GIS概念一、数据与信息 数据 通过数字化或记录下来可以被鉴别的数字、文字、符号、声音、图象等符号。 信息： 用数字、文字、符号、语言等介质来表示事件、事物、现象等的内容、数量或特征，向人们提供现实世界新的事实和知识，是生产、建设、经营、管理、分析和决策的依据。 关系 数据是信息的载体 信息是数据的内涵与解释 形与质的关系 只有数据对实体行为产生影响才成为信息，数据只有经过解释才有意义，成为信息。 二、地理信息和地理信息系统 地理信息 地理信息是有关地理实体的性质、特征和运动状态的表征和一切有用的知识，是对表达地理特征与地理现象之间关系的地理数据的解释。 特性： 空间分布性 数据量大 信息载体的多样性 地理信息系统 在计算机硬件、软件系统支持下，对整个或部分地球表层（包括大气层）空间中的有关地理分布数据进行采集、存储、管理、运算、分析、显示和描述的技术系统。 GIS定义的理解 物理外壳：计算机的技术系统 操作对象：空间数据和属性数据 技术优势： 混合数据结构和有效的数据集成 独特的地理空间分析能力 快速的空间定位搜索和复杂的查询功能 强大的图形创造和可视化表达手段 地理过程的演化模拟和空间决策支持功能 2、GIS构成1、基本硬件构成（单机） 2、GIS硬件组成 局域网 广域网 3、GIS软件组成 4、GIS数据（空间数据、属性数据） 系统分析与处理的对象、构成系统的应用基础 5、“3S”关系 3、GIS的功能及应用1、GIS基本功能 数据采集与编辑 数据存储与管理 数据处理和变换 空间分析和统计 产品制作与显示 二次开发和编程 数据处理： 数据变换： 投影变换、几何纠正、比例尺缩放、误差改正和处理 数据重构： 数据拼接、裁剪、数据压缩、结构转换、格式转换 数据抽取： 类型选择、窗口提取、布尔提取、空间内插 空间分析和统计： 路径分析 生成数字高程模型 2、应用领域 测绘制图 资源管理 城乡规划 国土监测 环境保护 国防军事 练习题1.1 地理信息系统形成于20世纪（60年代） 我国的GIS发展自20世纪（70年代初）起步 世界上第一个地理信息系统起步于（加拿大） （MAPGIS）是中国的 GIS脱胎于（地理学）","tags":[]},{"title":"GIS-Experiment3","date":"2019-10-23T08:17:29.361Z","path":"2019/10/23/GIS-Experiment3/","text":"ArcGIS 操作3第1步 裁剪要素地理处理 —&gt; ArcToolbox —&gt; 分析工具 —&gt; 提取分析 —&gt; 裁剪 第2步 拼接图层 地理处理 —&gt; ArcToolbox —&gt; 数据管理工具 —&gt; 常规 —&gt; 追加 第3步 要素融合 地理处理 —&gt; ArcToolbox —&gt; 数据管理工具 —&gt; 制图综合 —&gt; 融合 第4步 图层合并地理处理 —&gt; ArcToolbox —&gt; 分析工具 —&gt; 叠加分析 —&gt; 联合 第5步 图层相交地理处理 —&gt; ArcToolbox —&gt; 分析工具 —&gt; 叠加分析 —&gt; 相交 第6步 定义投影地理处理 —&gt; ArcToolbox —&gt; 数据管理工具 —&gt; 投影和变换 —&gt; 定义投影 第7步 投影变换地理处理 —&gt; ArcToolbox —&gt; 数据管理工具 —&gt; 投影和变换 —&gt; 要素 —&gt; 投影","tags":[]},{"title":"Eclipse基本配置（eclipse初使用必看，从小白到大白）","date":"2019-10-23T08:17:29.360Z","path":"2019/10/23/Eclipse基本配置（eclipse初使用必看，从小白到大白）/","text":"一个好的集成开发工具能够让你的开发更加方便，熟练使用集成开发工具，能让你的开发事半功倍！ (Eclipse的视窗和视图概述)(了解) A:视窗 每一个基本的窗体被称为视窗 PackageExplorer 显示项目结构，包，类，及资源 Outline 显示类的结构，方便查找，识别，修改 Console 程序运行的结果在该窗口显示 Hierarchy 显示Java继承层次结构，选中类后F4 B:视图 是由某些视窗的组合而成的 Java视图 Debug视图 (Eclipse工作空间的基本配置)(掌握) A:程序的编译和运行的环境配置(一般不改) window – Preferences – Java 编译环境：Compiler 默认选中的就是最高版本。 运行环境：Installed JREs 默认会找你安装的那个JDK。建议配置了Java的环境变量。 问题： 低编译，高运行。可以。 高编译，低运行。不可以。 建议，编译和运行的版本一致。 B:如何去掉默认注释? window – Preferences – Java – Code Style – Code Templates 选择你不想要的内容，通过右边Edit编辑。 注意：请只删除注释部分，不是注释部分的不要删除。 C:行号的显示和隐藏 显示：在代码区域的最左边的空白区域，右键 – Show Line Numbers即可。 隐藏：把上面的动作再做一次。 D:字体大小及颜色 a:Java代码区域的字体大小和颜色： window – Preferences – General – Appearance – Colors And Fonts –Java修改 – Java Edit Text Font b:控制台 window – Preferences – General – Appearance – Colors And Fonts – Debug – Console font c:其他文件 window – Preferences – General – Appearance – Colors And Fonts – Basic – Text Font E:窗体给弄乱了，怎么办? window – Reset Perspective F:控制台找不到了，怎么办? Window–Show View—Console G:取消悬浮提示 window – Preferences – Java–Editor–Hovers。右边将Combined Hover勾去掉。 这样代码的悬浮框就不会自动出现了。如果想看提示，将光标悬浮在代码上，按F2即可。 (Eclipse中内容辅助键的使用)(掌握) A:Alt+/ 起提示作用 B:main+alt+/,syso+alt+/,给出其他提示 C:补充输出语句,选中需要输出的部分,alt+/选择最后一项即可 C:定义自己的alt + / windows–perference-Java-Editor-Templates–New (Eclipse中快捷键的使用)(掌握) A:新建 ctrl + n B:格式化 ctrl+shift+f C:导入包 ctrl+shift+o D:注释 ctrl+/,ctrl+shift+/,ctrl+shift+\\ E:代码上下移动 选中代码alt+上/下箭头 F:查看源码 选中类名(F3或者Ctrl+鼠标点击) G:查找具体的类 ctrl + shift + t H:查找具体类的具体方法 ctrl + o I:给建议 ctrl+1,根据右边生成左边的数据类型,生成方法 J:删除代码 ctrl + d K:抽取方法alt + shift + m L:改名alt + shift + r (Eclipse中如何提高开发效率)(掌握) alt + shift + s A:自动生成构造方法 B:自动生成get/set方法 (Eclipse中如何生成jar包并导入到项目中)(了解) A:jar是什么? jar是多个class文件的压缩包。 B:jar有什么用? 用别人写好的东西 C:打jar包 选中项目–右键–Export–Java–Jar–自己指定一个路径和一个名称–Finish D:导入jar包 复制到项目路径下并添加至构建路径。 (Eclipse中如何删除项目和导入项目)(掌握) A:删除项目 选中项目 – 右键 – 删除 从项目区域中删除 从硬盘上删除 B:导入项目 在项目区域右键找到import 找到General，展开，并找到 Existing Projects into Workspace 点击next,然后选择你要导入的项目 注意：这里选择的是项目名称 (Eclipse中断点调试的基本使用)(了解) A:Debug的作用 调试程序 查看程序执行流程 B:如何查看程序执行流程 什么是断点： 就是一个标记，从哪里开始。 如何设置断点： 你想看哪里的程序，你就在那个有效程序的左边双击即可。 在哪里设置断点： 哪里不会点哪里。 目前：我们就在每个方法的第一条有效语句上都加。 如何运行设置断点后的程序： 右键 – Debug as – Java Application 看哪些地方： Debug：断点测试的地方 在这个地方，记住F6，或者点击也可以。一次看一行的执行过程。 Variables：查看程序的变量变化 ForDemo：被查看的源文件 Console：控制台 如何去断点： a:再次双击即可 b:找到Debug视图，Variables界面，找到Breakpoints，并点击，然后看到所有的断点，最后点击那个双叉。 (Eclipse查看Java中参数传递问题)(了解) A:断点演示 断点查看Java中参数传递问题","tags":[]},{"title":"Colletion集合","date":"2019-10-23T08:17:29.358Z","path":"2019/10/23/Colletion集合/","text":"(对象数组的概述和使用) A:案例演示 需求：我有5个学生，请把这个5个学生的信息存储到数组中，并遍历数组，获取得到每一个学生信息。 Student[] arr = new Student[5]; //存储学生对象 arr[0] = new Student(&quot;张三&quot;, 23); arr[1] = new Student(&quot;李四&quot;, 24); arr[2] = new Student(&quot;王五&quot;, 25); arr[3] = new Student(&quot;赵六&quot;, 26); arr[4] = new Student(&quot;马哥&quot;, 20); for (int i = 0; i &lt; arr.length; i++) { System.out.println(arr[i]); } B:画图演示 把学生数组的案例画图讲解 数组和集合存储引用数据类型,存的都是地址值 (集合的由来及集合继承体系图) A:集合的由来 数组长度是固定,当添加的元素超过了数组的长度时需要对数组重新定义,太麻烦,java内部给我们提供了集合类,能存储任意对象,长度是可以改变的,随着元素的增加而增加,随着元素的减少而减少 B:数组和集合的区别 区别1 : 数组既可以存储基本数据类型,又可以存储引用数据类型,基本数据类型存储的是值,引用数据类型存储的是地址值 集合只能存储引用数据类型(对象)集合中也可以存储基本数据类型,但是在存储的时候会自动装箱变成对象 区别2: 数组长度是固定的,不能自动增长 集合的长度的是可变的,可以根据元素的增加而增长 C:数组和集合什么时候用* 1,如果元素个数是固定的推荐用数组 * 2,如果元素个数不是固定的推荐用集合 D:集合继承体系图 (Collection集合的基本功能测试) A:案例演示 基本功能演示 boolean add(E e) boolean remove(Object o) void clear() boolean contains(Object o) boolean isEmpty() int size() B:注意: collectionXxx.java使用了未经检查或不安全的操作. 注意:要了解详细信息,请使用 -Xlint:unchecked重新编译. java编译器认为该程序存在安全隐患 温馨提示:这不是编译失败,所以先不用理会,等学了泛型你就知道了 (集合的遍历之集合转数组遍历) A:集合的遍历 其实就是依次获取集合中的每一个元素。 B:案例演示 把集合转成数组，可以实现集合的遍历 toArray() Collection coll = new ArrayList(); coll.add(new Student(&quot;张三&quot;,23)); //Object obj = new Student(&quot;张三&quot;,23); coll.add(new Student(&quot;李四&quot;,24)); coll.add(new Student(&quot;王五&quot;,25)); coll.add(new Student(&quot;赵六&quot;,26)); Object[] arr = coll.toArray(); //将集合转换成数组 for (int i = 0; i &lt; arr.length; i++) { Student s = (Student)arr[i]; //强转成Student System.out.println(s.getName() + &quot;,&quot; + s.getAge()); } (Collection集合的带All功能测试) A:案例演示 带All的功能演示 boolean addAll(Collection c) boolean removeAll(Collection c) boolean containsAll(Collection c) boolean retainAll(Collection c) (集合的遍历之迭代器遍历) A:迭代器概述 集合是用来存储元素,存储的元素需要查看,那么就需要迭代(遍历) B:案例演示 迭代器的使用 Collection c = new ArrayList(); c.add(&quot;a&quot;); c.add(&quot;b&quot;); c.add(&quot;c&quot;); c.add(&quot;d&quot;); Iterator it = c.iterator(); //获取迭代器的引用 while(it.hasNext()) { //集合中的迭代方法(遍历) System.out.println(it.next()); } (Collection存储自定义对象并遍历) A:案例演示 Collection存储自定义对象并用迭代器遍历 Collection c = new ArrayList(); c.add(new Student(&quot;张三&quot;,23)); c.add(new Student(&quot;李四&quot;,24)); c.add(new Student(&quot;王五&quot;,25)); c.add(new Student(&quot;赵六&quot;,26)); c.add(new Student(&quot;赵六&quot;,26)); for(Iterator it = c.iterator();it.hasNext();) { Student s = (Student)it.next(); //向下转型 System.out.println(s.getName() + &quot;,&quot; + s.getAge()); //获取对象中的姓名和年龄 } System.out.println(&quot;------------------------------&quot;); Iterator it = c.iterator(); //获取迭代器 while(it.hasNext()) { //判断集合中是否有元素 //System.out.println(((Student)(it.next())).getName() + &quot;,&quot; + ((Student)(it.next())).getAge()); Student s = (Student)it.next(); //向下转型 System.out.println(s.getName() + &quot;,&quot; + s.getAge()); //获取对象中的姓名和年龄 } (迭代器的原理及源码解析)(了解) A:迭代器原理 迭代器原理:迭代器是对集合进行遍历,而每一个集合内部的存储结构都是不同的,所以每一个集合存和取都是不一样,那么就需要在每一个类中定义hasNext()和next()方法,这样做是可以的,但是会让整个集合体系过于臃肿,迭代器是将这样的方法向上抽取出接口,然后在每个类的内部,定义自己迭代方式,这样做的好处有二,第一规定了整个集合体系的遍历方式都是hasNext()和next()方法,第二,代码有底层内部实现,使用者不用管怎么实现的,会用即可 B:迭代器源码解析 1,在eclipse中ctrl + shift + t找到ArrayList类 2,ctrl+o查找iterator()方法 3,查看返回值类型是new Itr(),说明Itr这个类实现Iterator接口 4,查找Itr这个内部类,发现重写了Iterator中的所有抽象方法 (List集合的特有功能概述和测试) A:List集合的特有功能概述 void add(int index,E element) E remove(int index) E get(int index) E set(int index,E element) (List集合存储学生对象并遍历) A:案例演示 通过size()和get()方法结合使用遍历。 List list = new ArrayList(); list.add(new Student(&quot;张三&quot;, 18)); list.add(new Student(&quot;李四&quot;, 18)); list.add(new Student(&quot;王五&quot;, 18)); list.add(new Student(&quot;赵六&quot;, 18)); for(int i = 0; i &lt; list.size(); i++) { Student s = (Student)list.get(i); System.out.println(s.getName() + &quot;,&quot; + s.getAge()); } (并发修改异常产生的原因及解决方案) A:案例演示 需求：我有一个集合，请问，我想判断里面有没有”world”这个元素，如果有，我就添加一个”javaee”元素，请写代码实现。 List list = new ArrayList(); list.add(&quot;a&quot;); list.add(&quot;b&quot;); list.add(&quot;world&quot;); list.add(&quot;d&quot;); list.add(&quot;e&quot;); /*Iterator it = list.iterator(); while(it.hasNext()) { String str = (String)it.next(); if(str.equals(&quot;world&quot;)) { list.add(&quot;javaee&quot;); //这里会抛出ConcurrentModificationException并发修改异常 } }*/ B:ConcurrentModificationException出现 迭代器遍历，集合修改集合 C:解决方案 a:迭代器迭代元素，迭代器修改元素(ListIterator的特有功能add) b:集合遍历元素，集合修改元素 ListIterator lit = list.listIterator(); //如果想在遍历的过程中添加元素,可以用ListIterator中的add方法 while(lit.hasNext()) { String str = (String)lit.next(); if(str.equals(&quot;world&quot;)) { lit.add(&quot;javaee&quot;); //list.add(&quot;javaee&quot;); } } (ListIterator)(了解) boolean hasNext()是否有下一个 boolean hasPrevious()是否有前一个 Object next()返回下一个元素 Object previous();返回上一个元素 (Vector的特有功能)(了解) A:Vector类概述 B:Vector类特有功能 public void addElement(E obj) public E elementAt(int index) public Enumeration elements() C:案例演示 Vector的迭代 Vector v = new Vector(); //创建集合对象,List的子类 v.addElement(&quot;a&quot;); v.addElement(&quot;b&quot;); v.addElement(&quot;c&quot;); v.addElement(&quot;d&quot;); //Vector迭代 Enumeration en = v.elements(); //获取枚举 while(en.hasMoreElements()) { //判断集合中是否有元素 System.out.println(en.nextElement());//获取集合中的元素 } (数据结构之数组和链表) A:数组 查询快修改也快 增删慢 B:链表 查询慢,修改也慢 增删快 (List的三个子类的特点) A:List的三个子类的特点 ArrayList: 底层数据结构是数组，查询快，增删慢。 线程不安全，效率高。 Vector: 底层数据结构是数组，查询快，增删慢。 线程安全，效率低。 Vector相对ArrayList查询慢(线程安全的) Vector相对LinkedList增删慢(数组结构) LinkedList: 底层数据结构是链表，查询慢，增删快。 线程不安全，效率高。 Vector和ArrayList的区别 Vector是线程安全的,效率低 ArrayList是线程不安全的,效率高 共同点:都是数组实现的 ArrayList和LinkedList的区别 ArrayList底层是数组结果,查询和修改快 LinkedList底层是链表结构的,增和删比较快,查询和修改比较慢 共同点:都是线程不安全的 B:List有三个儿子，我们到底使用谁呢? 查询多用ArrayList 增删多用LinkedList 如果都多ArrayList","tags":[]},{"title":"ArcGIS API for JavaScript","date":"2019-10-23T08:17:29.356Z","path":"2019/10/23/ArcGIS API for JavaScript/","text":"ArcGIS API for JavaScript 是 Esri公司根据js实现的地图方面的调用脚本。1. WebGIS必备: ArcGIS API for JavaScript（下文中用ArcJS代替） ArcGIS Sever（下文中用ArcSer代替） 2. ArcJS作用： 通过ArcSer的REST API调用地图服务，提供显示，查询，分析，缓冲区等功能。 调用ArcGIS Server的GP服务，得到分析结果 同时调用多个ArcGIS Server服务，实现服务聚合 3.入门路线 加载 小部件 查询 基础功能 分析渲染 此路线为博主学习路线。。 4.学习链接API 3.X 加载 动态地图加载 加载动态图层 + 注册文件夹 闪烁Layer(js入门) 小部件 绑定小部件 鹰眼图 图例 查询 FindTask属性查询 QueryTask属性查询 QueryTask空间查询 QueryTask空间+属性查询 GraphicsLayer的属性查询 查询+echarts交互 基础功能 地理编码 地图打印 几何服务_缓冲区 交互画图 具体坐标生成Graphic 分析 网络分析 影像分析 渲染 唯一值渲染 分类渲染 服务器分类渲染 扩展 卷帘 小操作 API 4.X 加载 动态地图加载api 4.x 联动 联动","tags":[]},{"title":"21 - 节点操作集合（添加，删除，替换，复制）","date":"2019-10-23T08:17:29.355Z","path":"2019/10/23/21 - 节点操作集合（添加，删除，替换，复制）/","text":"添加 内部添加 会将元素添加到指定元素内部的最后 $(&quot;ul&quot;).append($li); $li.appendTo(&quot;ul&quot;); 会将元素添加到指定元素内部的最前面 $(&quot;ul&quot;).prepend($li); $li.prependTo(&quot;ul&quot;); 外部添加 会将元素添加到指定元素外部的后面 $(&quot;ul&quot;).after($li); $li.insertAfter(&quot;ul&quot;); 会将元素添加到指定元素外部的前面 $(&quot;ul&quot;).before($li); $li.insertAfter(&quot;ul&quot;); 删除 利用remove删除之后再重新添加,原有的事件无法响应$(&quot;div&quot;).remove(); 利用detach删除之后再重新添加,原有事件可以响应$(&quot;div&quot;).detach(); 替换//将h1替换为h6 $(&quot;h1&quot;).replaceWith($h6); $h6.replaceAll(&quot;h1&quot;);复制 浅复制：只复制元素, 不会复制元素的事件 var $li = $(&quot;li:first&quot;).clone(false); 深复制：会复制元素, 而且还会复制元素的事件 var $li = $(&quot;li:first&quot;).clone(true);","tags":[]},{"title":"20 - 图标特效，无限滚动循环练习","date":"2019-10-23T08:17:29.352Z","path":"2019/10/23/20 - 图标特效，无限滚动循环练习/","text":"图标特效&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;49-图标特效&lt;/title&gt; &lt;style&gt; *{ margin: 0; padding: 0; } ul{ list-style: none; width: 400px; height: 250px; border: 1px solid #000; margin: 100px auto; } ul&gt;li{ width: 100px; height: 50px; margin-top: 50px; text-align: center; float: left; overflow: hidden; } ul&gt;li&gt;span{ display: inline-block; width: 24px; height: 24px; background: url(&quot;images/bg.png&quot;) no-repeat 0 0; position: relative; } &lt;/style&gt; &lt;script src=&quot;js/jquery-1.12.4.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function () { // 1.遍历所有的li $(&quot;li&quot;).each(function (index, ele) { // 1.1生成新的图片位置 var $url = &quot;url(\\&quot;images/bg.png\\&quot;) no-repeat 0 &quot;+(index * -24)+&quot;px&quot; // 1.2设置新的图片位置 $(this).children(&quot;span&quot;).css(&quot;background&quot;, $url); }); // 2.监听li移入事件 $(&quot;li&quot;).mouseenter(function () { // 2.1将图标往上移动 $(this).children(&quot;span&quot;).animate({ top: -50 }, 1000, function () { // 2.2将图片往下移动 $(this).css(&quot;top&quot;, &quot;50px&quot;); // 2.3将图片复位 $(this).animate({ top: 0 }, 1000); }); }); }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;&lt;span&gt;&lt;/span&gt;&lt;p&gt;百度&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;&lt;/span&gt;&lt;p&gt;百度&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;&lt;/span&gt;&lt;p&gt;百度&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;&lt;/span&gt;&lt;p&gt;百度&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;&lt;/span&gt;&lt;p&gt;百度&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;&lt;/span&gt;&lt;p&gt;百度&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;&lt;/span&gt;&lt;p&gt;百度&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;&lt;/span&gt;&lt;p&gt;百度&lt;/p&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt;无限循环滚动&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;50-无限循环滚动&lt;/title&gt; &lt;style&gt; *{ margin: 0; padding: 0; } div{ width: 600px; height: 161px; border: 1px solid #000; margin: 100px auto; overflow: hidden; } ul{ list-style: none; width: 1800px; height: 161px; background: #000; } ul&gt;li{ float: left; } &lt;/style&gt; &lt;script src=&quot;js/jquery-1.12.4.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function () { // 0.定义变量保存偏移位 var offset = 0; // 1.让图片滚动起来 var timer; function autoPlay(){ timer = setInterval(function () { offset += -10; if(offset &lt;= -1200){ offset = 0; } $(&quot;ul&quot;).css(&quot;marginLeft&quot;, offset); }, 50); } autoPlay(); // 2.监听li的移入和移出事件 $(&quot;li&quot;).hover(function () { // 停止滚动 clearInterval(timer); // 给非当前选中添加蒙版 $(this).siblings().fadeTo(100, 0.5); // 去除当前选中的蒙版 $(this).fadeTo(100, 1); }, function () { // 继续滚动 autoPlay(); // 去除所有的蒙版 $(&quot;li&quot;).fadeTo(100, 1); }); }); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;img src=&quot;images/a.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;images/b.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;images/c.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;images/d.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;images/a.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;images/b.jpg&quot; alt=&quot;&quot;&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;","tags":[]},{"title":"19 - jQuery的stop和delay方法","date":"2019-10-23T08:17:29.349Z","path":"2019/10/23/19 - jQuery的stop和delay方法/","text":"立即停止当前动画, 继续执行后续的动画 $(&quot;div&quot;).stop(); $(&quot;div&quot;).stop(false); $(&quot;div&quot;).stop(false, false); 立即停止当前和后续所有的动画 $(&quot;div&quot;).stop(true); $(&quot;div&quot;).stop(true, false); 立即完成当前的, 继续执行后续动画 $(&quot;div&quot;).stop(false, true); 立即完成当前的, 并且停止后续所有的 $(&quot;div&quot;).stop(true, true); 总结一下：第一个参数： true : 停止后续动画 false : 执行后续动画 第二个参数： true : 立即完成当前 false : 立即停止当前 正好相反，不要记错啊。","tags":[]},{"title":"Hello hexo","date":"2019-10-23T08:07:50.037Z","path":"2019/10/23/hello_hexo/","text":"Hello hexo2019/10/16","tags":[]}]